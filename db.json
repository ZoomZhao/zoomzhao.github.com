{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1482825795000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1482825795000},{"_id":"themes/next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1482825795000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1482825795000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1482825795000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1482825795000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1482825795000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1482825795000},{"_id":"themes/next/_config.yml","hash":"3c0c3c2bccc9f040e6fb27a9624216de37469797","modified":1482825795000},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1482825795000},{"_id":"themes/next/gulpfile.coffee","hash":"61ef0606a8134894d7ac796bc8d0fa4ba6a94483","modified":1482825795000},{"_id":"themes/next/package.json","hash":"877cb98025e59015532c4c9a04a33e2af4ad56f9","modified":1482825795000},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1482824092000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1482825795000},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1482825795000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1482825597000},{"_id":"themes/next/.git/index","hash":"17efa393a01c6b0f6982a9a5d0f3c5212eb29ee6","modified":1482825795000},{"_id":"themes/next/.git/packed-refs","hash":"0ff705f5f080495f8b0effec1e4ba3e766012b15","modified":1482825795000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1482825795000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1482825795000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1482825795000},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1482825795000},{"_id":"themes/next/languages/default.yml","hash":"767470a80dc257e23e14c3a78e8c52a46c9d6209","modified":1482825795000},{"_id":"themes/next/languages/en.yml","hash":"40057d6608e825d06e0864bac4dcd27ed88ada87","modified":1482825795000},{"_id":"themes/next/languages/fr-FR.yml","hash":"9fca01ef917d33ae2ae6bc04561ec6799dff5351","modified":1482825795000},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1482825795000},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1482825795000},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1482825795000},{"_id":"themes/next/languages/ru.yml","hash":"257d11e626cbe4b9b78785a764190b9278f95c28","modified":1482825795000},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1482825795000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"f6c9fafa0f5f0050cd07ca2cf5e38fbae3e28145","modified":1482825795000},{"_id":"themes/next/languages/zh-tw.yml","hash":"c97a5c41149de9b17f33439b0ecf0eff6fdae50e","modified":1482825795000},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1482825795000},{"_id":"themes/next/layout/_layout.swig","hash":"7a1e4443c3ba1e08c20e64ddbf0b8255d034dab0","modified":1482825795000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1482825795000},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1482825795000},{"_id":"themes/next/languages/zh-hk.yml","hash":"34c84c6d04447a25bd5eac576922a13947c000e2","modified":1482825795000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1482825795000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1482825795000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1482825795000},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1482825795000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1482825795000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1482825795000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1482825795000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1482825795000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482825795000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1482825597000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1482825597000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1482825597000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1482825597000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1482825597000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1482825597000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1482825597000},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1482825597000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1482825597000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1482825597000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1482825597000},{"_id":"themes/next/.git/logs/HEAD","hash":"44f02c323b227a463bc3fab4b3dab50b00fcbc13","modified":1482825795000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1482825795000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1482825795000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1482825795000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1482825795000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1482825795000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1482825795000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1482825795000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1482825795000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1482825795000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1482825795000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1482825795000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1482825795000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1482825795000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1482825795000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1482825795000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1482825795000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1482825795000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1482825795000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1482825795000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1482825795000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1482825795000},{"_id":"themes/next/layout/_macro/post.swig","hash":"39a8efd961ea2c5758ca4231d3cc4108c1856930","modified":1482825795000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1482825795000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1482825795000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"43d8830bb19da4fc7a5773866be19fa066b62645","modified":1482825795000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4eb278f7b1b7dfe1088c2b411778cc6129df82bb","modified":1482825795000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1482825795000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1482825795000},{"_id":"themes/next/layout/_partials/head.swig","hash":"ca56f92e2fa82b03853869f5073ee1a5626a4796","modified":1482825795000},{"_id":"themes/next/layout/_partials/header.swig","hash":"5696ee15fc21eb3a6416902afcf1df454497c552","modified":1482825795000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"39d613e5a9f8389d4ea52d6082502af8e833b9f2","modified":1482825795000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1482825795000},{"_id":"themes/next/layout/_partials/search.swig","hash":"1431719d1dbba3f5ee385eebc46376d1a960b2d5","modified":1482825795000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1482825795000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1482825795000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1482825795000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1482825795000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1482825795000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482825795000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482825795000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482825795000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482825795000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482825795000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482825795000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1482825795000},{"_id":"themes/next/.git/refs/heads/master","hash":"af778086de84b45cba893f59f046b25a692c10db","modified":1482825795000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1482825795000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"bef514826ebf9eb6e99bb2b0d72285106658a1ec","modified":1482825795000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"3f0d6aa424f434e82ea507f740eeff110f996269","modified":1482825795000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1482825795000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1482825795000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1482825795000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1482825795000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1482825795000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1482825795000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1482825795000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1482825795000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1482825795000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1482825795000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1482825795000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1482825795000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1482825795000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1482825795000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1482825795000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1482825795000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1482825795000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1482825795000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1482825795000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1482825795000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1482825795000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1482825795000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1482825795000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1482825795000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1482825795000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1482825795000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1482825795000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1482825795000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1482825795000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1482825795000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1482825795000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1482825795000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1482825795000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1482825795000},{"_id":"themes/next/source/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1482825795000},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1482825795000},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1482825795000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1482825795000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1482825795000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1482825795000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1482825795000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1482825795000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1482825795000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1482825795000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1482825795000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1482825795000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1482825795000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1482825795000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"394d9fff7951287cc90f52acc2d4cbfd1bae079d","modified":1482825795000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"417e16a0fbdcb1b87987787bd7f9fa17eefc2d2b","modified":1482825795000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1482825795000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"b460e27db3dcd4ab40b17d8926a5c4e624f293a9","modified":1482825795000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1482825795000},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1482825795000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1482825795000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1482825795000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"44f02c323b227a463bc3fab4b3dab50b00fcbc13","modified":1482825795000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1482825795000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1482825795000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1482825795000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1482825795000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1482825795000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1482825795000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1482825795000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1482825795000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1482825795000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1482825795000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1482825795000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1482825795000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1482825795000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1482825795000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1482825795000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1482825795000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1482825795000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1482825795000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1482825795000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"ff9f163bb05c0709577040a875924d36c9ab99d6","modified":1482825795000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1482825795000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"dcf9fe43b2ef78b923118ba39efedb38760e76b1","modified":1482825795000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1482825795000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1482825795000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9b63bd8effc7cf4b96acdea4d73add7df934a222","modified":1482825795000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"7e899c4c0aa1312666f2534a4700667d1bfd88da","modified":1482825795000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1482825795000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1482825795000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1482825795000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1482825795000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1482825795000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1482825795000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1482825795000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1482825795000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1482825795000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1482825795000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1482825795000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1482825795000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1482825795000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1482825795000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1482825795000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1482825795000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1482825795000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1482825795000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1482825795000},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1482825795000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1482825795000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1482825795000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1482825795000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1482825795000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1482825795000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1482825795000},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1482825795000},{"_id":"themes/next/layout/_scripts/third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1482825795000},{"_id":"themes/next/.git/objects/pack/pack-8bb640c26fcb52b24e505f549ed30e41a4bd41af.idx","hash":"8558c74c3b3f97fa9d3085a11ef0db67c9ecb50b","modified":1482825795000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1482825795000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1482825795000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1482825795000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1482825795000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1482825795000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"44f02c323b227a463bc3fab4b3dab50b00fcbc13","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4b7f81e1006e7acee3d1c840ccba155239f830cc","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"7f1aab694caf603809e33cff82beea84cd0128fd","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"c6dab7661a6b8c678b21b7eb273cef7100f970f6","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"3eb73cee103b810fa56901577ecb9c9bb1793cff","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"eba491ae624b4c843c8be4c94a044085dad4ba0f","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"637c6b32c58ecf40041be6e911471cd82671919b","modified":1482825795000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1482825795000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1482825795000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1482825795000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1482825795000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1482825795000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1482825795000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1482825795000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1482825795000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1482825795000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1482825795000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1482825795000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1482825795000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1482825795000},{"_id":"themes/next/.git/objects/pack/pack-8bb640c26fcb52b24e505f549ed30e41a4bd41af.pack","hash":"6be2e8040a103c824f23368fe13e9dca537c8e78","modified":1482825795000},{"_id":"source/.DS_Store","hash":"73a4da4c84ce950f4331cc2715517fdcdd088e13","modified":1482825994000},{"_id":"source/_posts/2012-03-18-css-vertical-align.md","hash":"110c6f31766f590760040bc27994a57198b69a65","modified":1482826381000},{"_id":"source/_posts/2012-11-08-using-the-application-cache.md","hash":"4024eaca1eff4ee91ea602a1b9292c35d4ae2209","modified":1482486946000},{"_id":"source/_posts/2012-11-11-application-cache-is-a-douchebag.md","hash":"ea95bfbe1da80dd8f9f7248cdf99b7cb5d016a46","modified":1482486946000},{"_id":"source/_posts/2015-07-24-mediums-css-is-actually-pretty-fucking-good.md","hash":"5841dcc2b4385516dc46e2ef99db5b21bdf4879f","modified":1482826370000},{"_id":"source/_posts/2015-07-30-medium-style-guide.md","hash":"b31e6554859eecac8fc870c2c207cca14e785e35","modified":1482826318000},{"_id":"source/_posts/2016-12-23-reactivity-system-of-vuejs.md","hash":"c11d4a394147c8462713a01a5933e9d572427412","modified":1482826478000},{"_id":"themes/next/.DS_Store","hash":"54438ce06dc44727067c481a7ed1d7b10b2be6bb","modified":1482826771000},{"_id":"themes/next/source/.DS_Store","hash":"41eda2c7e073c7ca6a9ac46e404de598c80b8938","modified":1482826778000},{"_id":"public/archives/index.html","hash":"4778e9d663c40946aad499838c5634bf239ce243","modified":1482827027880},{"_id":"public/archives/2012/index.html","hash":"9ca1b327081b5e5c6fefef91471ff6ad0676e1dd","modified":1482827027880},{"_id":"public/archives/2012/03/index.html","hash":"ae911eabc68a8fcc0412e07755f2e1fb885126be","modified":1482827027881},{"_id":"public/archives/2012/11/index.html","hash":"6c0eb6b90154fbae1e5143b891982d0b8a71b3a8","modified":1482827027881},{"_id":"public/archives/2015/index.html","hash":"47c19ca7f7febd88b82b87bb32a4cde36cbee9bb","modified":1482827027881},{"_id":"public/archives/2015/07/index.html","hash":"6143980983267a22cd8389ffaf0fe333e56363a7","modified":1482827027881},{"_id":"public/archives/2016/index.html","hash":"b2325fff843e886ae9e39080dc6699bef0d42ab3","modified":1482827027881},{"_id":"public/archives/2016/12/index.html","hash":"14c0ec4a0d4af312a7c45ec32c083e40fefd8a6f","modified":1482827027881},{"_id":"public/categories/front-end/index.html","hash":"20b9246e20df7d7d055c1575baa05bc3ed5ea7c8","modified":1482827027881},{"_id":"public/tags/Application-Cache/index.html","hash":"d8bcc0305137c6a1ae665d354e2c9db2693b79f5","modified":1482827027881},{"_id":"public/tags/AppCache/index.html","hash":"d077f7cca28689f55bf3c41d3ef926c2108cea8f","modified":1482827027881},{"_id":"public/tags/坑/index.html","hash":"e47b8623f7729d10c22f4d4980d52bd4f9a2407d","modified":1482827027881},{"_id":"public/tags/使用/index.html","hash":"53727787d474dc852171fb1e34c4c651bc7f105b","modified":1482827027882},{"_id":"public/tags/Medium/index.html","hash":"354dd1dfc2f3eea1963de6983d87fd40aa48feff","modified":1482827027882},{"_id":"public/tags/CSS/index.html","hash":"44aa482ab40ca4c0a504a2e7671a61336d579ff4","modified":1482827027882},{"_id":"public/2016/12/23/reactivity-system-of-vuejs/index.html","hash":"86016952ab5dbc99f14d9903e8bf1b547b4c37e1","modified":1482827027882},{"_id":"public/2015/07/30/medium-style-guide/index.html","hash":"12c45ba0111efa1f1a113bd41a9be6013003c422","modified":1482827027882},{"_id":"public/2015/07/23/mediums-css-is-actually-pretty-fucking-good/index.html","hash":"06b0c04d4297d5c696c641fe7e86a80c7a0704c4","modified":1482827027882},{"_id":"public/2012/11/11/2012-11-11-application-cache-is-a-douchebag/index.html","hash":"20f01bbdaba0364e6fbab619ba26f70e0ec97c65","modified":1482827027882},{"_id":"public/2012/11/08/2012-11-08-using-the-application-cache/index.html","hash":"eadf8e6d3a8f39917f53f2563df7bfaaf3b14c2e","modified":1482827027882},{"_id":"public/2012/03/18/css-vertical-align/index.html","hash":"786495b9e69404256c7b29f259d0efb3107ef2dd","modified":1482827027882},{"_id":"public/index.html","hash":"7d724068729632a0255d7c5c2a3e579995dea30a","modified":1482827027882},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1482827027896},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1482827027897},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1482827027897},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1482827027897},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1482827027897},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1482827027897},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1482827027897},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1482827027897},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1482827027897},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1482827027897},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1482827027897},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1482827027897},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1482827027898},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1482827027898},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1482827027898},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1482827027898},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1482827027898},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1482827027898},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1482827027898},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1482827027898},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1482827027898},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1482827027898},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1482827027898},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1482827027898},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1482827029232},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1482827029244},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1482827029254},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1482827029255},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1482827029264},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1482827029264},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1482827029264},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1482827029264},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1482827029264},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1482827029264},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1482827029264},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1482827029265},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1482827029265},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1482827029265},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1482827029265},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1482827029265},{"_id":"public/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1482827029265},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1482827029265},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1482827029265},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1482827029265},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1482827029265},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1482827029265},{"_id":"public/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1482827029265},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1482827029265},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1482827029265},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1482827029265},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1482827029265},{"_id":"public/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1482827029265},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1482827029265},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1482827029266},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1482827029266},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1482827029266},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1482827029266},{"_id":"public/css/main.css","hash":"264a09235f615f057dcd37399f5f4897623ed2c2","modified":1482827029266},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1482827029266},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1482827029266},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1482827029266},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1482827029266},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1482827029266},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1482827029266},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1482827029266},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1482827029266},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1482827029266},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1482827029266},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1482827029267},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1482827029283}],"Category":[{"name":"front-end","_id":"cix78b8ly00074as6yysb9q9f"}],"Data":[],"Page":[],"Post":[{"layout":"post","title":"使用 Application Cache","date":"2012-11-07T16:12:02.000Z","_content":" \n原文链接地址 [Using the application cache (MDN)](https://developer.mozilla.org/en/Offline_resources_in_Firefox)\n\n## 简介  \n\nHTML5 提供了一套可以让 web 应用离线运行的机制，开发者可以使用 application cache（AppCache）接口定义浏览器需要缓存的供离线用户使用的资源。即便是用户在离线的情况下刷新页面，被缓存的应用都应该被正确的加载和运行。  \n使用 AppCache 可以给应用带来如下的好处：\n\n* 离线浏览：即便是在离线的情况下用户都可以访问网站。  \n* 速度提升：被缓存的资源是本地的，所以可以加载的更快。  \n* 减小服务器负载：浏览器只会加载服务器端已经更新的资源。\n\n<!-- more -->\n\n## AppCache 的工作方式\n### 使用 AppCache\n想要在应用中使用 AppCache，需要在应用页面的 *html* 节点上增加 *manifest* 属性，如下所示：  \n\n    <html manifest=\"example.appcache\">  \n    ...   \n    </html>\n*manifest* 属性链接到一个 **cache manifest** 文件，文件中列出了应用中需要缓存的资源列表。  \n*manifest* 属性需要包含在每一个需要缓存的页面上。除非被显式的声明，浏览器不会缓存不包含 *manifest* 属性的页面。在 manifest 文件中不需要列出所有希望缓存的页面（pages），对于包含了 *manifest* 属性的页面，浏览器会隐式的将其缓存到 AppCache 中。  \n\n### 加载文档\n使用 AppCache 会影响加载 document 的流程。    \n\n详细的加载主文档以及更新 AppCache 的过程如下所示：  \n\n1. 当浏览器访问一个包含了 *manifest* 属性的页面时，如果 AppCache 不存在，浏览器会加载主文档，然后获取所有在 manifest 文件中列出的资源，创建 AppCache 的第一个版本。\n2. 随后访问页面，从而浏览器会从 AppCache 中加载主文档以及其余的在 manifest 文件中定义的资源（不是从服务器获取）。此外，浏览器会向 [window.applicationCache](https://developer.mozilla.org/en/DOM/window.applicationCache) 对象发送一个 *checking* 事件，通过 HTTP 请求获取 manifest 文件。\n3. 如果当前的 manifest 文件是最新的，浏览器发送一个 *noupdate* 事件给 [window.applicationCache](https://developer.mozilla.org/en/DOM/window.applicationCache) 对象，更新结束。需要强调的是，如果在服务器端更新了任何缓存中的资源文件，必须同时更新 manifest 文件，以保证浏览器知道需要重新获取所有资源。\n4. 如果 manifest 文件已经更新，所有 manifest 文件中列出的文件（包括通过调用  [applicationCache.add()](https://developer.mozilla.org/en/nsIDOMOfflineResourceList#add.28.29) 添加的资源）都会遵循基础的 HTTP 缓存规则，被加载到一个临时缓存中。对于每一个加载到临时缓存区的文件，浏览器会发送一个 *progress* 事件给 *applicationCache* 对象，如果过程中出现了任何错误，浏览器会发送一个 *error* 事件，停止更新的过程。\n5. 当浏览器收到所有的文件之后，他们自动会被移动到一个实际的离线缓存区，同时 *cahced* 事件被发送给 *applicationCache* 对象。由于主文档已经被从缓存中加载到浏览器中，已经更新的文档除非重新加载（包括人工或者程序内部）都不会被重新渲染。\n\n### 缓存存储位置以及 AppCache 的清除\n\n在 Chrome 中，可以通过点击 “preferences” 下的 “Clear browsing data...” 或者访问 [chrome://appcache-internals/](chrome://appcache-internals/) 来清除离线缓存。Safari 在 “preferences” 中有一个类似的 “Empty cache” 设置项，但是设置之后需要重启浏览器。\n\nAppCache 同样可以过时，如果应用的 manifest 文件被从服务器端删除，浏览器会删除使用 manifest 的所有应用缓存，同时发送 *obsoleted* 事件给 *applicationCache* 对象。AppCache 的状态被设置为 OBSOLETE。\n\n## manifest 文件\n\n### 引用一个 manifest 文件\n\nweb 应用中的 *manifest* 属性，可以通过相对路径和绝对路径（需要和 web 应用在同一个域下）两种方式进行。manifest 文件可以有任意的后缀，但是 MIME type 必须是 *text/cache-manifest*。\n\n### manifest 文件中的条目\n\nmanifest 文件是一个列出了浏览器需要缓存的文件的简单文本文件。资源通过 URI 进行识别。manifest 中列出的条目必须和 manifest 具有相同的域名和端口。\n\n### 示例1：一个简单的 manifest 文件\n下面是一个简单 manifest 文件示例， 示例网站 www.example.com 下的 *example.appcache*。\n\n```\nCACHE MANIFEST  \n# v1 - 2011-08-13  \n# This is a comment.  \nhttp://www.example.com/index.html    \nhttp://www.example.com/header.png  \nhttp://www.example.com/blah/blah  \n```\n \nmanifest 文件可以包含三段 （CACHE、NETWORK 和 FALLBACK）。在上面的示例中，没有分段，所以所有的列出的行都会被放到默认的段（CACHE）中去，表示浏览器应该在 AppCache 中缓存所有的资源。\n\n示例中的 “v1” 存在的原因如下：浏览器仅在 manifest 文件变化后才会更新 AppCache，如果更新了一个缓存了的资源（例如，更新了缓存中的 *header.png* 文件），必须更新 manifest 文件，从而让浏览器知道它需要更新缓存。对于 manifest 文件的所有修改都是可以的，但是推荐使用修改版本号的形式实现。  \n**注意：不要在 manifest 文件中缓存自身，否则想要通知浏览器 manifest 更新是几乎不可能的**\n\n### manifest 文件中的三段 CACHE，NERWORK 以及 FALLBACK\n一个 manifest 文件可以包含三个分段：CACHE，NETWORK 和 FALLBACK。\n\nCACHE：  \n这是 *manifest* 文件中条目的默认分段，在 CACHE 段中列出的文件在第一次下载后会被缓存。  \nNETWORK：  \n在 NETWORK 段下的文件建立了需要建立网络连接的白名单。即便是用户离线的情况下，所有此段下的资源会绕过缓存。可以使用通配符。  \nFALLBACK：  \nFALLBACK 段下的内容定义了资源不可用的情况下的备用资源。所有此段下的条目包含两个 URI，第一个是资源链接，第二个是备用资源链接。所有的 URI 同样不可以跨域。通配符也是可用的。\n\nCACHE，NETWORk 和 FALLBACK 三个段在 manifest 文件中出现的顺序是随意的，并且每个段在文件中出现的次数没有限制。\n\n### 示例2：一个更加完整的 manifest 文件\n以下是一个假象网站 www.example.com 下的更加完整点的 manifest 文件。  \n\n```\nCACHE MANIFEST  \n# v1 2011-08-14  \n# This is another comment \nindex.html  \ncache.html  \nstyle.css  \nimage1.png\n\n# Use from network if available  \nNETWORK:\nnetwork.html\n\n# Fallback content  \nFALLBACK:   \n/ fallback.html  \n```\n\n示例使用了 NETWORK 和 FALLBACK 段，定义了 `network.html`  必须从直接从服务器获取，`fallback.html` 备网站链接 / 无法访问的情况下访问。\n\n### manifest 文件结构\nmanifest 文件必须以 text/cache-manifest 的 MIME type 返回。  \nmanifest 文件是一个 UTF-8 编码的文本文件，可以包含 BOM 头。文件第一行必须包含 ‘CACHE MANIFEST’ （中间以空格隔开）字符串，MANIFEST 后需要接一个或者多个空白字符，所有其他文本都会被忽略。  \n文件中的其余部分必须由以下各行组成：  \n\n- **空白行**  \n可以使用包含任意多个空格或 Tab 的空白行  \n- **注释**  \n注释行需要以 # 加任意多个空白字符开始，后面可以包含任意字符。只能注释单行，不能注释一个片段。  \n- **段头**  \n共有三个可选的段头取值：  \nCACHE：   切换到缓存段。  \nNETWORK： 切换到白名单段。  \nFALLBACK：切换到备用段。  \n段头可以包含空包字符，但是必须包含 “:” 。\n- **规则**  \n行的格式决定于到底属于哪个段，在 CACHE 段中，每一行是指向需要缓存的资源的 URI 或者 IRI （不能包含通配符）。行的开头和结尾处可以存在空白符。FALLBACK 行包含两个指向资源的 URI 或者 IRI。NETWORK 段中的内容同样包含一个 URI 或 IRI （可以使用通配符 * ）。\n**注意：相对 URI，相对于 manifest 文件的 URI，而不是包含 manifest 的 document**  \n\n## AppCache 中的资源\n一个 AppCache 通常包含一个资源，通过 URI 识别。\n**注意：资源可以属于多个分类，比如可以同时属于 CACHE 和 FALLBACK**  \n资源分类的详情如下：  \n\n- **Master Entries**\nMaster Entries 是任何在 `<html>` 标签中包含了 manifest 属性的  HTML 文件，例如有一个 HTML 文件， http://www.example.com/entry.html，代码如下：\n\n```\n<html manifest=\"example.appcache\">  \n  <h1>Application Cache Example</h1>  \n</html>  \n```\n\n如果 entry.html 并没有在 *example.appcache* 中列出来，访问 entry.html 时，会将其自身作为 Master Entries 加入到 AppCache 中。\n\n- **Explicit Entries**  \nExplicit Entries 是在 manifest 文件中的 CACHE 段中列出的资源。\n\n- **Network entries**\nmanifest 文件中的 NETWORK 段中包含 web 应用需要联网的资源，Network entries 实际上是需要请求服务器而不访问缓存的白名单  \n**注意：在 manifest 文件中简单的覆盖 Master Entries 导致的结果是不确定的，因为 Master Entries 是在后续访问页面时被添加到 AppCache 的**\n\n- **Fallback entries**  \nFallback entries 的用处在资源加载失败时。\n\n## 缓存状态\n\n每个 AppCache 都会有一个状态，用来标示缓存的当前状态，用来相同 manifest URI 的缓存，享有同样的状态，所有的状态列表如下：\n\n- **UNCACHED**  \n特殊值，表明 AppCache 还未被完全初始化。  \n- **IDLE**  \nAppCache 当前不在被更新的过程中。  \n- **CHECKING**  \nmanifest 文件正在被加载或者检查是否已更新。  \n- **DOWNLOADING**  \n资源正在被下载到缓存中，会导致 manifest 中的资源更新。  \n- **UPDATEREADY**  \n存在更新的 AppCache，当新的缓存已经被下载但是没有使用 swapCache 方法更新的时候，相应的会触发 *updateready* 事件，而不是 *cached* 事件。  \n- **OBSOLETE**  \nAppCache 已经过时。  \n\n## 检测 manifest 文件是否已经更新\n\n可以在程序中使用 JavaScript 检测 manifest 文件是否已更新，由于有可能在脚本添加更新的事件监听之前 manifest 文件已经更新，所以脚本应该检查 `window.applicationCache.status`。 \n\n```\nfunction onUpdateReady() {  \n  alert('found new version!');  \n}  \nwindow.applicationCache.addEventListener('updateready', onUpdateReady);  \nif(window.applicationCache.status === window.applicationCache.UPDATEREADY) {  \n  onUpdateReady();  \n}  \n```\n    \n需要手动测试新的 manifest 文件时，可以使用 `window.applicationCache.update()` 方法。\n\n## 需要注意的点\n\n\n- 永远不要通过增加 GET 参数的方式（例如：`other-cached-page.html?parameterName=value`）获取缓存的文件，这会导致浏览器忽略缓存直接从网络获取文件。如果需要链接到有参数传递的资源，在 hash 上增加参数，例如：`other-cached-page.html#whatever?parameterName=value`。  \n- 当应用被缓存后，简单的更新资源文件是不够的。必须手动更新 manifest 文件，从而让浏览器使用新的文件。可以在程序内通过 `window.applicationCache.swapCache()` 方法来更新文件，但是已经被加载的资源不会受影响。\n- 服务器端设置 `*.appcache` 文件的 expires headers 为立即过期是个很好的做法，这样可以避免 manifest 文件被缓存带来的风险。例如，在 Apache 中可以添加如下设置：  \n`ExpiresByType text/cache-manifest \"access plus 0 seconds\"`\n\n","source":"_posts/2012-11-08-using-the-application-cache.md","raw":"---\nlayout: post\ncategory : front-end\ntitle: 使用 Application Cache\ndate: 2012-11-08 00:12:02\ntags : [Application Cache, AppCache, 使用]\n---\n \n原文链接地址 [Using the application cache (MDN)](https://developer.mozilla.org/en/Offline_resources_in_Firefox)\n\n## 简介  \n\nHTML5 提供了一套可以让 web 应用离线运行的机制，开发者可以使用 application cache（AppCache）接口定义浏览器需要缓存的供离线用户使用的资源。即便是用户在离线的情况下刷新页面，被缓存的应用都应该被正确的加载和运行。  \n使用 AppCache 可以给应用带来如下的好处：\n\n* 离线浏览：即便是在离线的情况下用户都可以访问网站。  \n* 速度提升：被缓存的资源是本地的，所以可以加载的更快。  \n* 减小服务器负载：浏览器只会加载服务器端已经更新的资源。\n\n<!-- more -->\n\n## AppCache 的工作方式\n### 使用 AppCache\n想要在应用中使用 AppCache，需要在应用页面的 *html* 节点上增加 *manifest* 属性，如下所示：  \n\n    <html manifest=\"example.appcache\">  \n    ...   \n    </html>\n*manifest* 属性链接到一个 **cache manifest** 文件，文件中列出了应用中需要缓存的资源列表。  \n*manifest* 属性需要包含在每一个需要缓存的页面上。除非被显式的声明，浏览器不会缓存不包含 *manifest* 属性的页面。在 manifest 文件中不需要列出所有希望缓存的页面（pages），对于包含了 *manifest* 属性的页面，浏览器会隐式的将其缓存到 AppCache 中。  \n\n### 加载文档\n使用 AppCache 会影响加载 document 的流程。    \n\n详细的加载主文档以及更新 AppCache 的过程如下所示：  \n\n1. 当浏览器访问一个包含了 *manifest* 属性的页面时，如果 AppCache 不存在，浏览器会加载主文档，然后获取所有在 manifest 文件中列出的资源，创建 AppCache 的第一个版本。\n2. 随后访问页面，从而浏览器会从 AppCache 中加载主文档以及其余的在 manifest 文件中定义的资源（不是从服务器获取）。此外，浏览器会向 [window.applicationCache](https://developer.mozilla.org/en/DOM/window.applicationCache) 对象发送一个 *checking* 事件，通过 HTTP 请求获取 manifest 文件。\n3. 如果当前的 manifest 文件是最新的，浏览器发送一个 *noupdate* 事件给 [window.applicationCache](https://developer.mozilla.org/en/DOM/window.applicationCache) 对象，更新结束。需要强调的是，如果在服务器端更新了任何缓存中的资源文件，必须同时更新 manifest 文件，以保证浏览器知道需要重新获取所有资源。\n4. 如果 manifest 文件已经更新，所有 manifest 文件中列出的文件（包括通过调用  [applicationCache.add()](https://developer.mozilla.org/en/nsIDOMOfflineResourceList#add.28.29) 添加的资源）都会遵循基础的 HTTP 缓存规则，被加载到一个临时缓存中。对于每一个加载到临时缓存区的文件，浏览器会发送一个 *progress* 事件给 *applicationCache* 对象，如果过程中出现了任何错误，浏览器会发送一个 *error* 事件，停止更新的过程。\n5. 当浏览器收到所有的文件之后，他们自动会被移动到一个实际的离线缓存区，同时 *cahced* 事件被发送给 *applicationCache* 对象。由于主文档已经被从缓存中加载到浏览器中，已经更新的文档除非重新加载（包括人工或者程序内部）都不会被重新渲染。\n\n### 缓存存储位置以及 AppCache 的清除\n\n在 Chrome 中，可以通过点击 “preferences” 下的 “Clear browsing data...” 或者访问 [chrome://appcache-internals/](chrome://appcache-internals/) 来清除离线缓存。Safari 在 “preferences” 中有一个类似的 “Empty cache” 设置项，但是设置之后需要重启浏览器。\n\nAppCache 同样可以过时，如果应用的 manifest 文件被从服务器端删除，浏览器会删除使用 manifest 的所有应用缓存，同时发送 *obsoleted* 事件给 *applicationCache* 对象。AppCache 的状态被设置为 OBSOLETE。\n\n## manifest 文件\n\n### 引用一个 manifest 文件\n\nweb 应用中的 *manifest* 属性，可以通过相对路径和绝对路径（需要和 web 应用在同一个域下）两种方式进行。manifest 文件可以有任意的后缀，但是 MIME type 必须是 *text/cache-manifest*。\n\n### manifest 文件中的条目\n\nmanifest 文件是一个列出了浏览器需要缓存的文件的简单文本文件。资源通过 URI 进行识别。manifest 中列出的条目必须和 manifest 具有相同的域名和端口。\n\n### 示例1：一个简单的 manifest 文件\n下面是一个简单 manifest 文件示例， 示例网站 www.example.com 下的 *example.appcache*。\n\n```\nCACHE MANIFEST  \n# v1 - 2011-08-13  \n# This is a comment.  \nhttp://www.example.com/index.html    \nhttp://www.example.com/header.png  \nhttp://www.example.com/blah/blah  \n```\n \nmanifest 文件可以包含三段 （CACHE、NETWORK 和 FALLBACK）。在上面的示例中，没有分段，所以所有的列出的行都会被放到默认的段（CACHE）中去，表示浏览器应该在 AppCache 中缓存所有的资源。\n\n示例中的 “v1” 存在的原因如下：浏览器仅在 manifest 文件变化后才会更新 AppCache，如果更新了一个缓存了的资源（例如，更新了缓存中的 *header.png* 文件），必须更新 manifest 文件，从而让浏览器知道它需要更新缓存。对于 manifest 文件的所有修改都是可以的，但是推荐使用修改版本号的形式实现。  \n**注意：不要在 manifest 文件中缓存自身，否则想要通知浏览器 manifest 更新是几乎不可能的**\n\n### manifest 文件中的三段 CACHE，NERWORK 以及 FALLBACK\n一个 manifest 文件可以包含三个分段：CACHE，NETWORK 和 FALLBACK。\n\nCACHE：  \n这是 *manifest* 文件中条目的默认分段，在 CACHE 段中列出的文件在第一次下载后会被缓存。  \nNETWORK：  \n在 NETWORK 段下的文件建立了需要建立网络连接的白名单。即便是用户离线的情况下，所有此段下的资源会绕过缓存。可以使用通配符。  \nFALLBACK：  \nFALLBACK 段下的内容定义了资源不可用的情况下的备用资源。所有此段下的条目包含两个 URI，第一个是资源链接，第二个是备用资源链接。所有的 URI 同样不可以跨域。通配符也是可用的。\n\nCACHE，NETWORk 和 FALLBACK 三个段在 manifest 文件中出现的顺序是随意的，并且每个段在文件中出现的次数没有限制。\n\n### 示例2：一个更加完整的 manifest 文件\n以下是一个假象网站 www.example.com 下的更加完整点的 manifest 文件。  \n\n```\nCACHE MANIFEST  \n# v1 2011-08-14  \n# This is another comment \nindex.html  \ncache.html  \nstyle.css  \nimage1.png\n\n# Use from network if available  \nNETWORK:\nnetwork.html\n\n# Fallback content  \nFALLBACK:   \n/ fallback.html  \n```\n\n示例使用了 NETWORK 和 FALLBACK 段，定义了 `network.html`  必须从直接从服务器获取，`fallback.html` 备网站链接 / 无法访问的情况下访问。\n\n### manifest 文件结构\nmanifest 文件必须以 text/cache-manifest 的 MIME type 返回。  \nmanifest 文件是一个 UTF-8 编码的文本文件，可以包含 BOM 头。文件第一行必须包含 ‘CACHE MANIFEST’ （中间以空格隔开）字符串，MANIFEST 后需要接一个或者多个空白字符，所有其他文本都会被忽略。  \n文件中的其余部分必须由以下各行组成：  \n\n- **空白行**  \n可以使用包含任意多个空格或 Tab 的空白行  \n- **注释**  \n注释行需要以 # 加任意多个空白字符开始，后面可以包含任意字符。只能注释单行，不能注释一个片段。  \n- **段头**  \n共有三个可选的段头取值：  \nCACHE：   切换到缓存段。  \nNETWORK： 切换到白名单段。  \nFALLBACK：切换到备用段。  \n段头可以包含空包字符，但是必须包含 “:” 。\n- **规则**  \n行的格式决定于到底属于哪个段，在 CACHE 段中，每一行是指向需要缓存的资源的 URI 或者 IRI （不能包含通配符）。行的开头和结尾处可以存在空白符。FALLBACK 行包含两个指向资源的 URI 或者 IRI。NETWORK 段中的内容同样包含一个 URI 或 IRI （可以使用通配符 * ）。\n**注意：相对 URI，相对于 manifest 文件的 URI，而不是包含 manifest 的 document**  \n\n## AppCache 中的资源\n一个 AppCache 通常包含一个资源，通过 URI 识别。\n**注意：资源可以属于多个分类，比如可以同时属于 CACHE 和 FALLBACK**  \n资源分类的详情如下：  \n\n- **Master Entries**\nMaster Entries 是任何在 `<html>` 标签中包含了 manifest 属性的  HTML 文件，例如有一个 HTML 文件， http://www.example.com/entry.html，代码如下：\n\n```\n<html manifest=\"example.appcache\">  \n  <h1>Application Cache Example</h1>  \n</html>  \n```\n\n如果 entry.html 并没有在 *example.appcache* 中列出来，访问 entry.html 时，会将其自身作为 Master Entries 加入到 AppCache 中。\n\n- **Explicit Entries**  \nExplicit Entries 是在 manifest 文件中的 CACHE 段中列出的资源。\n\n- **Network entries**\nmanifest 文件中的 NETWORK 段中包含 web 应用需要联网的资源，Network entries 实际上是需要请求服务器而不访问缓存的白名单  \n**注意：在 manifest 文件中简单的覆盖 Master Entries 导致的结果是不确定的，因为 Master Entries 是在后续访问页面时被添加到 AppCache 的**\n\n- **Fallback entries**  \nFallback entries 的用处在资源加载失败时。\n\n## 缓存状态\n\n每个 AppCache 都会有一个状态，用来标示缓存的当前状态，用来相同 manifest URI 的缓存，享有同样的状态，所有的状态列表如下：\n\n- **UNCACHED**  \n特殊值，表明 AppCache 还未被完全初始化。  \n- **IDLE**  \nAppCache 当前不在被更新的过程中。  \n- **CHECKING**  \nmanifest 文件正在被加载或者检查是否已更新。  \n- **DOWNLOADING**  \n资源正在被下载到缓存中，会导致 manifest 中的资源更新。  \n- **UPDATEREADY**  \n存在更新的 AppCache，当新的缓存已经被下载但是没有使用 swapCache 方法更新的时候，相应的会触发 *updateready* 事件，而不是 *cached* 事件。  \n- **OBSOLETE**  \nAppCache 已经过时。  \n\n## 检测 manifest 文件是否已经更新\n\n可以在程序中使用 JavaScript 检测 manifest 文件是否已更新，由于有可能在脚本添加更新的事件监听之前 manifest 文件已经更新，所以脚本应该检查 `window.applicationCache.status`。 \n\n```\nfunction onUpdateReady() {  \n  alert('found new version!');  \n}  \nwindow.applicationCache.addEventListener('updateready', onUpdateReady);  \nif(window.applicationCache.status === window.applicationCache.UPDATEREADY) {  \n  onUpdateReady();  \n}  \n```\n    \n需要手动测试新的 manifest 文件时，可以使用 `window.applicationCache.update()` 方法。\n\n## 需要注意的点\n\n\n- 永远不要通过增加 GET 参数的方式（例如：`other-cached-page.html?parameterName=value`）获取缓存的文件，这会导致浏览器忽略缓存直接从网络获取文件。如果需要链接到有参数传递的资源，在 hash 上增加参数，例如：`other-cached-page.html#whatever?parameterName=value`。  \n- 当应用被缓存后，简单的更新资源文件是不够的。必须手动更新 manifest 文件，从而让浏览器使用新的文件。可以在程序内通过 `window.applicationCache.swapCache()` 方法来更新文件，但是已经被加载的资源不会受影响。\n- 服务器端设置 `*.appcache` 文件的 expires headers 为立即过期是个很好的做法，这样可以避免 manifest 文件被缓存带来的风险。例如，在 Apache 中可以添加如下设置：  \n`ExpiresByType text/cache-manifest \"access plus 0 seconds\"`\n\n","slug":"2012-11-08-using-the-application-cache","published":1,"updated":"2016-12-23T09:55:46.000Z","_id":"cix78b8kl00014as6u0g495wd","comments":1,"photos":[],"link":"","content":"<p>原文链接地址 <a href=\"https://developer.mozilla.org/en/Offline_resources_in_Firefox\" target=\"_blank\" rel=\"external\">Using the application cache (MDN)</a></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>HTML5 提供了一套可以让 web 应用离线运行的机制，开发者可以使用 application cache（AppCache）接口定义浏览器需要缓存的供离线用户使用的资源。即便是用户在离线的情况下刷新页面，被缓存的应用都应该被正确的加载和运行。<br>使用 AppCache 可以给应用带来如下的好处：</p>\n<ul>\n<li>离线浏览：即便是在离线的情况下用户都可以访问网站。  </li>\n<li>速度提升：被缓存的资源是本地的，所以可以加载的更快。  </li>\n<li>减小服务器负载：浏览器只会加载服务器端已经更新的资源。</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"AppCache-的工作方式\"><a href=\"#AppCache-的工作方式\" class=\"headerlink\" title=\"AppCache 的工作方式\"></a>AppCache 的工作方式</h2><h3 id=\"使用-AppCache\"><a href=\"#使用-AppCache\" class=\"headerlink\" title=\"使用 AppCache\"></a>使用 AppCache</h3><p>想要在应用中使用 AppCache，需要在应用页面的 <em>html</em> 节点上增加 <em>manifest</em> 属性，如下所示：  </p>\n<pre><code>&lt;html manifest=&quot;example.appcache&quot;&gt;  \n...   \n&lt;/html&gt;\n</code></pre><p><em>manifest</em> 属性链接到一个 <strong>cache manifest</strong> 文件，文件中列出了应用中需要缓存的资源列表。<br><em>manifest</em> 属性需要包含在每一个需要缓存的页面上。除非被显式的声明，浏览器不会缓存不包含 <em>manifest</em> 属性的页面。在 manifest 文件中不需要列出所有希望缓存的页面（pages），对于包含了 <em>manifest</em> 属性的页面，浏览器会隐式的将其缓存到 AppCache 中。  </p>\n<h3 id=\"加载文档\"><a href=\"#加载文档\" class=\"headerlink\" title=\"加载文档\"></a>加载文档</h3><p>使用 AppCache 会影响加载 document 的流程。    </p>\n<p>详细的加载主文档以及更新 AppCache 的过程如下所示：  </p>\n<ol>\n<li>当浏览器访问一个包含了 <em>manifest</em> 属性的页面时，如果 AppCache 不存在，浏览器会加载主文档，然后获取所有在 manifest 文件中列出的资源，创建 AppCache 的第一个版本。</li>\n<li>随后访问页面，从而浏览器会从 AppCache 中加载主文档以及其余的在 manifest 文件中定义的资源（不是从服务器获取）。此外，浏览器会向 <a href=\"https://developer.mozilla.org/en/DOM/window.applicationCache\" target=\"_blank\" rel=\"external\">window.applicationCache</a> 对象发送一个 <em>checking</em> 事件，通过 HTTP 请求获取 manifest 文件。</li>\n<li>如果当前的 manifest 文件是最新的，浏览器发送一个 <em>noupdate</em> 事件给 <a href=\"https://developer.mozilla.org/en/DOM/window.applicationCache\" target=\"_blank\" rel=\"external\">window.applicationCache</a> 对象，更新结束。需要强调的是，如果在服务器端更新了任何缓存中的资源文件，必须同时更新 manifest 文件，以保证浏览器知道需要重新获取所有资源。</li>\n<li>如果 manifest 文件已经更新，所有 manifest 文件中列出的文件（包括通过调用  <a href=\"https://developer.mozilla.org/en/nsIDOMOfflineResourceList#add.28.29\" target=\"_blank\" rel=\"external\">applicationCache.add()</a> 添加的资源）都会遵循基础的 HTTP 缓存规则，被加载到一个临时缓存中。对于每一个加载到临时缓存区的文件，浏览器会发送一个 <em>progress</em> 事件给 <em>applicationCache</em> 对象，如果过程中出现了任何错误，浏览器会发送一个 <em>error</em> 事件，停止更新的过程。</li>\n<li>当浏览器收到所有的文件之后，他们自动会被移动到一个实际的离线缓存区，同时 <em>cahced</em> 事件被发送给 <em>applicationCache</em> 对象。由于主文档已经被从缓存中加载到浏览器中，已经更新的文档除非重新加载（包括人工或者程序内部）都不会被重新渲染。</li>\n</ol>\n<h3 id=\"缓存存储位置以及-AppCache-的清除\"><a href=\"#缓存存储位置以及-AppCache-的清除\" class=\"headerlink\" title=\"缓存存储位置以及 AppCache 的清除\"></a>缓存存储位置以及 AppCache 的清除</h3><p>在 Chrome 中，可以通过点击 “preferences” 下的 “Clear browsing data…” 或者访问 <a href=\"chrome://appcache-internals/\" target=\"_blank\" rel=\"external\">chrome://appcache-internals/</a> 来清除离线缓存。Safari 在 “preferences” 中有一个类似的 “Empty cache” 设置项，但是设置之后需要重启浏览器。</p>\n<p>AppCache 同样可以过时，如果应用的 manifest 文件被从服务器端删除，浏览器会删除使用 manifest 的所有应用缓存，同时发送 <em>obsoleted</em> 事件给 <em>applicationCache</em> 对象。AppCache 的状态被设置为 OBSOLETE。</p>\n<h2 id=\"manifest-文件\"><a href=\"#manifest-文件\" class=\"headerlink\" title=\"manifest 文件\"></a>manifest 文件</h2><h3 id=\"引用一个-manifest-文件\"><a href=\"#引用一个-manifest-文件\" class=\"headerlink\" title=\"引用一个 manifest 文件\"></a>引用一个 manifest 文件</h3><p>web 应用中的 <em>manifest</em> 属性，可以通过相对路径和绝对路径（需要和 web 应用在同一个域下）两种方式进行。manifest 文件可以有任意的后缀，但是 MIME type 必须是 <em>text/cache-manifest</em>。</p>\n<h3 id=\"manifest-文件中的条目\"><a href=\"#manifest-文件中的条目\" class=\"headerlink\" title=\"manifest 文件中的条目\"></a>manifest 文件中的条目</h3><p>manifest 文件是一个列出了浏览器需要缓存的文件的简单文本文件。资源通过 URI 进行识别。manifest 中列出的条目必须和 manifest 具有相同的域名和端口。</p>\n<h3 id=\"示例1：一个简单的-manifest-文件\"><a href=\"#示例1：一个简单的-manifest-文件\" class=\"headerlink\" title=\"示例1：一个简单的 manifest 文件\"></a>示例1：一个简单的 manifest 文件</h3><p>下面是一个简单 manifest 文件示例， 示例网站 www.example.com 下的 <em>example.appcache</em>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">CACHE MANIFEST  </div><div class=\"line\"># v1 - 2011-08-13  </div><div class=\"line\"># This is a comment.  </div><div class=\"line\">http://www.example.com/index.html    </div><div class=\"line\">http://www.example.com/header.png  </div><div class=\"line\">http://www.example.com/blah/blah</div></pre></td></tr></table></figure>\n<p>manifest 文件可以包含三段 （CACHE、NETWORK 和 FALLBACK）。在上面的示例中，没有分段，所以所有的列出的行都会被放到默认的段（CACHE）中去，表示浏览器应该在 AppCache 中缓存所有的资源。</p>\n<p>示例中的 “v1” 存在的原因如下：浏览器仅在 manifest 文件变化后才会更新 AppCache，如果更新了一个缓存了的资源（例如，更新了缓存中的 <em>header.png</em> 文件），必须更新 manifest 文件，从而让浏览器知道它需要更新缓存。对于 manifest 文件的所有修改都是可以的，但是推荐使用修改版本号的形式实现。<br><strong>注意：不要在 manifest 文件中缓存自身，否则想要通知浏览器 manifest 更新是几乎不可能的</strong></p>\n<h3 id=\"manifest-文件中的三段-CACHE，NERWORK-以及-FALLBACK\"><a href=\"#manifest-文件中的三段-CACHE，NERWORK-以及-FALLBACK\" class=\"headerlink\" title=\"manifest 文件中的三段 CACHE，NERWORK 以及 FALLBACK\"></a>manifest 文件中的三段 CACHE，NERWORK 以及 FALLBACK</h3><p>一个 manifest 文件可以包含三个分段：CACHE，NETWORK 和 FALLBACK。</p>\n<p>CACHE：<br>这是 <em>manifest</em> 文件中条目的默认分段，在 CACHE 段中列出的文件在第一次下载后会被缓存。<br>NETWORK：<br>在 NETWORK 段下的文件建立了需要建立网络连接的白名单。即便是用户离线的情况下，所有此段下的资源会绕过缓存。可以使用通配符。<br>FALLBACK：<br>FALLBACK 段下的内容定义了资源不可用的情况下的备用资源。所有此段下的条目包含两个 URI，第一个是资源链接，第二个是备用资源链接。所有的 URI 同样不可以跨域。通配符也是可用的。</p>\n<p>CACHE，NETWORk 和 FALLBACK 三个段在 manifest 文件中出现的顺序是随意的，并且每个段在文件中出现的次数没有限制。</p>\n<h3 id=\"示例2：一个更加完整的-manifest-文件\"><a href=\"#示例2：一个更加完整的-manifest-文件\" class=\"headerlink\" title=\"示例2：一个更加完整的 manifest 文件\"></a>示例2：一个更加完整的 manifest 文件</h3><p>以下是一个假象网站 www.example.com 下的更加完整点的 manifest 文件。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">CACHE MANIFEST  </div><div class=\"line\"># v1 2011-08-14  </div><div class=\"line\"># This is another comment </div><div class=\"line\">index.html  </div><div class=\"line\">cache.html  </div><div class=\"line\">style.css  </div><div class=\"line\">image1.png</div><div class=\"line\"></div><div class=\"line\"># Use from network if available  </div><div class=\"line\">NETWORK:</div><div class=\"line\">network.html</div><div class=\"line\"></div><div class=\"line\"># Fallback content  </div><div class=\"line\">FALLBACK:   </div><div class=\"line\">/ fallback.html</div></pre></td></tr></table></figure>\n<p>示例使用了 NETWORK 和 FALLBACK 段，定义了 <code>network.html</code>  必须从直接从服务器获取，<code>fallback.html</code> 备网站链接 / 无法访问的情况下访问。</p>\n<h3 id=\"manifest-文件结构\"><a href=\"#manifest-文件结构\" class=\"headerlink\" title=\"manifest 文件结构\"></a>manifest 文件结构</h3><p>manifest 文件必须以 text/cache-manifest 的 MIME type 返回。<br>manifest 文件是一个 UTF-8 编码的文本文件，可以包含 BOM 头。文件第一行必须包含 ‘CACHE MANIFEST’ （中间以空格隔开）字符串，MANIFEST 后需要接一个或者多个空白字符，所有其他文本都会被忽略。<br>文件中的其余部分必须由以下各行组成：  </p>\n<ul>\n<li><strong>空白行</strong><br>可以使用包含任意多个空格或 Tab 的空白行  </li>\n<li><strong>注释</strong><br>注释行需要以 # 加任意多个空白字符开始，后面可以包含任意字符。只能注释单行，不能注释一个片段。  </li>\n<li><strong>段头</strong><br>共有三个可选的段头取值：<br>CACHE：   切换到缓存段。<br>NETWORK： 切换到白名单段。<br>FALLBACK：切换到备用段。<br>段头可以包含空包字符，但是必须包含 “:” 。</li>\n<li><strong>规则</strong><br>行的格式决定于到底属于哪个段，在 CACHE 段中，每一行是指向需要缓存的资源的 URI 或者 IRI （不能包含通配符）。行的开头和结尾处可以存在空白符。FALLBACK 行包含两个指向资源的 URI 或者 IRI。NETWORK 段中的内容同样包含一个 URI 或 IRI （可以使用通配符 <em> ）。<br><em>*注意：相对 URI，相对于 manifest 文件的 URI，而不是包含 manifest 的 document</em></em>  </li>\n</ul>\n<h2 id=\"AppCache-中的资源\"><a href=\"#AppCache-中的资源\" class=\"headerlink\" title=\"AppCache 中的资源\"></a>AppCache 中的资源</h2><p>一个 AppCache 通常包含一个资源，通过 URI 识别。<br><strong>注意：资源可以属于多个分类，比如可以同时属于 CACHE 和 FALLBACK</strong><br>资源分类的详情如下：  </p>\n<ul>\n<li><strong>Master Entries</strong><br>Master Entries 是任何在 <code>&lt;html&gt;</code> 标签中包含了 manifest 属性的  HTML 文件，例如有一个 HTML 文件， <a href=\"http://www.example.com/entry.html，代码如下：\" target=\"_blank\" rel=\"external\">http://www.example.com/entry.html，代码如下：</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;html manifest=&quot;example.appcache&quot;&gt;  </div><div class=\"line\">  &lt;h1&gt;Application Cache Example&lt;/h1&gt;  </div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>如果 entry.html 并没有在 <em>example.appcache</em> 中列出来，访问 entry.html 时，会将其自身作为 Master Entries 加入到 AppCache 中。</p>\n<ul>\n<li><p><strong>Explicit Entries</strong><br>Explicit Entries 是在 manifest 文件中的 CACHE 段中列出的资源。</p>\n</li>\n<li><p><strong>Network entries</strong><br>manifest 文件中的 NETWORK 段中包含 web 应用需要联网的资源，Network entries 实际上是需要请求服务器而不访问缓存的白名单<br><strong>注意：在 manifest 文件中简单的覆盖 Master Entries 导致的结果是不确定的，因为 Master Entries 是在后续访问页面时被添加到 AppCache 的</strong></p>\n</li>\n<li><p><strong>Fallback entries</strong><br>Fallback entries 的用处在资源加载失败时。</p>\n</li>\n</ul>\n<h2 id=\"缓存状态\"><a href=\"#缓存状态\" class=\"headerlink\" title=\"缓存状态\"></a>缓存状态</h2><p>每个 AppCache 都会有一个状态，用来标示缓存的当前状态，用来相同 manifest URI 的缓存，享有同样的状态，所有的状态列表如下：</p>\n<ul>\n<li><strong>UNCACHED</strong><br>特殊值，表明 AppCache 还未被完全初始化。  </li>\n<li><strong>IDLE</strong><br>AppCache 当前不在被更新的过程中。  </li>\n<li><strong>CHECKING</strong><br>manifest 文件正在被加载或者检查是否已更新。  </li>\n<li><strong>DOWNLOADING</strong><br>资源正在被下载到缓存中，会导致 manifest 中的资源更新。  </li>\n<li><strong>UPDATEREADY</strong><br>存在更新的 AppCache，当新的缓存已经被下载但是没有使用 swapCache 方法更新的时候，相应的会触发 <em>updateready</em> 事件，而不是 <em>cached</em> 事件。  </li>\n<li><strong>OBSOLETE</strong><br>AppCache 已经过时。  </li>\n</ul>\n<h2 id=\"检测-manifest-文件是否已经更新\"><a href=\"#检测-manifest-文件是否已经更新\" class=\"headerlink\" title=\"检测 manifest 文件是否已经更新\"></a>检测 manifest 文件是否已经更新</h2><p>可以在程序中使用 JavaScript 检测 manifest 文件是否已更新，由于有可能在脚本添加更新的事件监听之前 manifest 文件已经更新，所以脚本应该检查 <code>window.applicationCache.status</code>。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function onUpdateReady() &#123;  </div><div class=\"line\">  alert(&apos;found new version!&apos;);  </div><div class=\"line\">&#125;  </div><div class=\"line\">window.applicationCache.addEventListener(&apos;updateready&apos;, onUpdateReady);  </div><div class=\"line\">if(window.applicationCache.status === window.applicationCache.UPDATEREADY) &#123;  </div><div class=\"line\">  onUpdateReady();  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要手动测试新的 manifest 文件时，可以使用 <code>window.applicationCache.update()</code> 方法。</p>\n<h2 id=\"需要注意的点\"><a href=\"#需要注意的点\" class=\"headerlink\" title=\"需要注意的点\"></a>需要注意的点</h2><ul>\n<li>永远不要通过增加 GET 参数的方式（例如：<code>other-cached-page.html?parameterName=value</code>）获取缓存的文件，这会导致浏览器忽略缓存直接从网络获取文件。如果需要链接到有参数传递的资源，在 hash 上增加参数，例如：<code>other-cached-page.html#whatever?parameterName=value</code>。  </li>\n<li>当应用被缓存后，简单的更新资源文件是不够的。必须手动更新 manifest 文件，从而让浏览器使用新的文件。可以在程序内通过 <code>window.applicationCache.swapCache()</code> 方法来更新文件，但是已经被加载的资源不会受影响。</li>\n<li>服务器端设置 <code>*.appcache</code> 文件的 expires headers 为立即过期是个很好的做法，这样可以避免 manifest 文件被缓存带来的风险。例如，在 Apache 中可以添加如下设置：<br><code>ExpiresByType text/cache-manifest &quot;access plus 0 seconds&quot;</code></li>\n</ul>\n","excerpt":"<p>原文链接地址 <a href=\"https://developer.mozilla.org/en/Offline_resources_in_Firefox\">Using the application cache (MDN)</a></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>HTML5 提供了一套可以让 web 应用离线运行的机制，开发者可以使用 application cache（AppCache）接口定义浏览器需要缓存的供离线用户使用的资源。即便是用户在离线的情况下刷新页面，被缓存的应用都应该被正确的加载和运行。<br>使用 AppCache 可以给应用带来如下的好处：</p>\n<ul>\n<li>离线浏览：即便是在离线的情况下用户都可以访问网站。  </li>\n<li>速度提升：被缓存的资源是本地的，所以可以加载的更快。  </li>\n<li>减小服务器负载：浏览器只会加载服务器端已经更新的资源。</li>\n</ul>","more":"<h2 id=\"AppCache-的工作方式\"><a href=\"#AppCache-的工作方式\" class=\"headerlink\" title=\"AppCache 的工作方式\"></a>AppCache 的工作方式</h2><h3 id=\"使用-AppCache\"><a href=\"#使用-AppCache\" class=\"headerlink\" title=\"使用 AppCache\"></a>使用 AppCache</h3><p>想要在应用中使用 AppCache，需要在应用页面的 <em>html</em> 节点上增加 <em>manifest</em> 属性，如下所示：  </p>\n<pre><code>&lt;html manifest=&quot;example.appcache&quot;&gt;  \n...   \n&lt;/html&gt;\n</code></pre><p><em>manifest</em> 属性链接到一个 <strong>cache manifest</strong> 文件，文件中列出了应用中需要缓存的资源列表。<br><em>manifest</em> 属性需要包含在每一个需要缓存的页面上。除非被显式的声明，浏览器不会缓存不包含 <em>manifest</em> 属性的页面。在 manifest 文件中不需要列出所有希望缓存的页面（pages），对于包含了 <em>manifest</em> 属性的页面，浏览器会隐式的将其缓存到 AppCache 中。  </p>\n<h3 id=\"加载文档\"><a href=\"#加载文档\" class=\"headerlink\" title=\"加载文档\"></a>加载文档</h3><p>使用 AppCache 会影响加载 document 的流程。    </p>\n<p>详细的加载主文档以及更新 AppCache 的过程如下所示：  </p>\n<ol>\n<li>当浏览器访问一个包含了 <em>manifest</em> 属性的页面时，如果 AppCache 不存在，浏览器会加载主文档，然后获取所有在 manifest 文件中列出的资源，创建 AppCache 的第一个版本。</li>\n<li>随后访问页面，从而浏览器会从 AppCache 中加载主文档以及其余的在 manifest 文件中定义的资源（不是从服务器获取）。此外，浏览器会向 <a href=\"https://developer.mozilla.org/en/DOM/window.applicationCache\">window.applicationCache</a> 对象发送一个 <em>checking</em> 事件，通过 HTTP 请求获取 manifest 文件。</li>\n<li>如果当前的 manifest 文件是最新的，浏览器发送一个 <em>noupdate</em> 事件给 <a href=\"https://developer.mozilla.org/en/DOM/window.applicationCache\">window.applicationCache</a> 对象，更新结束。需要强调的是，如果在服务器端更新了任何缓存中的资源文件，必须同时更新 manifest 文件，以保证浏览器知道需要重新获取所有资源。</li>\n<li>如果 manifest 文件已经更新，所有 manifest 文件中列出的文件（包括通过调用  <a href=\"https://developer.mozilla.org/en/nsIDOMOfflineResourceList#add.28.29\">applicationCache.add()</a> 添加的资源）都会遵循基础的 HTTP 缓存规则，被加载到一个临时缓存中。对于每一个加载到临时缓存区的文件，浏览器会发送一个 <em>progress</em> 事件给 <em>applicationCache</em> 对象，如果过程中出现了任何错误，浏览器会发送一个 <em>error</em> 事件，停止更新的过程。</li>\n<li>当浏览器收到所有的文件之后，他们自动会被移动到一个实际的离线缓存区，同时 <em>cahced</em> 事件被发送给 <em>applicationCache</em> 对象。由于主文档已经被从缓存中加载到浏览器中，已经更新的文档除非重新加载（包括人工或者程序内部）都不会被重新渲染。</li>\n</ol>\n<h3 id=\"缓存存储位置以及-AppCache-的清除\"><a href=\"#缓存存储位置以及-AppCache-的清除\" class=\"headerlink\" title=\"缓存存储位置以及 AppCache 的清除\"></a>缓存存储位置以及 AppCache 的清除</h3><p>在 Chrome 中，可以通过点击 “preferences” 下的 “Clear browsing data…” 或者访问 <a href=\"chrome://appcache-internals/\">chrome://appcache-internals/</a> 来清除离线缓存。Safari 在 “preferences” 中有一个类似的 “Empty cache” 设置项，但是设置之后需要重启浏览器。</p>\n<p>AppCache 同样可以过时，如果应用的 manifest 文件被从服务器端删除，浏览器会删除使用 manifest 的所有应用缓存，同时发送 <em>obsoleted</em> 事件给 <em>applicationCache</em> 对象。AppCache 的状态被设置为 OBSOLETE。</p>\n<h2 id=\"manifest-文件\"><a href=\"#manifest-文件\" class=\"headerlink\" title=\"manifest 文件\"></a>manifest 文件</h2><h3 id=\"引用一个-manifest-文件\"><a href=\"#引用一个-manifest-文件\" class=\"headerlink\" title=\"引用一个 manifest 文件\"></a>引用一个 manifest 文件</h3><p>web 应用中的 <em>manifest</em> 属性，可以通过相对路径和绝对路径（需要和 web 应用在同一个域下）两种方式进行。manifest 文件可以有任意的后缀，但是 MIME type 必须是 <em>text/cache-manifest</em>。</p>\n<h3 id=\"manifest-文件中的条目\"><a href=\"#manifest-文件中的条目\" class=\"headerlink\" title=\"manifest 文件中的条目\"></a>manifest 文件中的条目</h3><p>manifest 文件是一个列出了浏览器需要缓存的文件的简单文本文件。资源通过 URI 进行识别。manifest 中列出的条目必须和 manifest 具有相同的域名和端口。</p>\n<h3 id=\"示例1：一个简单的-manifest-文件\"><a href=\"#示例1：一个简单的-manifest-文件\" class=\"headerlink\" title=\"示例1：一个简单的 manifest 文件\"></a>示例1：一个简单的 manifest 文件</h3><p>下面是一个简单 manifest 文件示例， 示例网站 www.example.com 下的 <em>example.appcache</em>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">CACHE MANIFEST  </div><div class=\"line\"># v1 - 2011-08-13  </div><div class=\"line\"># This is a comment.  </div><div class=\"line\">http://www.example.com/index.html    </div><div class=\"line\">http://www.example.com/header.png  </div><div class=\"line\">http://www.example.com/blah/blah</div></pre></td></tr></table></figure>\n<p>manifest 文件可以包含三段 （CACHE、NETWORK 和 FALLBACK）。在上面的示例中，没有分段，所以所有的列出的行都会被放到默认的段（CACHE）中去，表示浏览器应该在 AppCache 中缓存所有的资源。</p>\n<p>示例中的 “v1” 存在的原因如下：浏览器仅在 manifest 文件变化后才会更新 AppCache，如果更新了一个缓存了的资源（例如，更新了缓存中的 <em>header.png</em> 文件），必须更新 manifest 文件，从而让浏览器知道它需要更新缓存。对于 manifest 文件的所有修改都是可以的，但是推荐使用修改版本号的形式实现。<br><strong>注意：不要在 manifest 文件中缓存自身，否则想要通知浏览器 manifest 更新是几乎不可能的</strong></p>\n<h3 id=\"manifest-文件中的三段-CACHE，NERWORK-以及-FALLBACK\"><a href=\"#manifest-文件中的三段-CACHE，NERWORK-以及-FALLBACK\" class=\"headerlink\" title=\"manifest 文件中的三段 CACHE，NERWORK 以及 FALLBACK\"></a>manifest 文件中的三段 CACHE，NERWORK 以及 FALLBACK</h3><p>一个 manifest 文件可以包含三个分段：CACHE，NETWORK 和 FALLBACK。</p>\n<p>CACHE：<br>这是 <em>manifest</em> 文件中条目的默认分段，在 CACHE 段中列出的文件在第一次下载后会被缓存。<br>NETWORK：<br>在 NETWORK 段下的文件建立了需要建立网络连接的白名单。即便是用户离线的情况下，所有此段下的资源会绕过缓存。可以使用通配符。<br>FALLBACK：<br>FALLBACK 段下的内容定义了资源不可用的情况下的备用资源。所有此段下的条目包含两个 URI，第一个是资源链接，第二个是备用资源链接。所有的 URI 同样不可以跨域。通配符也是可用的。</p>\n<p>CACHE，NETWORk 和 FALLBACK 三个段在 manifest 文件中出现的顺序是随意的，并且每个段在文件中出现的次数没有限制。</p>\n<h3 id=\"示例2：一个更加完整的-manifest-文件\"><a href=\"#示例2：一个更加完整的-manifest-文件\" class=\"headerlink\" title=\"示例2：一个更加完整的 manifest 文件\"></a>示例2：一个更加完整的 manifest 文件</h3><p>以下是一个假象网站 www.example.com 下的更加完整点的 manifest 文件。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">CACHE MANIFEST  </div><div class=\"line\"># v1 2011-08-14  </div><div class=\"line\"># This is another comment </div><div class=\"line\">index.html  </div><div class=\"line\">cache.html  </div><div class=\"line\">style.css  </div><div class=\"line\">image1.png</div><div class=\"line\"></div><div class=\"line\"># Use from network if available  </div><div class=\"line\">NETWORK:</div><div class=\"line\">network.html</div><div class=\"line\"></div><div class=\"line\"># Fallback content  </div><div class=\"line\">FALLBACK:   </div><div class=\"line\">/ fallback.html</div></pre></td></tr></table></figure>\n<p>示例使用了 NETWORK 和 FALLBACK 段，定义了 <code>network.html</code>  必须从直接从服务器获取，<code>fallback.html</code> 备网站链接 / 无法访问的情况下访问。</p>\n<h3 id=\"manifest-文件结构\"><a href=\"#manifest-文件结构\" class=\"headerlink\" title=\"manifest 文件结构\"></a>manifest 文件结构</h3><p>manifest 文件必须以 text/cache-manifest 的 MIME type 返回。<br>manifest 文件是一个 UTF-8 编码的文本文件，可以包含 BOM 头。文件第一行必须包含 ‘CACHE MANIFEST’ （中间以空格隔开）字符串，MANIFEST 后需要接一个或者多个空白字符，所有其他文本都会被忽略。<br>文件中的其余部分必须由以下各行组成：  </p>\n<ul>\n<li><strong>空白行</strong><br>可以使用包含任意多个空格或 Tab 的空白行  </li>\n<li><strong>注释</strong><br>注释行需要以 # 加任意多个空白字符开始，后面可以包含任意字符。只能注释单行，不能注释一个片段。  </li>\n<li><strong>段头</strong><br>共有三个可选的段头取值：<br>CACHE：   切换到缓存段。<br>NETWORK： 切换到白名单段。<br>FALLBACK：切换到备用段。<br>段头可以包含空包字符，但是必须包含 “:” 。</li>\n<li><strong>规则</strong><br>行的格式决定于到底属于哪个段，在 CACHE 段中，每一行是指向需要缓存的资源的 URI 或者 IRI （不能包含通配符）。行的开头和结尾处可以存在空白符。FALLBACK 行包含两个指向资源的 URI 或者 IRI。NETWORK 段中的内容同样包含一个 URI 或 IRI （可以使用通配符 <em> ）。<br><em>*注意：相对 URI，相对于 manifest 文件的 URI，而不是包含 manifest 的 document</em></em>  </li>\n</ul>\n<h2 id=\"AppCache-中的资源\"><a href=\"#AppCache-中的资源\" class=\"headerlink\" title=\"AppCache 中的资源\"></a>AppCache 中的资源</h2><p>一个 AppCache 通常包含一个资源，通过 URI 识别。<br><strong>注意：资源可以属于多个分类，比如可以同时属于 CACHE 和 FALLBACK</strong><br>资源分类的详情如下：  </p>\n<ul>\n<li><strong>Master Entries</strong><br>Master Entries 是任何在 <code>&lt;html&gt;</code> 标签中包含了 manifest 属性的  HTML 文件，例如有一个 HTML 文件， <a href=\"http://www.example.com/entry.html，代码如下：\">http://www.example.com/entry.html，代码如下：</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;html manifest=&quot;example.appcache&quot;&gt;  </div><div class=\"line\">  &lt;h1&gt;Application Cache Example&lt;/h1&gt;  </div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>如果 entry.html 并没有在 <em>example.appcache</em> 中列出来，访问 entry.html 时，会将其自身作为 Master Entries 加入到 AppCache 中。</p>\n<ul>\n<li><p><strong>Explicit Entries</strong><br>Explicit Entries 是在 manifest 文件中的 CACHE 段中列出的资源。</p>\n</li>\n<li><p><strong>Network entries</strong><br>manifest 文件中的 NETWORK 段中包含 web 应用需要联网的资源，Network entries 实际上是需要请求服务器而不访问缓存的白名单<br><strong>注意：在 manifest 文件中简单的覆盖 Master Entries 导致的结果是不确定的，因为 Master Entries 是在后续访问页面时被添加到 AppCache 的</strong></p>\n</li>\n<li><p><strong>Fallback entries</strong><br>Fallback entries 的用处在资源加载失败时。</p>\n</li>\n</ul>\n<h2 id=\"缓存状态\"><a href=\"#缓存状态\" class=\"headerlink\" title=\"缓存状态\"></a>缓存状态</h2><p>每个 AppCache 都会有一个状态，用来标示缓存的当前状态，用来相同 manifest URI 的缓存，享有同样的状态，所有的状态列表如下：</p>\n<ul>\n<li><strong>UNCACHED</strong><br>特殊值，表明 AppCache 还未被完全初始化。  </li>\n<li><strong>IDLE</strong><br>AppCache 当前不在被更新的过程中。  </li>\n<li><strong>CHECKING</strong><br>manifest 文件正在被加载或者检查是否已更新。  </li>\n<li><strong>DOWNLOADING</strong><br>资源正在被下载到缓存中，会导致 manifest 中的资源更新。  </li>\n<li><strong>UPDATEREADY</strong><br>存在更新的 AppCache，当新的缓存已经被下载但是没有使用 swapCache 方法更新的时候，相应的会触发 <em>updateready</em> 事件，而不是 <em>cached</em> 事件。  </li>\n<li><strong>OBSOLETE</strong><br>AppCache 已经过时。  </li>\n</ul>\n<h2 id=\"检测-manifest-文件是否已经更新\"><a href=\"#检测-manifest-文件是否已经更新\" class=\"headerlink\" title=\"检测 manifest 文件是否已经更新\"></a>检测 manifest 文件是否已经更新</h2><p>可以在程序中使用 JavaScript 检测 manifest 文件是否已更新，由于有可能在脚本添加更新的事件监听之前 manifest 文件已经更新，所以脚本应该检查 <code>window.applicationCache.status</code>。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function onUpdateReady() &#123;  </div><div class=\"line\">  alert(&apos;found new version!&apos;);  </div><div class=\"line\">&#125;  </div><div class=\"line\">window.applicationCache.addEventListener(&apos;updateready&apos;, onUpdateReady);  </div><div class=\"line\">if(window.applicationCache.status === window.applicationCache.UPDATEREADY) &#123;  </div><div class=\"line\">  onUpdateReady();  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要手动测试新的 manifest 文件时，可以使用 <code>window.applicationCache.update()</code> 方法。</p>\n<h2 id=\"需要注意的点\"><a href=\"#需要注意的点\" class=\"headerlink\" title=\"需要注意的点\"></a>需要注意的点</h2><ul>\n<li>永远不要通过增加 GET 参数的方式（例如：<code>other-cached-page.html?parameterName=value</code>）获取缓存的文件，这会导致浏览器忽略缓存直接从网络获取文件。如果需要链接到有参数传递的资源，在 hash 上增加参数，例如：<code>other-cached-page.html#whatever?parameterName=value</code>。  </li>\n<li>当应用被缓存后，简单的更新资源文件是不够的。必须手动更新 manifest 文件，从而让浏览器使用新的文件。可以在程序内通过 <code>window.applicationCache.swapCache()</code> 方法来更新文件，但是已经被加载的资源不会受影响。</li>\n<li>服务器端设置 <code>*.appcache</code> 文件的 expires headers 为立即过期是个很好的做法，这样可以避免 manifest 文件被缓存带来的风险。例如，在 Apache 中可以添加如下设置：<br><code>ExpiresByType text/cache-manifest &quot;access plus 0 seconds&quot;</code></li>\n</ul>"},{"layout":"post","title":"Application Cache 就是个坑","date":"2012-11-11T14:29:33.000Z","_content":"\n- by  [Jake Archibald](http://www.alistapart.com/authors/a/Jake%20Archibald \"Jake Archibald\")  \n- 原文地址 [Application Cache is a Douchebag](http://www.alistapart.com/articles/application-cache-is-a-douchebag/ \"Application Cache is a Douchebag\")\n\n![application-cache-is-a-douchebag](http://www.alistapart.com/d/application-cache-is-a-douchebag/application-cache-is-a-douchebag.jpg)\n\n早上好，我们最近发布了 [我们的 Mobile 网站](http://m.lanyrd.com/)，其中使用了离线缓存技术。我将离线缓存部分的代码简化成了[一个小的实例](http://appcache-demo.s3-website-us-east-1.amazonaws.com/localstorage-cache/)，并把代码放到了 [Github](https://github.com/jakearchibald/appcache-demo) 上。不过在深入代码之前，请允许我向您讲述一个真实的故事。  \n\n<!-- more -->\n\n故事发生在一个大家彼此很陌生的派对上，我躲在一群尝试介绍自己的人群之中。这时候，一个漂亮的女士走过来对着一个略显羞涩的人说，\"我是 Dev，你叫什么名字？\"  \n\n\"呃，我是 LocalStorage\"，他回答的很不自然，\"我提供了一个脚本接口来管理跨页面和会话的文本存储\"。  \n\n\"他其实只是个简单的柜子\"，另外一个人打断道，其余人也纷纷嘲笑 LocalStorage 对于资源的浪费。我跟他很熟，所以我并没有参与其中。  \n\n这个时候，人群中的另一个人尖着嗓子说，\"嗨，我是 ApplicationCache\"，说话的同时，他伸手去与 Dev 握手，\"我仅仅通过增加一个文件成功的提升了狗屎般的离线体验，小而美，不需要脚本控制\"，他在说脚本控制的同时做了个砍价的动作。与此同时，我却是咬牙切齿，因为我知道他过分的夸大了他的能力，坏消息是其余的人并没有意识到这一点。但是如果在这种情况下指出他在胡说八道，我肯定会被认为是个混蛋。  \n\n没能在那个晚上指出 ApplicationCache 的问题，让我感到非常不舒服。看到那些只是顺路看了下 ApplicationCache 的人夸奖他的易用性真是让人痛苦。我想我必须来说点什么：我在这里告诉你 ApplicationCache 就是个坑。  \n\n并不是说 ApplicationCache 没有用，或者是需要尽量避免使用，只是在什么情况下使用以及怎么使用的问题上需要非常的谨慎。一旦出了差错，混乱会被传递给用户。通过了解我们使用 ApplicationCache 的痛苦经历，你也许可以了解到能够从 ApplicationCache 中得到什么以及应该怎么使用它。  \n  \n### 离线访问的适用场景是怎么样的  \n我们在接入网络方面变得越来越好了，可以却依然不能任何什么时候都保持在线。比如说正在一辆在萨塞克斯西部平原上穿行的火车上写这篇文章的我。另外，当我在国外使用数据服务的时候我几乎可以听到网络提供商办公室里开香槟庆祝的声音。在数据漫游时使用网络会让我大放血，但网络中有我需要的数据，有些时候又不得不通过网络连接来获得它。  \n\n可以在离线情况下访问的网站大概可以分为两类，一类\"可以离线使用\"的网站，而另一类则\"可以离线查看\"的网站。  \n\n\"可以离线查看\"的网站包括 [Wikipedia](http://www.wikipedia.com/), [YouTube](http://youtube.com/), 和 [Twitter](http://twitter.com/)。他们复杂的处理都在服务器上进行，虽然可以获得很多的数据，但是在用户只能使用其中很小的一部分。  \n\n\"可以离线使用\"的网站有 [Cut the Rope](http://www.cuttherope.ie/), [CSS Lint](http://csslint.net/), 和 [Google Docs](http://docs.google.com/)。这些网站复杂的业务逻辑很多是在客户端实现的。他们只提供了一定量的数据，但是可以通过各种方法是用这些数据，用户甚至创造自己的数据。这正是 ApplicationCache 被设计时想要针对的情况，我们来首先来看一个关于它的简单介绍。  \n\n### \"可以离线使用\"的网站  \n[Sprite Cow](http://www.spritecow.com/) 是一个可以离线使用的网站，CSS sprites 对于[提高性能](http://css-tricks.com/css-sprites/)是很有好处的，但是在 sprite 页中找到一个元素的大小和位置是很复杂的。Sprite Cow 加载 sprite 页面，然后产生 CSS 来展示其中特定的部分。它包括一个 HTML 文件，一些静态文件，所有的处理都会在客户端执行，服务器只负责提供静态文件。  \n\n在火车上能像使用 Native App 一样使用 Sprite Cow 真的是很好的体验。为了做到这样，我们创建了一个 manifest 文件，其中列出了网站需要的所有静态文件：\n \n    CACHE MANIFEST\n    assets/6/script/mainmin.js\n    assets/6/style/mainmin.css\n    assets/6/style/fonts/pro.ttf\n    assets/6/style/imgs/sprites1.png\n    ...\n\n然后将 manifest 文件通过一个属性链接到 html 页面上。  \n\n    `<html manifest=\"offline.appcache\">`\n\nHTML 页面本身没有在 manifest 文件中列出，但是包含 manifest 的页面自身会成为 manifest 的一部分。  \n\n实践表明，如果你在线的情况下访问了 [Sprite Cow](http://www.spritecow.com/)，你可以在以后离线时访问他。  \n\nChrome 的 Web Inspector 中的 resource 标签可以展示 manifest 文件中记录的文件，它属于属于哪个页面。如果你需要清除这些缓存，访问 [chrome://appcache-internals/](chrome://appcache-internals/) 就可以了。  \n\n首先，这看上去像是一个很神奇的解决方案，不幸的是，我在说这会是个简单介绍的时候撒谎了，ApplicationCache 的规则更像是一个洋葱，它有很多很多层，随着你慢慢剥开它，眼泪也会慢慢流下来。  \n\n## 坑#1：即便在线，文件也从 ApplicationCache 中加载\n当你访问 Sprite Cow 的时候，你会立即获得缓存中的版本，当页面渲染结束后（实际上不一定在渲染结束的情况下进行），浏览器会查看 manifest 文件以及被缓存的文件的更新情况。  \n\n这看上去像是很奇怪的处理方式，这决定了浏览器不用等到连接 Timeout 来决定你处于离线状态。  \n\nApplicationCache 会抛出 `updateready ` 事件来告诉我们内容有更新，但是我们并不能在这个时候简单的刷新页面，因为用户可能正在使用他们已经获得的旧版本。  \n\n这并不是一个大问题，因为旧版本可能也是足够好的，如果需要的话我们可以显示\"发现了一个更新，请刷新页面获取更新\"的信息。你可能曾经在 Google 的应用中看到过它，比如 Google Reader 或者是 Gmail。  \n\n还记得我在四段之前说 ApplicationCache 会在页面渲染结束后查看是否有更新吗? 我又撒谎了。\n\n## 坑#2：ApplicationCache 只在 Manifest 文件改变的时候更新  \nHTTP 已经有缓存模型了，每个文件可以定义怎样被浏览器缓存。最基本的，每个独立的文件可以声明\"永远不要缓存我\"或者\"与服务器进行验证，它会告诉你有没有更新\"或者\"直到 2022 年 4 月 1 日我都是可以使用的\"。  \n\n但是，如果在你的 manifest 中有 50 个 html 页面，每次你在线的情况下访问他们的时候，浏览器会创建 50 个网络请求来确认他们是不是需要更新。  \n\n作为一个不寻常的解决方式，浏览器只会在 manifest 文件发生更新时查看 manifest 文件中列出的文件是不是有更新。 manifest 文件比较是以二进制方式进行的。  \n\n这个处理对于通过 CDN 分发并且永远不会改变的静态文件来说是透明的。当 CSS/JavaScript 等等改变的时候，它们会使用与之前不同的 url，这意味着 manifest 文件改变了。如果你不熟悉缓存以及 CDN，请先查看 [Yahoo 的性能最佳实践指引](http://developer.yahoo.com/performance/rules.html#expires)。  \n\n有些资源不能简单的改变他们的 url，比如说我们的 HTML 页面。除非更新了 manifest 文件 ApplicationCache 不会查看文件的更新。最简单的方式是，在 manifest 文件中增加注释。\n\n    CACHE MANIFEST  \n    # v1\n    whatever.html  \n\n在 manifest 文件中，注释以`#`开始，如果我更新了 html 页面，我需要更新注释到 `# v2`，来触发更新。你可以使用脚本通过类似 ETag 的方式修改在 manifest 文件中的注释，这样每个文件的改变都可以保证 manifest 文件能够更新。  \n\n但是，更新 manifest 文件中的文本并不能保证其中的资源会访问服务器获得更新。  \n\n## 坑#3：ApplicationCache 只是个附加的缓存，而不是替代品  \n当浏览器更新 ApplicationCache 时会像平常一样请求 manifest 文件的地址。它遵循普通的缓存逻辑，如果一个元素的头部声明\"在 2022 年 4 月 1 日之前我都是足够新鲜的\"，浏览器会假设其是最新的直到 2022 年 4 月 1 日，这会阻止 manifest 的更新。  \n\n这是件好事，因为你可以通过它在 manifest 文件改变时减少浏览器需要发送的请求数目。  \n\n但这也会坑人，所以有些人尝试服务器不提供缓存头。但是在不提供的情况下，浏览器会猜测文件的缓存过期时间，你可以更新 html 页面以及 manifest 文件，但是浏览器不一定会更新它，因为他\"猜测\"文件是不需要更新的。  \n\n服务器提供的所有文件都应该包含缓存头，他们对于 manifest 中的文件以及 manifest 自身来说都是很重要的。如果文件会被频繁更新，它应该带上 `no-cache` 头部。如果文件偶尔更新，`must-revalidate` 是个更好的选择，比如 `must-revalidate` 对于 manifest 自身来说是个很好的选择。好吧，有点跑题……  \n\n## 坑#4：永远永远不要长期缓存 Manifest  \n你可能觉得 manifest 文件是个静态文件，就像\"在 2022 年 4 月 1 日之前我都是足够新鲜的\",然后再更新的时候更新 manifest 文件的 url。  \n\n别！千万别这样！  \n\n记住坑#1中提到的内容，当用户第二次访问页面时，他们会获取 ApplicationCache 的版本，如果已经更改了 manifest 文件地址的话，很不幸的，用户缓存的版本依然指向旧的 manifest 文件，它就永远不会更新了，永远。  \n\n## 坑#5：未缓存的资源不会在缓存的页面中展示  \n如果你缓存了 index.html，但是没有缓存 cate.jpg，文件即便是在线的情况下也不会在 index.html 中显示，实际上这是预期的行为，[自己看吧](http://appcache-demo.s3-website-us-east-1.amazonaws.com/without-network/)。  \n\n为了禁止这个行为，需要使用 manifest 中的 NETWORK 段\n \n    CACHE MANIFEST\n    # v1\n    index.html\n    NETWORK:  \n    *\n\n字符 * 表示，浏览器应该允许所有缓存页面中的的非缓存连接。这里，你可以看到[设置 NETWORK 之后的实例](http://appcache-demo.s3-website-us-east-1.amazonaws.com/with-network/)。显然，这些链接在离线情况会失败。  \n\n很好，你已经完成了使用 ApplicationCache 的简单示例。是的，虽然这只是个简单示例。让我们来点厉害的吧。\n\n### \"可以离线查看\"的网站  \n\n就像我在文章开始提到的那样，Lanyrd 最近发布了[一个 Mobile 网站](http://m.lanyrd.com/)，用户可以查看会议日程，地点，参与者等。离线访问这些数据对旅行和面临数据漫游费用的人来说是非常重要的。  \n\n离线所有内容简直太大了，但是通常一个用户只会对他们参与的事件感兴趣。  \n\n最近的 [Dive into HTML5](http://diveintohtml5.info/) 给我们[一个关于离线 Wikipedia 的示例](http://diveintohtml5.info/offline.html#fallback)，那是另外一个\"可以离线查看\"的网站。它的工作方式是每个链接使用一个几乎为空的 manifest 文件，当用户在网站中浏览时，这些网页立即成为他们缓存的一部分，当离线时，他们能够访问之前查看过的任意网页。  \n\nWikipedia 的解决方案非常简单，但是由于规范中存在一些诡异的地方，这又是非常惨的。对于初级用户来说，用户没有收到任何指示来表明哪些内容在离线情况下是可用的，并且没有可以获取这些信息的 JavaScript API。我们可以下载 manifest 文件，然后使用 JavaScript 解析它，但是所有的  Wikipedia 的页面是隐式缓存的，所以他们没有在 manifest 文件中被列出。  \n\n更进一步，坑＃1：缓存中的版本会被显示，而不是服务器端的版本。当用户第一次访问时，页面会被冻结，但是我们在坑＃2中发现，我们可以通过修改 manifest 文件来触发浏览器查看更新。但是我们什么时候改变 manifest 文件呢？每当一个 Wikipedia 的条目被更新？那样就会变的过于频繁，实际上如果 manifest 文件在更新的开始以及结束之间被修改，浏览器会[认为此次更新失败(step24)](http://www.whatwg.org/specs/web-apps/current-work/multipage/offline.html#downloading-or-updating-an-application-cache)。  \n\n更新的频率是个问题，但是更新的大小才是真正的杀手，想想你所看过的 Wikipedia 的数量吧，几百？几千？一个 AppCache 的更新会包括下载所有的页面。AppCache 没有提供删除隐式缓存元素的方法，所以数量会不断的增长，增长，直到达到浏览器的缓存最大限度，然后世界崩溃。这不是什么好事。  \n\n### 我们希望从离线网站获得什么？  \n我需要从一个提供离线能力的网站获得的是：  \n\n- 在线的情况下显示最新的数据，和没有 ApplicationCache 一样  \n- 允许我们（开发人员）控制哪些内容被缓存，什么时候被缓存以及怎样被缓存  \n- 允许我们提供给用户一些控制的能力，有可能以“保存为离线”或者“稍后阅读”按钮  \n- 每次对页面的访问必须提供给浏览器供离线显示需要的所有内容  \n\nApplicationCache，甚至夸大了它的作用的那些说法，都没有让这些变得简单。如果页面中包含了 manifest，它就会被缓存，你没办法用一个页面告诉浏览器所有被缓存的内容。  \n\n### 限制 ApplicationCache 的使用范围  \n最简单的让一个页面像没有 ApplicationCache 一样的方法是提供它时不包含 manifest。我们可以通过插入一个不可见的 iframe 指向包含 manifest 的页面来告诉浏览器需要缓存的内容。\n\n让我们转个弯。在线的情况下[访问这个页面](http://appcache-demo.s3-website-us-east-1.amazonaws.com/offline-iframe/)。之后你可以在离线的状态下访问[这个页面](http://appcache-demo.s3-website-us-east-1.amazonaws.com/offline-iframe/offline.html)。第一个页面并不是缓存的一部分，所以用户一直可以通过它获取最新的内容。  \n\n### Fallback  \n通过 ApplicationCache 的 manifest 文件可以定义一个如果一个请求失败的时候 Fallback 使用的资源。  \n\n    CACHE MANIFEST\n    FALLBACK:  \n    / fallback.html  \n    /assets/imgs/avatars/ assets/imgs/avatars/default-v1.png  \n\n这个 manifest 文件告诉 ApplicationCache 在任何网络请求失败的情况下显示 fallback.html，除非包含 /assets/imgs/avatars/ 的请求失败，这种情况下一个 Fallback 的图片会被使用。  \n\n了解 Fallback 实际怎么工作，[访问这个页面](http://appcache-demo.s3-website-us-east-1.amazonaws.com/simple-fallback/)。在没有网络请求的情况下再次访问页面，Fallback的页面会被显示。需要注意它强制重定向的方式，原始页面的 url 会被保留，这是很有用的。  \n\n顺便，存在 Fallback 资源[解决了在坑＃5中提到的网络规则中遇到的疑难杂症](http://appcache-demo.s3-website-us-east-1.amazonaws.com/with-fallback/)。现在同一域名中的连接都会被允许，但是对于其他域名来说网络通配符还是需要的。  \n\n现在我们更近了一步，我们在普通页面没有成功加载的情况下显示一个被缓存了的页面。  \n\n### 只对静态内容使用 ApplicationCache  \n说“静态内容”，我的意思是内容从来不会改变。可以是图片，脚本，样式表和我们的 Fallback 页面。  \n\n    CACHE MANIFEST\n    js/script-v1.js\n    css/style-v1.css\n    img/logo-v1.png\n    FALLBACK:\n    / fallback/v1.html\n    /imgs/avatars/ imgs/avatars/default-v1.png\n\n如果我们需要改变 JavaScript，我们上传一个新的文件，并且使用新的 url，比如：script-v2.js。  \n\n这样就可以解决坑1＃以及坑2＃带来的问题：用户永远被不会提供过期的脚本或者样式，因为它们在改变的时候会拥有一个新的 url。我们不需要去处理一个包含注释的版本好的 manifest，因为 url 中的文本改变已经足够触发刷新。所有的资源都会拥有一个未来过期时间，这样只有更新了的文件需要 Http 请求来更新内容。  \n\n## 坑6＃：再见吧，条件下载  \n等等，你不觉得整篇文章到现在还没有提到任何关于响应式设计的部分吗？  \n\n你有两套设计图片吗？是不是其中一个更小，以便使用 Mobile 设备的用户查看网站？你使用 Media Queries 来决定显示哪一个图片吗？好吧，ApplicationCache 讨厌你，讨厌你全家。  \n\n所有需要在网站中渲染的图片都需要在 manifest 中，并且浏览器会将所有图片下载。在这种响应式图片的情况下，用户最终会下载同样资源的所有版本，这显然违背了我们的意愿。用桌面版的图片吧，在客户端通过 [CSS background size](https://developer.mozilla.org/en/CSS/background-size) 重新处理图片的大小。  \n\n如果 Mobile 版本有一个完全不同的设计，至少将他们同高分辨率图片一起放置到一个 sprite 中，这样他们可以同时从 png 压缩中获益。  \n\n对于字体来说也是同样的道理。我看到过一些人建议使用[很多的字体格式](http://speakerdeck.com/u/jaffathecake/p/in-your-font-face?slide=38)，这对于普通网站来说是不错的，但是我们不能把他们都放到 manifest 文件里。对于离线用户，只使用 Trye Type Fonts (TTF) 吧，“嗨，未来不是属于 Web Open Font Format (WOFF) 的吗？”，是的，有可能，但是只是因为法律的原因。WOFF 相对于 TTF 并没有什么优势可言。是的，WOFF 可以在创建时进行压缩，但是并没有比 Gzip 的 TTF 好。另外，[WOFF 不支持很多的旧版本浏览器](http://caniuse.com/woff)，而 TTF 支持的浏览器多很多。  \n\n随他去吧，回到 Application Cache。\n### 对于需要离线的动态内容使用 LocalStorage  \n我们不能离线下载所有内容，它们确实太多了。我们希望用户获得他们离线情况下希望获得的内容。我们可以使用 LocalStorage 来保存数据。  \n\n是的，LocalStorage 就是个柜子，但是它是个使用很简单的有用柜子。在同一域名下的页面内，你可以放置任何的 text 数据到 LocalStorage 然后在之后获取它。  \n\nLocalStorage 是存储在硬盘的，虽然耗费不大，但是也[不是完全没有耗费](http://，我们应该控制calendar.perfplanet.com/2011/localstorage-read-performance/)的。所以我们应该控制读写的数量，只在必须的时候读写它。  \n\n我们给每一个存储的页面存储一个列表，然后另外设置一个列表跟踪我们离线缓存的内容和页面的标题，这意味着通过一次读取我们就可以列出我们已经缓存的列表，两次读取就可以显示一个特定的页面。  \n\n当我们保存页面 `articles/1.html` 供离线使用时，我们这样处理。\n\n    // Get the page content\n    var pageHtml = document.body.innerHTML;\n    var urlPath = location.pathName;\n    // Save it in local storage\n    localStorage.setItem( urlPath, pageHtml );\n    // Get our index\n    var index = JSON.parse( localStorage.getItem( index' ) );\n    // Set the title and save it\n    index[ urlPath ] = document.title;\n    localStorage.setItem( 'index', JSON.stringify( index ) );\n\n然后当用户离线情况下访问 `articles/1.html` 的时候，会得到 fallback.html，就像下面做的这样。  \n\n    var pageHtml = localStorage.getItem( urlPath );\n    if ( !pageHtml ) {\n        document.body.innerHTML = `'<h1>Page not available</h1>'`;\n    }\n    else {\n        document.body.innerHTML = localStorage.getItem( urlPath );\n        document.title = localStorage.getItem( 'index' )[ urlPath ];\n    }\n\n我们也可以遍历 localStorage.getItem( 'index' ) 来获得用户缓存的所有页面的详细信息。  \n\n### 同时使用 ApplicationCache 以及 LocalStorage  \n[这里是个以上操作的 Demo](http://appcache-demo.s3-website-us-east-1.amazonaws.com/localstorage-cache/)。文章页可以通过页面右上方的按钮进行缓存，index 页面会显示出哪些页面可以在离线状态下使用。  \n\n所有的代码[可以从 Github 获得](https://github.com/jakearchibald/appcache-demo/tree/master/www/localstorage-cache)。任何页面可以通过调用 [offliner.cacheCurrentPage()](https://github.com/jakearchibald/appcache-demo/blob/master/www/localstorage-cache/js/offliner-v1.js#L62) 来缓存。函数在每次进入 index 以及用户希望缓存的页面时被调用。  \n\n如果用户遇到了 fallback 页面。 [offliner.renderCurrentPage()](https://github.com/jakearchibald/appcache-demo/blob/master/www/localstorage-cache/js/offliner-v1.js#L74) 会被调用来渲染指定的页面。如果没有页面可以被显示，就会显示错误信息。哦，这提醒了我....  \n\n## 坑#7：我们不知道怎么获得 Fallback 页面  \n当我们不能显示一个具体的页面的时候，我们可以显示的信息是[非常不清晰](https://github.com/jakearchibald/appcache-demo/blob/master/www/localstorage-cache/js/offliner-v1.js#L84)的。根据规范，如果初始请求遇到以下情况 Fallback 页面会被使用：\"被重定向到了另外的来源，返回了 4XX 或 5XX 或者存在网络错误（不包括用户取消了下载）\"。  \n\n某种程度上这不错。如果用户在线使用，但是网站挂掉了，浏览器只是会使用缓存的数据，用户甚至不会被通知。不幸的是，我们没办法提供用户使用 fallback 的原因。可能因为用户没有连接，可能是他们输入了不正确的 url，也可能是服务器报错。我们并不知道到底发生了什么。  \n\n接下来让我们看下重定向。\n\n## 坑#8：重定向到其余网站的请求会被认为失败  \n是的，又是一个坑，好高兴啊你还在读。如果你想要去把自己锁在厕所的隔间，直到没有网络的时候才出来，我表示完全可以理解你。  \n如果你的一个链接需要跳转到 Twitter 或者 Facebook 去做一些认证，我们友善的 Application Cache 会认为这是**不被允许的**，然后显示 Fallback 页面。  \n\n这个规则还是有好的方面的。如果用户想要访问你的网站，但是他们使用的 wifi 强制他们重定向到 http://rubbish-network/pay-for-wifi-access (付费使用 wifi 的链接)，这个时候显示我们网站的 Fallback 页面是很好的。  \n\n在需要验证的重定向的时候，NETWORK 段下的白名单并不能帮上什么。作为替代方案，你可以使用 JavaScript 或者 meta-redirect。呃。。  \n\n### LocalStorage 方式的缺点  \n“我们到了缺点的部分了吗？那刚刚说过的那些算什么啊？”，我知道，但是别烦我。单纯的 ApplicationCache 的解决方案有一些缺点。  \n\n需要 JavaScript，虽然 Sprite Cow 使用 ApplicationCache 没有依赖 JavaScript，但是其余的网站都有使用。我以项上人头保证，很少人支持 ApplicationCache 但是不支持 JavaScript 。这并不是说 no-JavaScript 的支持不重要。[Lanyrd’s mobile 网站](http://m.lanyrd.com/)在浏览器不支持 JavaScript 的情况下依然运行的很好，实际上我们在旧的设备上避免了依赖 JavaScript 来使它变的简单和迅速。  \n\n有些请求的体验并不好。FALLBACK 的问题是，在它之前原始链接必须已经失败，请求的发送和接受会消耗一定的时间。这样看 坑#1 (文件总会从 ApplicationCache 加载)，确实是蛮有用的。  \n\nOpera 下 Fallback 不工作。Opera 不支持 manifest 属性中的 FALLBACK 段。希望他们能尽快的修复这个问题。  \n\n### m.lanyrd.com 有什么不同点呢  \n[之前看到的 Demo](http://appcache-demo.s3-website-us-east-1.amazonaws.com/localstorage-cache/) 只是我在 lanyrd 所做的事情的简化版。我们在 LocalStorage 中存储 JSON 数据，在 ApplicationCache 中存储对应的模版，而不是直接存储 HTML 文件供离线使用。这意味着我们可以不关心数据，只更新模版，也可以在不同的模版中使用相同的数据。  \n\n我们的每个会议的 JSON 有个版本号。版本号在浏览网站的时候会被检测。如果他们与已经缓存的不匹配，则会更新。这意味着只在存在更新的时候发送更新请求。  \n\n我们在用户跟踪或者下载事件发生时缓存数据，而不是提供按钮使用户可以离线存储特定的页面。这样浏览器可以知道用户需要哪些数据离线使用，这样如果他们更换了设备或者莫名其妙丢失了缓存，我们可以迅速的重新填充。  \n\n通过 XMLHttpRequest 和 pushState 来切换页面。这在 Mobile 设备上更快，因为它不需要在每个页面加载的时候重新执行 JavaScript，也使网站更像一个 App。  \n\n继续，由于遗留问题...\n## 坑#9：关于 XHR 额外的一点  \n离线情况下你可以发起 XHR 请求请求缓存资源，不幸的是，旧版本的 Webkit 以状态码为 0 返回这个请求，这种情况在流行的库中会被认为请求失败。  \n\n    // In jQuery...\n    $.ajax( url ).done( function(response) {\n        // Hooray, it worked!\n    }).fail( function(response) {\n        // Unfortunately, some requests\n        // that worked end up here\n    });\n\n具体点，这个问题存在于 Blackberry Playbook 和 iOS3 设备以及 Android 3/4。Android 2 没有这个 Bug，奇怪的是，它看上去运行了新版的 Webkit 内核，它支持 `history.pushState ` 而最新版的 Android 并不支持。他X的 ANDROID，以下是你需要处理这个问题的方式。  \n\n    $.ajax( url ).always( function(response) {\n    // Exit if this request was deliberately aborted\n    if (response.statusText === 'abort') { return; }\n    // Does this smell like an error?\n    if (response.responseText !== undefined) {\n        if (response.responseText && response.status < 400) {\n            // Not a real error, recover the content\n            response = response.responseText;\n        }\n        else {  \n            // This is a proper error, deal with it\n            return;\n        }\n    }\n    // do something with 'response'\n});\n\n你可以在[这个 Demo](http://appcache-demo.s3-website-us-east-1.amazonaws.com/localstorage-cache/) 上进行测试。\n\n### ApplicationCache: 你的朋友，你的坑\n我没有说不应该使用 ApplicationCache，它是很有用的。我们都知道有些人需要特别提醒，或者需要特殊的“看管”来保证他们不做蠢事。嗯，ApplicationCache 就是其中一个。  \n\n在细心的照料下，ApplicationCache 能做一些其他人不能做的事情。但是当他对你说“你不用雇佣水管工，我自己就可以搞定那整个浴室，我曾经搞定了白金汉宫所有的浴室，你看...”的时候，请绅士的拒绝他。  \n\n如果你不是在创建一个不需要任何网络请求的完全客户端的应用的话，请使用尽可能小的 ApplicationCache，其余的事情交给 LocalStorage 吧，这样会减少很多的麻烦。","source":"_posts/2012-11-11-application-cache-is-a-douchebag.md","raw":"---\nlayout: post\ncategory : front-end\ntitle: Application Cache 就是个坑\ndate: 2012-11-11 22:29:33\ntags : [Application Cache, AppCache, 坑]\n---\n\n- by  [Jake Archibald](http://www.alistapart.com/authors/a/Jake%20Archibald \"Jake Archibald\")  \n- 原文地址 [Application Cache is a Douchebag](http://www.alistapart.com/articles/application-cache-is-a-douchebag/ \"Application Cache is a Douchebag\")\n\n![application-cache-is-a-douchebag](http://www.alistapart.com/d/application-cache-is-a-douchebag/application-cache-is-a-douchebag.jpg)\n\n早上好，我们最近发布了 [我们的 Mobile 网站](http://m.lanyrd.com/)，其中使用了离线缓存技术。我将离线缓存部分的代码简化成了[一个小的实例](http://appcache-demo.s3-website-us-east-1.amazonaws.com/localstorage-cache/)，并把代码放到了 [Github](https://github.com/jakearchibald/appcache-demo) 上。不过在深入代码之前，请允许我向您讲述一个真实的故事。  \n\n<!-- more -->\n\n故事发生在一个大家彼此很陌生的派对上，我躲在一群尝试介绍自己的人群之中。这时候，一个漂亮的女士走过来对着一个略显羞涩的人说，\"我是 Dev，你叫什么名字？\"  \n\n\"呃，我是 LocalStorage\"，他回答的很不自然，\"我提供了一个脚本接口来管理跨页面和会话的文本存储\"。  \n\n\"他其实只是个简单的柜子\"，另外一个人打断道，其余人也纷纷嘲笑 LocalStorage 对于资源的浪费。我跟他很熟，所以我并没有参与其中。  \n\n这个时候，人群中的另一个人尖着嗓子说，\"嗨，我是 ApplicationCache\"，说话的同时，他伸手去与 Dev 握手，\"我仅仅通过增加一个文件成功的提升了狗屎般的离线体验，小而美，不需要脚本控制\"，他在说脚本控制的同时做了个砍价的动作。与此同时，我却是咬牙切齿，因为我知道他过分的夸大了他的能力，坏消息是其余的人并没有意识到这一点。但是如果在这种情况下指出他在胡说八道，我肯定会被认为是个混蛋。  \n\n没能在那个晚上指出 ApplicationCache 的问题，让我感到非常不舒服。看到那些只是顺路看了下 ApplicationCache 的人夸奖他的易用性真是让人痛苦。我想我必须来说点什么：我在这里告诉你 ApplicationCache 就是个坑。  \n\n并不是说 ApplicationCache 没有用，或者是需要尽量避免使用，只是在什么情况下使用以及怎么使用的问题上需要非常的谨慎。一旦出了差错，混乱会被传递给用户。通过了解我们使用 ApplicationCache 的痛苦经历，你也许可以了解到能够从 ApplicationCache 中得到什么以及应该怎么使用它。  \n  \n### 离线访问的适用场景是怎么样的  \n我们在接入网络方面变得越来越好了，可以却依然不能任何什么时候都保持在线。比如说正在一辆在萨塞克斯西部平原上穿行的火车上写这篇文章的我。另外，当我在国外使用数据服务的时候我几乎可以听到网络提供商办公室里开香槟庆祝的声音。在数据漫游时使用网络会让我大放血，但网络中有我需要的数据，有些时候又不得不通过网络连接来获得它。  \n\n可以在离线情况下访问的网站大概可以分为两类，一类\"可以离线使用\"的网站，而另一类则\"可以离线查看\"的网站。  \n\n\"可以离线查看\"的网站包括 [Wikipedia](http://www.wikipedia.com/), [YouTube](http://youtube.com/), 和 [Twitter](http://twitter.com/)。他们复杂的处理都在服务器上进行，虽然可以获得很多的数据，但是在用户只能使用其中很小的一部分。  \n\n\"可以离线使用\"的网站有 [Cut the Rope](http://www.cuttherope.ie/), [CSS Lint](http://csslint.net/), 和 [Google Docs](http://docs.google.com/)。这些网站复杂的业务逻辑很多是在客户端实现的。他们只提供了一定量的数据，但是可以通过各种方法是用这些数据，用户甚至创造自己的数据。这正是 ApplicationCache 被设计时想要针对的情况，我们来首先来看一个关于它的简单介绍。  \n\n### \"可以离线使用\"的网站  \n[Sprite Cow](http://www.spritecow.com/) 是一个可以离线使用的网站，CSS sprites 对于[提高性能](http://css-tricks.com/css-sprites/)是很有好处的，但是在 sprite 页中找到一个元素的大小和位置是很复杂的。Sprite Cow 加载 sprite 页面，然后产生 CSS 来展示其中特定的部分。它包括一个 HTML 文件，一些静态文件，所有的处理都会在客户端执行，服务器只负责提供静态文件。  \n\n在火车上能像使用 Native App 一样使用 Sprite Cow 真的是很好的体验。为了做到这样，我们创建了一个 manifest 文件，其中列出了网站需要的所有静态文件：\n \n    CACHE MANIFEST\n    assets/6/script/mainmin.js\n    assets/6/style/mainmin.css\n    assets/6/style/fonts/pro.ttf\n    assets/6/style/imgs/sprites1.png\n    ...\n\n然后将 manifest 文件通过一个属性链接到 html 页面上。  \n\n    `<html manifest=\"offline.appcache\">`\n\nHTML 页面本身没有在 manifest 文件中列出，但是包含 manifest 的页面自身会成为 manifest 的一部分。  \n\n实践表明，如果你在线的情况下访问了 [Sprite Cow](http://www.spritecow.com/)，你可以在以后离线时访问他。  \n\nChrome 的 Web Inspector 中的 resource 标签可以展示 manifest 文件中记录的文件，它属于属于哪个页面。如果你需要清除这些缓存，访问 [chrome://appcache-internals/](chrome://appcache-internals/) 就可以了。  \n\n首先，这看上去像是一个很神奇的解决方案，不幸的是，我在说这会是个简单介绍的时候撒谎了，ApplicationCache 的规则更像是一个洋葱，它有很多很多层，随着你慢慢剥开它，眼泪也会慢慢流下来。  \n\n## 坑#1：即便在线，文件也从 ApplicationCache 中加载\n当你访问 Sprite Cow 的时候，你会立即获得缓存中的版本，当页面渲染结束后（实际上不一定在渲染结束的情况下进行），浏览器会查看 manifest 文件以及被缓存的文件的更新情况。  \n\n这看上去像是很奇怪的处理方式，这决定了浏览器不用等到连接 Timeout 来决定你处于离线状态。  \n\nApplicationCache 会抛出 `updateready ` 事件来告诉我们内容有更新，但是我们并不能在这个时候简单的刷新页面，因为用户可能正在使用他们已经获得的旧版本。  \n\n这并不是一个大问题，因为旧版本可能也是足够好的，如果需要的话我们可以显示\"发现了一个更新，请刷新页面获取更新\"的信息。你可能曾经在 Google 的应用中看到过它，比如 Google Reader 或者是 Gmail。  \n\n还记得我在四段之前说 ApplicationCache 会在页面渲染结束后查看是否有更新吗? 我又撒谎了。\n\n## 坑#2：ApplicationCache 只在 Manifest 文件改变的时候更新  \nHTTP 已经有缓存模型了，每个文件可以定义怎样被浏览器缓存。最基本的，每个独立的文件可以声明\"永远不要缓存我\"或者\"与服务器进行验证，它会告诉你有没有更新\"或者\"直到 2022 年 4 月 1 日我都是可以使用的\"。  \n\n但是，如果在你的 manifest 中有 50 个 html 页面，每次你在线的情况下访问他们的时候，浏览器会创建 50 个网络请求来确认他们是不是需要更新。  \n\n作为一个不寻常的解决方式，浏览器只会在 manifest 文件发生更新时查看 manifest 文件中列出的文件是不是有更新。 manifest 文件比较是以二进制方式进行的。  \n\n这个处理对于通过 CDN 分发并且永远不会改变的静态文件来说是透明的。当 CSS/JavaScript 等等改变的时候，它们会使用与之前不同的 url，这意味着 manifest 文件改变了。如果你不熟悉缓存以及 CDN，请先查看 [Yahoo 的性能最佳实践指引](http://developer.yahoo.com/performance/rules.html#expires)。  \n\n有些资源不能简单的改变他们的 url，比如说我们的 HTML 页面。除非更新了 manifest 文件 ApplicationCache 不会查看文件的更新。最简单的方式是，在 manifest 文件中增加注释。\n\n    CACHE MANIFEST  \n    # v1\n    whatever.html  \n\n在 manifest 文件中，注释以`#`开始，如果我更新了 html 页面，我需要更新注释到 `# v2`，来触发更新。你可以使用脚本通过类似 ETag 的方式修改在 manifest 文件中的注释，这样每个文件的改变都可以保证 manifest 文件能够更新。  \n\n但是，更新 manifest 文件中的文本并不能保证其中的资源会访问服务器获得更新。  \n\n## 坑#3：ApplicationCache 只是个附加的缓存，而不是替代品  \n当浏览器更新 ApplicationCache 时会像平常一样请求 manifest 文件的地址。它遵循普通的缓存逻辑，如果一个元素的头部声明\"在 2022 年 4 月 1 日之前我都是足够新鲜的\"，浏览器会假设其是最新的直到 2022 年 4 月 1 日，这会阻止 manifest 的更新。  \n\n这是件好事，因为你可以通过它在 manifest 文件改变时减少浏览器需要发送的请求数目。  \n\n但这也会坑人，所以有些人尝试服务器不提供缓存头。但是在不提供的情况下，浏览器会猜测文件的缓存过期时间，你可以更新 html 页面以及 manifest 文件，但是浏览器不一定会更新它，因为他\"猜测\"文件是不需要更新的。  \n\n服务器提供的所有文件都应该包含缓存头，他们对于 manifest 中的文件以及 manifest 自身来说都是很重要的。如果文件会被频繁更新，它应该带上 `no-cache` 头部。如果文件偶尔更新，`must-revalidate` 是个更好的选择，比如 `must-revalidate` 对于 manifest 自身来说是个很好的选择。好吧，有点跑题……  \n\n## 坑#4：永远永远不要长期缓存 Manifest  \n你可能觉得 manifest 文件是个静态文件，就像\"在 2022 年 4 月 1 日之前我都是足够新鲜的\",然后再更新的时候更新 manifest 文件的 url。  \n\n别！千万别这样！  \n\n记住坑#1中提到的内容，当用户第二次访问页面时，他们会获取 ApplicationCache 的版本，如果已经更改了 manifest 文件地址的话，很不幸的，用户缓存的版本依然指向旧的 manifest 文件，它就永远不会更新了，永远。  \n\n## 坑#5：未缓存的资源不会在缓存的页面中展示  \n如果你缓存了 index.html，但是没有缓存 cate.jpg，文件即便是在线的情况下也不会在 index.html 中显示，实际上这是预期的行为，[自己看吧](http://appcache-demo.s3-website-us-east-1.amazonaws.com/without-network/)。  \n\n为了禁止这个行为，需要使用 manifest 中的 NETWORK 段\n \n    CACHE MANIFEST\n    # v1\n    index.html\n    NETWORK:  \n    *\n\n字符 * 表示，浏览器应该允许所有缓存页面中的的非缓存连接。这里，你可以看到[设置 NETWORK 之后的实例](http://appcache-demo.s3-website-us-east-1.amazonaws.com/with-network/)。显然，这些链接在离线情况会失败。  \n\n很好，你已经完成了使用 ApplicationCache 的简单示例。是的，虽然这只是个简单示例。让我们来点厉害的吧。\n\n### \"可以离线查看\"的网站  \n\n就像我在文章开始提到的那样，Lanyrd 最近发布了[一个 Mobile 网站](http://m.lanyrd.com/)，用户可以查看会议日程，地点，参与者等。离线访问这些数据对旅行和面临数据漫游费用的人来说是非常重要的。  \n\n离线所有内容简直太大了，但是通常一个用户只会对他们参与的事件感兴趣。  \n\n最近的 [Dive into HTML5](http://diveintohtml5.info/) 给我们[一个关于离线 Wikipedia 的示例](http://diveintohtml5.info/offline.html#fallback)，那是另外一个\"可以离线查看\"的网站。它的工作方式是每个链接使用一个几乎为空的 manifest 文件，当用户在网站中浏览时，这些网页立即成为他们缓存的一部分，当离线时，他们能够访问之前查看过的任意网页。  \n\nWikipedia 的解决方案非常简单，但是由于规范中存在一些诡异的地方，这又是非常惨的。对于初级用户来说，用户没有收到任何指示来表明哪些内容在离线情况下是可用的，并且没有可以获取这些信息的 JavaScript API。我们可以下载 manifest 文件，然后使用 JavaScript 解析它，但是所有的  Wikipedia 的页面是隐式缓存的，所以他们没有在 manifest 文件中被列出。  \n\n更进一步，坑＃1：缓存中的版本会被显示，而不是服务器端的版本。当用户第一次访问时，页面会被冻结，但是我们在坑＃2中发现，我们可以通过修改 manifest 文件来触发浏览器查看更新。但是我们什么时候改变 manifest 文件呢？每当一个 Wikipedia 的条目被更新？那样就会变的过于频繁，实际上如果 manifest 文件在更新的开始以及结束之间被修改，浏览器会[认为此次更新失败(step24)](http://www.whatwg.org/specs/web-apps/current-work/multipage/offline.html#downloading-or-updating-an-application-cache)。  \n\n更新的频率是个问题，但是更新的大小才是真正的杀手，想想你所看过的 Wikipedia 的数量吧，几百？几千？一个 AppCache 的更新会包括下载所有的页面。AppCache 没有提供删除隐式缓存元素的方法，所以数量会不断的增长，增长，直到达到浏览器的缓存最大限度，然后世界崩溃。这不是什么好事。  \n\n### 我们希望从离线网站获得什么？  \n我需要从一个提供离线能力的网站获得的是：  \n\n- 在线的情况下显示最新的数据，和没有 ApplicationCache 一样  \n- 允许我们（开发人员）控制哪些内容被缓存，什么时候被缓存以及怎样被缓存  \n- 允许我们提供给用户一些控制的能力，有可能以“保存为离线”或者“稍后阅读”按钮  \n- 每次对页面的访问必须提供给浏览器供离线显示需要的所有内容  \n\nApplicationCache，甚至夸大了它的作用的那些说法，都没有让这些变得简单。如果页面中包含了 manifest，它就会被缓存，你没办法用一个页面告诉浏览器所有被缓存的内容。  \n\n### 限制 ApplicationCache 的使用范围  \n最简单的让一个页面像没有 ApplicationCache 一样的方法是提供它时不包含 manifest。我们可以通过插入一个不可见的 iframe 指向包含 manifest 的页面来告诉浏览器需要缓存的内容。\n\n让我们转个弯。在线的情况下[访问这个页面](http://appcache-demo.s3-website-us-east-1.amazonaws.com/offline-iframe/)。之后你可以在离线的状态下访问[这个页面](http://appcache-demo.s3-website-us-east-1.amazonaws.com/offline-iframe/offline.html)。第一个页面并不是缓存的一部分，所以用户一直可以通过它获取最新的内容。  \n\n### Fallback  \n通过 ApplicationCache 的 manifest 文件可以定义一个如果一个请求失败的时候 Fallback 使用的资源。  \n\n    CACHE MANIFEST\n    FALLBACK:  \n    / fallback.html  \n    /assets/imgs/avatars/ assets/imgs/avatars/default-v1.png  \n\n这个 manifest 文件告诉 ApplicationCache 在任何网络请求失败的情况下显示 fallback.html，除非包含 /assets/imgs/avatars/ 的请求失败，这种情况下一个 Fallback 的图片会被使用。  \n\n了解 Fallback 实际怎么工作，[访问这个页面](http://appcache-demo.s3-website-us-east-1.amazonaws.com/simple-fallback/)。在没有网络请求的情况下再次访问页面，Fallback的页面会被显示。需要注意它强制重定向的方式，原始页面的 url 会被保留，这是很有用的。  \n\n顺便，存在 Fallback 资源[解决了在坑＃5中提到的网络规则中遇到的疑难杂症](http://appcache-demo.s3-website-us-east-1.amazonaws.com/with-fallback/)。现在同一域名中的连接都会被允许，但是对于其他域名来说网络通配符还是需要的。  \n\n现在我们更近了一步，我们在普通页面没有成功加载的情况下显示一个被缓存了的页面。  \n\n### 只对静态内容使用 ApplicationCache  \n说“静态内容”，我的意思是内容从来不会改变。可以是图片，脚本，样式表和我们的 Fallback 页面。  \n\n    CACHE MANIFEST\n    js/script-v1.js\n    css/style-v1.css\n    img/logo-v1.png\n    FALLBACK:\n    / fallback/v1.html\n    /imgs/avatars/ imgs/avatars/default-v1.png\n\n如果我们需要改变 JavaScript，我们上传一个新的文件，并且使用新的 url，比如：script-v2.js。  \n\n这样就可以解决坑1＃以及坑2＃带来的问题：用户永远被不会提供过期的脚本或者样式，因为它们在改变的时候会拥有一个新的 url。我们不需要去处理一个包含注释的版本好的 manifest，因为 url 中的文本改变已经足够触发刷新。所有的资源都会拥有一个未来过期时间，这样只有更新了的文件需要 Http 请求来更新内容。  \n\n## 坑6＃：再见吧，条件下载  \n等等，你不觉得整篇文章到现在还没有提到任何关于响应式设计的部分吗？  \n\n你有两套设计图片吗？是不是其中一个更小，以便使用 Mobile 设备的用户查看网站？你使用 Media Queries 来决定显示哪一个图片吗？好吧，ApplicationCache 讨厌你，讨厌你全家。  \n\n所有需要在网站中渲染的图片都需要在 manifest 中，并且浏览器会将所有图片下载。在这种响应式图片的情况下，用户最终会下载同样资源的所有版本，这显然违背了我们的意愿。用桌面版的图片吧，在客户端通过 [CSS background size](https://developer.mozilla.org/en/CSS/background-size) 重新处理图片的大小。  \n\n如果 Mobile 版本有一个完全不同的设计，至少将他们同高分辨率图片一起放置到一个 sprite 中，这样他们可以同时从 png 压缩中获益。  \n\n对于字体来说也是同样的道理。我看到过一些人建议使用[很多的字体格式](http://speakerdeck.com/u/jaffathecake/p/in-your-font-face?slide=38)，这对于普通网站来说是不错的，但是我们不能把他们都放到 manifest 文件里。对于离线用户，只使用 Trye Type Fonts (TTF) 吧，“嗨，未来不是属于 Web Open Font Format (WOFF) 的吗？”，是的，有可能，但是只是因为法律的原因。WOFF 相对于 TTF 并没有什么优势可言。是的，WOFF 可以在创建时进行压缩，但是并没有比 Gzip 的 TTF 好。另外，[WOFF 不支持很多的旧版本浏览器](http://caniuse.com/woff)，而 TTF 支持的浏览器多很多。  \n\n随他去吧，回到 Application Cache。\n### 对于需要离线的动态内容使用 LocalStorage  \n我们不能离线下载所有内容，它们确实太多了。我们希望用户获得他们离线情况下希望获得的内容。我们可以使用 LocalStorage 来保存数据。  \n\n是的，LocalStorage 就是个柜子，但是它是个使用很简单的有用柜子。在同一域名下的页面内，你可以放置任何的 text 数据到 LocalStorage 然后在之后获取它。  \n\nLocalStorage 是存储在硬盘的，虽然耗费不大，但是也[不是完全没有耗费](http://，我们应该控制calendar.perfplanet.com/2011/localstorage-read-performance/)的。所以我们应该控制读写的数量，只在必须的时候读写它。  \n\n我们给每一个存储的页面存储一个列表，然后另外设置一个列表跟踪我们离线缓存的内容和页面的标题，这意味着通过一次读取我们就可以列出我们已经缓存的列表，两次读取就可以显示一个特定的页面。  \n\n当我们保存页面 `articles/1.html` 供离线使用时，我们这样处理。\n\n    // Get the page content\n    var pageHtml = document.body.innerHTML;\n    var urlPath = location.pathName;\n    // Save it in local storage\n    localStorage.setItem( urlPath, pageHtml );\n    // Get our index\n    var index = JSON.parse( localStorage.getItem( index' ) );\n    // Set the title and save it\n    index[ urlPath ] = document.title;\n    localStorage.setItem( 'index', JSON.stringify( index ) );\n\n然后当用户离线情况下访问 `articles/1.html` 的时候，会得到 fallback.html，就像下面做的这样。  \n\n    var pageHtml = localStorage.getItem( urlPath );\n    if ( !pageHtml ) {\n        document.body.innerHTML = `'<h1>Page not available</h1>'`;\n    }\n    else {\n        document.body.innerHTML = localStorage.getItem( urlPath );\n        document.title = localStorage.getItem( 'index' )[ urlPath ];\n    }\n\n我们也可以遍历 localStorage.getItem( 'index' ) 来获得用户缓存的所有页面的详细信息。  \n\n### 同时使用 ApplicationCache 以及 LocalStorage  \n[这里是个以上操作的 Demo](http://appcache-demo.s3-website-us-east-1.amazonaws.com/localstorage-cache/)。文章页可以通过页面右上方的按钮进行缓存，index 页面会显示出哪些页面可以在离线状态下使用。  \n\n所有的代码[可以从 Github 获得](https://github.com/jakearchibald/appcache-demo/tree/master/www/localstorage-cache)。任何页面可以通过调用 [offliner.cacheCurrentPage()](https://github.com/jakearchibald/appcache-demo/blob/master/www/localstorage-cache/js/offliner-v1.js#L62) 来缓存。函数在每次进入 index 以及用户希望缓存的页面时被调用。  \n\n如果用户遇到了 fallback 页面。 [offliner.renderCurrentPage()](https://github.com/jakearchibald/appcache-demo/blob/master/www/localstorage-cache/js/offliner-v1.js#L74) 会被调用来渲染指定的页面。如果没有页面可以被显示，就会显示错误信息。哦，这提醒了我....  \n\n## 坑#7：我们不知道怎么获得 Fallback 页面  \n当我们不能显示一个具体的页面的时候，我们可以显示的信息是[非常不清晰](https://github.com/jakearchibald/appcache-demo/blob/master/www/localstorage-cache/js/offliner-v1.js#L84)的。根据规范，如果初始请求遇到以下情况 Fallback 页面会被使用：\"被重定向到了另外的来源，返回了 4XX 或 5XX 或者存在网络错误（不包括用户取消了下载）\"。  \n\n某种程度上这不错。如果用户在线使用，但是网站挂掉了，浏览器只是会使用缓存的数据，用户甚至不会被通知。不幸的是，我们没办法提供用户使用 fallback 的原因。可能因为用户没有连接，可能是他们输入了不正确的 url，也可能是服务器报错。我们并不知道到底发生了什么。  \n\n接下来让我们看下重定向。\n\n## 坑#8：重定向到其余网站的请求会被认为失败  \n是的，又是一个坑，好高兴啊你还在读。如果你想要去把自己锁在厕所的隔间，直到没有网络的时候才出来，我表示完全可以理解你。  \n如果你的一个链接需要跳转到 Twitter 或者 Facebook 去做一些认证，我们友善的 Application Cache 会认为这是**不被允许的**，然后显示 Fallback 页面。  \n\n这个规则还是有好的方面的。如果用户想要访问你的网站，但是他们使用的 wifi 强制他们重定向到 http://rubbish-network/pay-for-wifi-access (付费使用 wifi 的链接)，这个时候显示我们网站的 Fallback 页面是很好的。  \n\n在需要验证的重定向的时候，NETWORK 段下的白名单并不能帮上什么。作为替代方案，你可以使用 JavaScript 或者 meta-redirect。呃。。  \n\n### LocalStorage 方式的缺点  \n“我们到了缺点的部分了吗？那刚刚说过的那些算什么啊？”，我知道，但是别烦我。单纯的 ApplicationCache 的解决方案有一些缺点。  \n\n需要 JavaScript，虽然 Sprite Cow 使用 ApplicationCache 没有依赖 JavaScript，但是其余的网站都有使用。我以项上人头保证，很少人支持 ApplicationCache 但是不支持 JavaScript 。这并不是说 no-JavaScript 的支持不重要。[Lanyrd’s mobile 网站](http://m.lanyrd.com/)在浏览器不支持 JavaScript 的情况下依然运行的很好，实际上我们在旧的设备上避免了依赖 JavaScript 来使它变的简单和迅速。  \n\n有些请求的体验并不好。FALLBACK 的问题是，在它之前原始链接必须已经失败，请求的发送和接受会消耗一定的时间。这样看 坑#1 (文件总会从 ApplicationCache 加载)，确实是蛮有用的。  \n\nOpera 下 Fallback 不工作。Opera 不支持 manifest 属性中的 FALLBACK 段。希望他们能尽快的修复这个问题。  \n\n### m.lanyrd.com 有什么不同点呢  \n[之前看到的 Demo](http://appcache-demo.s3-website-us-east-1.amazonaws.com/localstorage-cache/) 只是我在 lanyrd 所做的事情的简化版。我们在 LocalStorage 中存储 JSON 数据，在 ApplicationCache 中存储对应的模版，而不是直接存储 HTML 文件供离线使用。这意味着我们可以不关心数据，只更新模版，也可以在不同的模版中使用相同的数据。  \n\n我们的每个会议的 JSON 有个版本号。版本号在浏览网站的时候会被检测。如果他们与已经缓存的不匹配，则会更新。这意味着只在存在更新的时候发送更新请求。  \n\n我们在用户跟踪或者下载事件发生时缓存数据，而不是提供按钮使用户可以离线存储特定的页面。这样浏览器可以知道用户需要哪些数据离线使用，这样如果他们更换了设备或者莫名其妙丢失了缓存，我们可以迅速的重新填充。  \n\n通过 XMLHttpRequest 和 pushState 来切换页面。这在 Mobile 设备上更快，因为它不需要在每个页面加载的时候重新执行 JavaScript，也使网站更像一个 App。  \n\n继续，由于遗留问题...\n## 坑#9：关于 XHR 额外的一点  \n离线情况下你可以发起 XHR 请求请求缓存资源，不幸的是，旧版本的 Webkit 以状态码为 0 返回这个请求，这种情况在流行的库中会被认为请求失败。  \n\n    // In jQuery...\n    $.ajax( url ).done( function(response) {\n        // Hooray, it worked!\n    }).fail( function(response) {\n        // Unfortunately, some requests\n        // that worked end up here\n    });\n\n具体点，这个问题存在于 Blackberry Playbook 和 iOS3 设备以及 Android 3/4。Android 2 没有这个 Bug，奇怪的是，它看上去运行了新版的 Webkit 内核，它支持 `history.pushState ` 而最新版的 Android 并不支持。他X的 ANDROID，以下是你需要处理这个问题的方式。  \n\n    $.ajax( url ).always( function(response) {\n    // Exit if this request was deliberately aborted\n    if (response.statusText === 'abort') { return; }\n    // Does this smell like an error?\n    if (response.responseText !== undefined) {\n        if (response.responseText && response.status < 400) {\n            // Not a real error, recover the content\n            response = response.responseText;\n        }\n        else {  \n            // This is a proper error, deal with it\n            return;\n        }\n    }\n    // do something with 'response'\n});\n\n你可以在[这个 Demo](http://appcache-demo.s3-website-us-east-1.amazonaws.com/localstorage-cache/) 上进行测试。\n\n### ApplicationCache: 你的朋友，你的坑\n我没有说不应该使用 ApplicationCache，它是很有用的。我们都知道有些人需要特别提醒，或者需要特殊的“看管”来保证他们不做蠢事。嗯，ApplicationCache 就是其中一个。  \n\n在细心的照料下，ApplicationCache 能做一些其他人不能做的事情。但是当他对你说“你不用雇佣水管工，我自己就可以搞定那整个浴室，我曾经搞定了白金汉宫所有的浴室，你看...”的时候，请绅士的拒绝他。  \n\n如果你不是在创建一个不需要任何网络请求的完全客户端的应用的话，请使用尽可能小的 ApplicationCache，其余的事情交给 LocalStorage 吧，这样会减少很多的麻烦。","slug":"2012-11-11-application-cache-is-a-douchebag","published":1,"updated":"2016-12-23T09:55:46.000Z","_id":"cix78b8kr00024as6qkjx6pxq","comments":1,"photos":[],"link":"","content":"<ul>\n<li>by  <a href=\"http://www.alistapart.com/authors/a/Jake%20Archibald\" title=\"Jake Archibald\" target=\"_blank\" rel=\"external\">Jake Archibald</a>  </li>\n<li>原文地址 <a href=\"http://www.alistapart.com/articles/application-cache-is-a-douchebag/\" title=\"Application Cache is a Douchebag\" target=\"_blank\" rel=\"external\">Application Cache is a Douchebag</a></li>\n</ul>\n<p><img src=\"http://www.alistapart.com/d/application-cache-is-a-douchebag/application-cache-is-a-douchebag.jpg\" alt=\"application-cache-is-a-douchebag\"></p>\n<p>早上好，我们最近发布了 <a href=\"http://m.lanyrd.com/\" target=\"_blank\" rel=\"external\">我们的 Mobile 网站</a>，其中使用了离线缓存技术。我将离线缓存部分的代码简化成了<a href=\"http://appcache-demo.s3-website-us-east-1.amazonaws.com/localstorage-cache/\" target=\"_blank\" rel=\"external\">一个小的实例</a>，并把代码放到了 <a href=\"https://github.com/jakearchibald/appcache-demo\" target=\"_blank\" rel=\"external\">Github</a> 上。不过在深入代码之前，请允许我向您讲述一个真实的故事。  </p>\n<a id=\"more\"></a>\n<p>故事发生在一个大家彼此很陌生的派对上，我躲在一群尝试介绍自己的人群之中。这时候，一个漂亮的女士走过来对着一个略显羞涩的人说，”我是 Dev，你叫什么名字？”  </p>\n<p>“呃，我是 LocalStorage”，他回答的很不自然，”我提供了一个脚本接口来管理跨页面和会话的文本存储”。  </p>\n<p>“他其实只是个简单的柜子”，另外一个人打断道，其余人也纷纷嘲笑 LocalStorage 对于资源的浪费。我跟他很熟，所以我并没有参与其中。  </p>\n<p>这个时候，人群中的另一个人尖着嗓子说，”嗨，我是 ApplicationCache”，说话的同时，他伸手去与 Dev 握手，”我仅仅通过增加一个文件成功的提升了狗屎般的离线体验，小而美，不需要脚本控制”，他在说脚本控制的同时做了个砍价的动作。与此同时，我却是咬牙切齿，因为我知道他过分的夸大了他的能力，坏消息是其余的人并没有意识到这一点。但是如果在这种情况下指出他在胡说八道，我肯定会被认为是个混蛋。  </p>\n<p>没能在那个晚上指出 ApplicationCache 的问题，让我感到非常不舒服。看到那些只是顺路看了下 ApplicationCache 的人夸奖他的易用性真是让人痛苦。我想我必须来说点什么：我在这里告诉你 ApplicationCache 就是个坑。  </p>\n<p>并不是说 ApplicationCache 没有用，或者是需要尽量避免使用，只是在什么情况下使用以及怎么使用的问题上需要非常的谨慎。一旦出了差错，混乱会被传递给用户。通过了解我们使用 ApplicationCache 的痛苦经历，你也许可以了解到能够从 ApplicationCache 中得到什么以及应该怎么使用它。  </p>\n<h3 id=\"离线访问的适用场景是怎么样的\"><a href=\"#离线访问的适用场景是怎么样的\" class=\"headerlink\" title=\"离线访问的适用场景是怎么样的\"></a>离线访问的适用场景是怎么样的</h3><p>我们在接入网络方面变得越来越好了，可以却依然不能任何什么时候都保持在线。比如说正在一辆在萨塞克斯西部平原上穿行的火车上写这篇文章的我。另外，当我在国外使用数据服务的时候我几乎可以听到网络提供商办公室里开香槟庆祝的声音。在数据漫游时使用网络会让我大放血，但网络中有我需要的数据，有些时候又不得不通过网络连接来获得它。  </p>\n<p>可以在离线情况下访问的网站大概可以分为两类，一类”可以离线使用”的网站，而另一类则”可以离线查看”的网站。  </p>\n<p>“可以离线查看”的网站包括 <a href=\"http://www.wikipedia.com/\" target=\"_blank\" rel=\"external\">Wikipedia</a>, <a href=\"http://youtube.com/\" target=\"_blank\" rel=\"external\">YouTube</a>, 和 <a href=\"http://twitter.com/\" target=\"_blank\" rel=\"external\">Twitter</a>。他们复杂的处理都在服务器上进行，虽然可以获得很多的数据，但是在用户只能使用其中很小的一部分。  </p>\n<p>“可以离线使用”的网站有 <a href=\"http://www.cuttherope.ie/\" target=\"_blank\" rel=\"external\">Cut the Rope</a>, <a href=\"http://csslint.net/\" target=\"_blank\" rel=\"external\">CSS Lint</a>, 和 <a href=\"http://docs.google.com/\" target=\"_blank\" rel=\"external\">Google Docs</a>。这些网站复杂的业务逻辑很多是在客户端实现的。他们只提供了一定量的数据，但是可以通过各种方法是用这些数据，用户甚至创造自己的数据。这正是 ApplicationCache 被设计时想要针对的情况，我们来首先来看一个关于它的简单介绍。  </p>\n<h3 id=\"“可以离线使用”的网站\"><a href=\"#“可以离线使用”的网站\" class=\"headerlink\" title=\"“可以离线使用”的网站\"></a>“可以离线使用”的网站</h3><p><a href=\"http://www.spritecow.com/\" target=\"_blank\" rel=\"external\">Sprite Cow</a> 是一个可以离线使用的网站，CSS sprites 对于<a href=\"http://css-tricks.com/css-sprites/\" target=\"_blank\" rel=\"external\">提高性能</a>是很有好处的，但是在 sprite 页中找到一个元素的大小和位置是很复杂的。Sprite Cow 加载 sprite 页面，然后产生 CSS 来展示其中特定的部分。它包括一个 HTML 文件，一些静态文件，所有的处理都会在客户端执行，服务器只负责提供静态文件。  </p>\n<p>在火车上能像使用 Native App 一样使用 Sprite Cow 真的是很好的体验。为了做到这样，我们创建了一个 manifest 文件，其中列出了网站需要的所有静态文件：</p>\n<pre><code>CACHE MANIFEST\nassets/6/script/mainmin.js\nassets/6/style/mainmin.css\nassets/6/style/fonts/pro.ttf\nassets/6/style/imgs/sprites1.png\n...\n</code></pre><p>然后将 manifest 文件通过一个属性链接到 html 页面上。  </p>\n<pre><code>`&lt;html manifest=&quot;offline.appcache&quot;&gt;`\n</code></pre><p>HTML 页面本身没有在 manifest 文件中列出，但是包含 manifest 的页面自身会成为 manifest 的一部分。  </p>\n<p>实践表明，如果你在线的情况下访问了 <a href=\"http://www.spritecow.com/\" target=\"_blank\" rel=\"external\">Sprite Cow</a>，你可以在以后离线时访问他。  </p>\n<p>Chrome 的 Web Inspector 中的 resource 标签可以展示 manifest 文件中记录的文件，它属于属于哪个页面。如果你需要清除这些缓存，访问 <a href=\"chrome://appcache-internals/\" target=\"_blank\" rel=\"external\">chrome://appcache-internals/</a> 就可以了。  </p>\n<p>首先，这看上去像是一个很神奇的解决方案，不幸的是，我在说这会是个简单介绍的时候撒谎了，ApplicationCache 的规则更像是一个洋葱，它有很多很多层，随着你慢慢剥开它，眼泪也会慢慢流下来。  </p>\n<h2 id=\"坑-1：即便在线，文件也从-ApplicationCache-中加载\"><a href=\"#坑-1：即便在线，文件也从-ApplicationCache-中加载\" class=\"headerlink\" title=\"坑#1：即便在线，文件也从 ApplicationCache 中加载\"></a>坑#1：即便在线，文件也从 ApplicationCache 中加载</h2><p>当你访问 Sprite Cow 的时候，你会立即获得缓存中的版本，当页面渲染结束后（实际上不一定在渲染结束的情况下进行），浏览器会查看 manifest 文件以及被缓存的文件的更新情况。  </p>\n<p>这看上去像是很奇怪的处理方式，这决定了浏览器不用等到连接 Timeout 来决定你处于离线状态。  </p>\n<p>ApplicationCache 会抛出 <code>updateready</code> 事件来告诉我们内容有更新，但是我们并不能在这个时候简单的刷新页面，因为用户可能正在使用他们已经获得的旧版本。  </p>\n<p>这并不是一个大问题，因为旧版本可能也是足够好的，如果需要的话我们可以显示”发现了一个更新，请刷新页面获取更新”的信息。你可能曾经在 Google 的应用中看到过它，比如 Google Reader 或者是 Gmail。  </p>\n<p>还记得我在四段之前说 ApplicationCache 会在页面渲染结束后查看是否有更新吗? 我又撒谎了。</p>\n<h2 id=\"坑-2：ApplicationCache-只在-Manifest-文件改变的时候更新\"><a href=\"#坑-2：ApplicationCache-只在-Manifest-文件改变的时候更新\" class=\"headerlink\" title=\"坑#2：ApplicationCache 只在 Manifest 文件改变的时候更新\"></a>坑#2：ApplicationCache 只在 Manifest 文件改变的时候更新</h2><p>HTTP 已经有缓存模型了，每个文件可以定义怎样被浏览器缓存。最基本的，每个独立的文件可以声明”永远不要缓存我”或者”与服务器进行验证，它会告诉你有没有更新”或者”直到 2022 年 4 月 1 日我都是可以使用的”。  </p>\n<p>但是，如果在你的 manifest 中有 50 个 html 页面，每次你在线的情况下访问他们的时候，浏览器会创建 50 个网络请求来确认他们是不是需要更新。  </p>\n<p>作为一个不寻常的解决方式，浏览器只会在 manifest 文件发生更新时查看 manifest 文件中列出的文件是不是有更新。 manifest 文件比较是以二进制方式进行的。  </p>\n<p>这个处理对于通过 CDN 分发并且永远不会改变的静态文件来说是透明的。当 CSS/JavaScript 等等改变的时候，它们会使用与之前不同的 url，这意味着 manifest 文件改变了。如果你不熟悉缓存以及 CDN，请先查看 <a href=\"http://developer.yahoo.com/performance/rules.html#expires\" target=\"_blank\" rel=\"external\">Yahoo 的性能最佳实践指引</a>。  </p>\n<p>有些资源不能简单的改变他们的 url，比如说我们的 HTML 页面。除非更新了 manifest 文件 ApplicationCache 不会查看文件的更新。最简单的方式是，在 manifest 文件中增加注释。</p>\n<pre><code>CACHE MANIFEST  \n# v1\nwhatever.html  \n</code></pre><p>在 manifest 文件中，注释以<code>#</code>开始，如果我更新了 html 页面，我需要更新注释到 <code># v2</code>，来触发更新。你可以使用脚本通过类似 ETag 的方式修改在 manifest 文件中的注释，这样每个文件的改变都可以保证 manifest 文件能够更新。  </p>\n<p>但是，更新 manifest 文件中的文本并不能保证其中的资源会访问服务器获得更新。  </p>\n<h2 id=\"坑-3：ApplicationCache-只是个附加的缓存，而不是替代品\"><a href=\"#坑-3：ApplicationCache-只是个附加的缓存，而不是替代品\" class=\"headerlink\" title=\"坑#3：ApplicationCache 只是个附加的缓存，而不是替代品\"></a>坑#3：ApplicationCache 只是个附加的缓存，而不是替代品</h2><p>当浏览器更新 ApplicationCache 时会像平常一样请求 manifest 文件的地址。它遵循普通的缓存逻辑，如果一个元素的头部声明”在 2022 年 4 月 1 日之前我都是足够新鲜的”，浏览器会假设其是最新的直到 2022 年 4 月 1 日，这会阻止 manifest 的更新。  </p>\n<p>这是件好事，因为你可以通过它在 manifest 文件改变时减少浏览器需要发送的请求数目。  </p>\n<p>但这也会坑人，所以有些人尝试服务器不提供缓存头。但是在不提供的情况下，浏览器会猜测文件的缓存过期时间，你可以更新 html 页面以及 manifest 文件，但是浏览器不一定会更新它，因为他”猜测”文件是不需要更新的。  </p>\n<p>服务器提供的所有文件都应该包含缓存头，他们对于 manifest 中的文件以及 manifest 自身来说都是很重要的。如果文件会被频繁更新，它应该带上 <code>no-cache</code> 头部。如果文件偶尔更新，<code>must-revalidate</code> 是个更好的选择，比如 <code>must-revalidate</code> 对于 manifest 自身来说是个很好的选择。好吧，有点跑题……  </p>\n<h2 id=\"坑-4：永远永远不要长期缓存-Manifest\"><a href=\"#坑-4：永远永远不要长期缓存-Manifest\" class=\"headerlink\" title=\"坑#4：永远永远不要长期缓存 Manifest\"></a>坑#4：永远永远不要长期缓存 Manifest</h2><p>你可能觉得 manifest 文件是个静态文件，就像”在 2022 年 4 月 1 日之前我都是足够新鲜的”,然后再更新的时候更新 manifest 文件的 url。  </p>\n<p>别！千万别这样！  </p>\n<p>记住坑#1中提到的内容，当用户第二次访问页面时，他们会获取 ApplicationCache 的版本，如果已经更改了 manifest 文件地址的话，很不幸的，用户缓存的版本依然指向旧的 manifest 文件，它就永远不会更新了，永远。  </p>\n<h2 id=\"坑-5：未缓存的资源不会在缓存的页面中展示\"><a href=\"#坑-5：未缓存的资源不会在缓存的页面中展示\" class=\"headerlink\" title=\"坑#5：未缓存的资源不会在缓存的页面中展示\"></a>坑#5：未缓存的资源不会在缓存的页面中展示</h2><p>如果你缓存了 index.html，但是没有缓存 cate.jpg，文件即便是在线的情况下也不会在 index.html 中显示，实际上这是预期的行为，<a href=\"http://appcache-demo.s3-website-us-east-1.amazonaws.com/without-network/\" target=\"_blank\" rel=\"external\">自己看吧</a>。  </p>\n<p>为了禁止这个行为，需要使用 manifest 中的 NETWORK 段</p>\n<pre><code>CACHE MANIFEST\n# v1\nindex.html\nNETWORK:  \n*\n</code></pre><p>字符 * 表示，浏览器应该允许所有缓存页面中的的非缓存连接。这里，你可以看到<a href=\"http://appcache-demo.s3-website-us-east-1.amazonaws.com/with-network/\" target=\"_blank\" rel=\"external\">设置 NETWORK 之后的实例</a>。显然，这些链接在离线情况会失败。  </p>\n<p>很好，你已经完成了使用 ApplicationCache 的简单示例。是的，虽然这只是个简单示例。让我们来点厉害的吧。</p>\n<h3 id=\"“可以离线查看”的网站\"><a href=\"#“可以离线查看”的网站\" class=\"headerlink\" title=\"“可以离线查看”的网站\"></a>“可以离线查看”的网站</h3><p>就像我在文章开始提到的那样，Lanyrd 最近发布了<a href=\"http://m.lanyrd.com/\" target=\"_blank\" rel=\"external\">一个 Mobile 网站</a>，用户可以查看会议日程，地点，参与者等。离线访问这些数据对旅行和面临数据漫游费用的人来说是非常重要的。  </p>\n<p>离线所有内容简直太大了，但是通常一个用户只会对他们参与的事件感兴趣。  </p>\n<p>最近的 <a href=\"http://diveintohtml5.info/\" target=\"_blank\" rel=\"external\">Dive into HTML5</a> 给我们<a href=\"http://diveintohtml5.info/offline.html#fallback\" target=\"_blank\" rel=\"external\">一个关于离线 Wikipedia 的示例</a>，那是另外一个”可以离线查看”的网站。它的工作方式是每个链接使用一个几乎为空的 manifest 文件，当用户在网站中浏览时，这些网页立即成为他们缓存的一部分，当离线时，他们能够访问之前查看过的任意网页。  </p>\n<p>Wikipedia 的解决方案非常简单，但是由于规范中存在一些诡异的地方，这又是非常惨的。对于初级用户来说，用户没有收到任何指示来表明哪些内容在离线情况下是可用的，并且没有可以获取这些信息的 JavaScript API。我们可以下载 manifest 文件，然后使用 JavaScript 解析它，但是所有的  Wikipedia 的页面是隐式缓存的，所以他们没有在 manifest 文件中被列出。  </p>\n<p>更进一步，坑＃1：缓存中的版本会被显示，而不是服务器端的版本。当用户第一次访问时，页面会被冻结，但是我们在坑＃2中发现，我们可以通过修改 manifest 文件来触发浏览器查看更新。但是我们什么时候改变 manifest 文件呢？每当一个 Wikipedia 的条目被更新？那样就会变的过于频繁，实际上如果 manifest 文件在更新的开始以及结束之间被修改，浏览器会<a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/offline.html#downloading-or-updating-an-application-cache\" target=\"_blank\" rel=\"external\">认为此次更新失败(step24)</a>。  </p>\n<p>更新的频率是个问题，但是更新的大小才是真正的杀手，想想你所看过的 Wikipedia 的数量吧，几百？几千？一个 AppCache 的更新会包括下载所有的页面。AppCache 没有提供删除隐式缓存元素的方法，所以数量会不断的增长，增长，直到达到浏览器的缓存最大限度，然后世界崩溃。这不是什么好事。  </p>\n<h3 id=\"我们希望从离线网站获得什么？\"><a href=\"#我们希望从离线网站获得什么？\" class=\"headerlink\" title=\"我们希望从离线网站获得什么？\"></a>我们希望从离线网站获得什么？</h3><p>我需要从一个提供离线能力的网站获得的是：  </p>\n<ul>\n<li>在线的情况下显示最新的数据，和没有 ApplicationCache 一样  </li>\n<li>允许我们（开发人员）控制哪些内容被缓存，什么时候被缓存以及怎样被缓存  </li>\n<li>允许我们提供给用户一些控制的能力，有可能以“保存为离线”或者“稍后阅读”按钮  </li>\n<li>每次对页面的访问必须提供给浏览器供离线显示需要的所有内容  </li>\n</ul>\n<p>ApplicationCache，甚至夸大了它的作用的那些说法，都没有让这些变得简单。如果页面中包含了 manifest，它就会被缓存，你没办法用一个页面告诉浏览器所有被缓存的内容。  </p>\n<h3 id=\"限制-ApplicationCache-的使用范围\"><a href=\"#限制-ApplicationCache-的使用范围\" class=\"headerlink\" title=\"限制 ApplicationCache 的使用范围\"></a>限制 ApplicationCache 的使用范围</h3><p>最简单的让一个页面像没有 ApplicationCache 一样的方法是提供它时不包含 manifest。我们可以通过插入一个不可见的 iframe 指向包含 manifest 的页面来告诉浏览器需要缓存的内容。</p>\n<p>让我们转个弯。在线的情况下<a href=\"http://appcache-demo.s3-website-us-east-1.amazonaws.com/offline-iframe/\" target=\"_blank\" rel=\"external\">访问这个页面</a>。之后你可以在离线的状态下访问<a href=\"http://appcache-demo.s3-website-us-east-1.amazonaws.com/offline-iframe/offline.html\" target=\"_blank\" rel=\"external\">这个页面</a>。第一个页面并不是缓存的一部分，所以用户一直可以通过它获取最新的内容。  </p>\n<h3 id=\"Fallback\"><a href=\"#Fallback\" class=\"headerlink\" title=\"Fallback\"></a>Fallback</h3><p>通过 ApplicationCache 的 manifest 文件可以定义一个如果一个请求失败的时候 Fallback 使用的资源。  </p>\n<pre><code>CACHE MANIFEST\nFALLBACK:  \n/ fallback.html  \n/assets/imgs/avatars/ assets/imgs/avatars/default-v1.png  \n</code></pre><p>这个 manifest 文件告诉 ApplicationCache 在任何网络请求失败的情况下显示 fallback.html，除非包含 /assets/imgs/avatars/ 的请求失败，这种情况下一个 Fallback 的图片会被使用。  </p>\n<p>了解 Fallback 实际怎么工作，<a href=\"http://appcache-demo.s3-website-us-east-1.amazonaws.com/simple-fallback/\" target=\"_blank\" rel=\"external\">访问这个页面</a>。在没有网络请求的情况下再次访问页面，Fallback的页面会被显示。需要注意它强制重定向的方式，原始页面的 url 会被保留，这是很有用的。  </p>\n<p>顺便，存在 Fallback 资源<a href=\"http://appcache-demo.s3-website-us-east-1.amazonaws.com/with-fallback/\" target=\"_blank\" rel=\"external\">解决了在坑＃5中提到的网络规则中遇到的疑难杂症</a>。现在同一域名中的连接都会被允许，但是对于其他域名来说网络通配符还是需要的。  </p>\n<p>现在我们更近了一步，我们在普通页面没有成功加载的情况下显示一个被缓存了的页面。  </p>\n<h3 id=\"只对静态内容使用-ApplicationCache\"><a href=\"#只对静态内容使用-ApplicationCache\" class=\"headerlink\" title=\"只对静态内容使用 ApplicationCache\"></a>只对静态内容使用 ApplicationCache</h3><p>说“静态内容”，我的意思是内容从来不会改变。可以是图片，脚本，样式表和我们的 Fallback 页面。  </p>\n<pre><code>CACHE MANIFEST\njs/script-v1.js\ncss/style-v1.css\nimg/logo-v1.png\nFALLBACK:\n/ fallback/v1.html\n/imgs/avatars/ imgs/avatars/default-v1.png\n</code></pre><p>如果我们需要改变 JavaScript，我们上传一个新的文件，并且使用新的 url，比如：script-v2.js。  </p>\n<p>这样就可以解决坑1＃以及坑2＃带来的问题：用户永远被不会提供过期的脚本或者样式，因为它们在改变的时候会拥有一个新的 url。我们不需要去处理一个包含注释的版本好的 manifest，因为 url 中的文本改变已经足够触发刷新。所有的资源都会拥有一个未来过期时间，这样只有更新了的文件需要 Http 请求来更新内容。  </p>\n<h2 id=\"坑6＃：再见吧，条件下载\"><a href=\"#坑6＃：再见吧，条件下载\" class=\"headerlink\" title=\"坑6＃：再见吧，条件下载\"></a>坑6＃：再见吧，条件下载</h2><p>等等，你不觉得整篇文章到现在还没有提到任何关于响应式设计的部分吗？  </p>\n<p>你有两套设计图片吗？是不是其中一个更小，以便使用 Mobile 设备的用户查看网站？你使用 Media Queries 来决定显示哪一个图片吗？好吧，ApplicationCache 讨厌你，讨厌你全家。  </p>\n<p>所有需要在网站中渲染的图片都需要在 manifest 中，并且浏览器会将所有图片下载。在这种响应式图片的情况下，用户最终会下载同样资源的所有版本，这显然违背了我们的意愿。用桌面版的图片吧，在客户端通过 <a href=\"https://developer.mozilla.org/en/CSS/background-size\" target=\"_blank\" rel=\"external\">CSS background size</a> 重新处理图片的大小。  </p>\n<p>如果 Mobile 版本有一个完全不同的设计，至少将他们同高分辨率图片一起放置到一个 sprite 中，这样他们可以同时从 png 压缩中获益。  </p>\n<p>对于字体来说也是同样的道理。我看到过一些人建议使用<a href=\"http://speakerdeck.com/u/jaffathecake/p/in-your-font-face?slide=38\" target=\"_blank\" rel=\"external\">很多的字体格式</a>，这对于普通网站来说是不错的，但是我们不能把他们都放到 manifest 文件里。对于离线用户，只使用 Trye Type Fonts (TTF) 吧，“嗨，未来不是属于 Web Open Font Format (WOFF) 的吗？”，是的，有可能，但是只是因为法律的原因。WOFF 相对于 TTF 并没有什么优势可言。是的，WOFF 可以在创建时进行压缩，但是并没有比 Gzip 的 TTF 好。另外，<a href=\"http://caniuse.com/woff\" target=\"_blank\" rel=\"external\">WOFF 不支持很多的旧版本浏览器</a>，而 TTF 支持的浏览器多很多。  </p>\n<p>随他去吧，回到 Application Cache。</p>\n<h3 id=\"对于需要离线的动态内容使用-LocalStorage\"><a href=\"#对于需要离线的动态内容使用-LocalStorage\" class=\"headerlink\" title=\"对于需要离线的动态内容使用 LocalStorage\"></a>对于需要离线的动态内容使用 LocalStorage</h3><p>我们不能离线下载所有内容，它们确实太多了。我们希望用户获得他们离线情况下希望获得的内容。我们可以使用 LocalStorage 来保存数据。  </p>\n<p>是的，LocalStorage 就是个柜子，但是它是个使用很简单的有用柜子。在同一域名下的页面内，你可以放置任何的 text 数据到 LocalStorage 然后在之后获取它。  </p>\n<p>LocalStorage 是存储在硬盘的，虽然耗费不大，但是也<a href=\"http://，我们应该控制calendar.perfplanet.com/2011/localstorage-read-performance/\" target=\"_blank\" rel=\"external\">不是完全没有耗费</a>的。所以我们应该控制读写的数量，只在必须的时候读写它。  </p>\n<p>我们给每一个存储的页面存储一个列表，然后另外设置一个列表跟踪我们离线缓存的内容和页面的标题，这意味着通过一次读取我们就可以列出我们已经缓存的列表，两次读取就可以显示一个特定的页面。  </p>\n<p>当我们保存页面 <code>articles/1.html</code> 供离线使用时，我们这样处理。</p>\n<pre><code>// Get the page content\nvar pageHtml = document.body.innerHTML;\nvar urlPath = location.pathName;\n// Save it in local storage\nlocalStorage.setItem( urlPath, pageHtml );\n// Get our index\nvar index = JSON.parse( localStorage.getItem( index&apos; ) );\n// Set the title and save it\nindex[ urlPath ] = document.title;\nlocalStorage.setItem( &apos;index&apos;, JSON.stringify( index ) );\n</code></pre><p>然后当用户离线情况下访问 <code>articles/1.html</code> 的时候，会得到 fallback.html，就像下面做的这样。  </p>\n<pre><code>var pageHtml = localStorage.getItem( urlPath );\nif ( !pageHtml ) {\n    document.body.innerHTML = `&apos;&lt;h1&gt;Page not available&lt;/h1&gt;&apos;`;\n}\nelse {\n    document.body.innerHTML = localStorage.getItem( urlPath );\n    document.title = localStorage.getItem( &apos;index&apos; )[ urlPath ];\n}\n</code></pre><p>我们也可以遍历 localStorage.getItem( ‘index’ ) 来获得用户缓存的所有页面的详细信息。  </p>\n<h3 id=\"同时使用-ApplicationCache-以及-LocalStorage\"><a href=\"#同时使用-ApplicationCache-以及-LocalStorage\" class=\"headerlink\" title=\"同时使用 ApplicationCache 以及 LocalStorage\"></a>同时使用 ApplicationCache 以及 LocalStorage</h3><p><a href=\"http://appcache-demo.s3-website-us-east-1.amazonaws.com/localstorage-cache/\" target=\"_blank\" rel=\"external\">这里是个以上操作的 Demo</a>。文章页可以通过页面右上方的按钮进行缓存，index 页面会显示出哪些页面可以在离线状态下使用。  </p>\n<p>所有的代码<a href=\"https://github.com/jakearchibald/appcache-demo/tree/master/www/localstorage-cache\" target=\"_blank\" rel=\"external\">可以从 Github 获得</a>。任何页面可以通过调用 <a href=\"https://github.com/jakearchibald/appcache-demo/blob/master/www/localstorage-cache/js/offliner-v1.js#L62\" target=\"_blank\" rel=\"external\">offliner.cacheCurrentPage()</a> 来缓存。函数在每次进入 index 以及用户希望缓存的页面时被调用。  </p>\n<p>如果用户遇到了 fallback 页面。 <a href=\"https://github.com/jakearchibald/appcache-demo/blob/master/www/localstorage-cache/js/offliner-v1.js#L74\" target=\"_blank\" rel=\"external\">offliner.renderCurrentPage()</a> 会被调用来渲染指定的页面。如果没有页面可以被显示，就会显示错误信息。哦，这提醒了我….  </p>\n<h2 id=\"坑-7：我们不知道怎么获得-Fallback-页面\"><a href=\"#坑-7：我们不知道怎么获得-Fallback-页面\" class=\"headerlink\" title=\"坑#7：我们不知道怎么获得 Fallback 页面\"></a>坑#7：我们不知道怎么获得 Fallback 页面</h2><p>当我们不能显示一个具体的页面的时候，我们可以显示的信息是<a href=\"https://github.com/jakearchibald/appcache-demo/blob/master/www/localstorage-cache/js/offliner-v1.js#L84\" target=\"_blank\" rel=\"external\">非常不清晰</a>的。根据规范，如果初始请求遇到以下情况 Fallback 页面会被使用：”被重定向到了另外的来源，返回了 4XX 或 5XX 或者存在网络错误（不包括用户取消了下载）”。  </p>\n<p>某种程度上这不错。如果用户在线使用，但是网站挂掉了，浏览器只是会使用缓存的数据，用户甚至不会被通知。不幸的是，我们没办法提供用户使用 fallback 的原因。可能因为用户没有连接，可能是他们输入了不正确的 url，也可能是服务器报错。我们并不知道到底发生了什么。  </p>\n<p>接下来让我们看下重定向。</p>\n<h2 id=\"坑-8：重定向到其余网站的请求会被认为失败\"><a href=\"#坑-8：重定向到其余网站的请求会被认为失败\" class=\"headerlink\" title=\"坑#8：重定向到其余网站的请求会被认为失败\"></a>坑#8：重定向到其余网站的请求会被认为失败</h2><p>是的，又是一个坑，好高兴啊你还在读。如果你想要去把自己锁在厕所的隔间，直到没有网络的时候才出来，我表示完全可以理解你。<br>如果你的一个链接需要跳转到 Twitter 或者 Facebook 去做一些认证，我们友善的 Application Cache 会认为这是<strong>不被允许的</strong>，然后显示 Fallback 页面。  </p>\n<p>这个规则还是有好的方面的。如果用户想要访问你的网站，但是他们使用的 wifi 强制他们重定向到 <a href=\"http://rubbish-network/pay-for-wifi-access\" target=\"_blank\" rel=\"external\">http://rubbish-network/pay-for-wifi-access</a> (付费使用 wifi 的链接)，这个时候显示我们网站的 Fallback 页面是很好的。  </p>\n<p>在需要验证的重定向的时候，NETWORK 段下的白名单并不能帮上什么。作为替代方案，你可以使用 JavaScript 或者 meta-redirect。呃。。  </p>\n<h3 id=\"LocalStorage-方式的缺点\"><a href=\"#LocalStorage-方式的缺点\" class=\"headerlink\" title=\"LocalStorage 方式的缺点\"></a>LocalStorage 方式的缺点</h3><p>“我们到了缺点的部分了吗？那刚刚说过的那些算什么啊？”，我知道，但是别烦我。单纯的 ApplicationCache 的解决方案有一些缺点。  </p>\n<p>需要 JavaScript，虽然 Sprite Cow 使用 ApplicationCache 没有依赖 JavaScript，但是其余的网站都有使用。我以项上人头保证，很少人支持 ApplicationCache 但是不支持 JavaScript 。这并不是说 no-JavaScript 的支持不重要。<a href=\"http://m.lanyrd.com/\" target=\"_blank\" rel=\"external\">Lanyrd’s mobile 网站</a>在浏览器不支持 JavaScript 的情况下依然运行的很好，实际上我们在旧的设备上避免了依赖 JavaScript 来使它变的简单和迅速。  </p>\n<p>有些请求的体验并不好。FALLBACK 的问题是，在它之前原始链接必须已经失败，请求的发送和接受会消耗一定的时间。这样看 坑#1 (文件总会从 ApplicationCache 加载)，确实是蛮有用的。  </p>\n<p>Opera 下 Fallback 不工作。Opera 不支持 manifest 属性中的 FALLBACK 段。希望他们能尽快的修复这个问题。  </p>\n<h3 id=\"m-lanyrd-com-有什么不同点呢\"><a href=\"#m-lanyrd-com-有什么不同点呢\" class=\"headerlink\" title=\"m.lanyrd.com 有什么不同点呢\"></a>m.lanyrd.com 有什么不同点呢</h3><p><a href=\"http://appcache-demo.s3-website-us-east-1.amazonaws.com/localstorage-cache/\" target=\"_blank\" rel=\"external\">之前看到的 Demo</a> 只是我在 lanyrd 所做的事情的简化版。我们在 LocalStorage 中存储 JSON 数据，在 ApplicationCache 中存储对应的模版，而不是直接存储 HTML 文件供离线使用。这意味着我们可以不关心数据，只更新模版，也可以在不同的模版中使用相同的数据。  </p>\n<p>我们的每个会议的 JSON 有个版本号。版本号在浏览网站的时候会被检测。如果他们与已经缓存的不匹配，则会更新。这意味着只在存在更新的时候发送更新请求。  </p>\n<p>我们在用户跟踪或者下载事件发生时缓存数据，而不是提供按钮使用户可以离线存储特定的页面。这样浏览器可以知道用户需要哪些数据离线使用，这样如果他们更换了设备或者莫名其妙丢失了缓存，我们可以迅速的重新填充。  </p>\n<p>通过 XMLHttpRequest 和 pushState 来切换页面。这在 Mobile 设备上更快，因为它不需要在每个页面加载的时候重新执行 JavaScript，也使网站更像一个 App。  </p>\n<p>继续，由于遗留问题…</p>\n<h2 id=\"坑-9：关于-XHR-额外的一点\"><a href=\"#坑-9：关于-XHR-额外的一点\" class=\"headerlink\" title=\"坑#9：关于 XHR 额外的一点\"></a>坑#9：关于 XHR 额外的一点</h2><p>离线情况下你可以发起 XHR 请求请求缓存资源，不幸的是，旧版本的 Webkit 以状态码为 0 返回这个请求，这种情况在流行的库中会被认为请求失败。  </p>\n<pre><code>// In jQuery...\n$.ajax( url ).done( function(response) {\n    // Hooray, it worked!\n}).fail( function(response) {\n    // Unfortunately, some requests\n    // that worked end up here\n});\n</code></pre><p>具体点，这个问题存在于 Blackberry Playbook 和 iOS3 设备以及 Android 3/4。Android 2 没有这个 Bug，奇怪的是，它看上去运行了新版的 Webkit 内核，它支持 <code>history.pushState</code> 而最新版的 Android 并不支持。他X的 ANDROID，以下是你需要处理这个问题的方式。  </p>\n<pre><code>$.ajax( url ).always( function(response) {\n// Exit if this request was deliberately aborted\nif (response.statusText === &apos;abort&apos;) { return; }\n// Does this smell like an error?\nif (response.responseText !== undefined) {\n    if (response.responseText &amp;&amp; response.status &lt; 400) {\n        // Not a real error, recover the content\n        response = response.responseText;\n    }\n    else {  \n        // This is a proper error, deal with it\n        return;\n    }\n}\n// do something with &apos;response&apos;\n</code></pre><p>});</p>\n<p>你可以在<a href=\"http://appcache-demo.s3-website-us-east-1.amazonaws.com/localstorage-cache/\" target=\"_blank\" rel=\"external\">这个 Demo</a> 上进行测试。</p>\n<h3 id=\"ApplicationCache-你的朋友，你的坑\"><a href=\"#ApplicationCache-你的朋友，你的坑\" class=\"headerlink\" title=\"ApplicationCache: 你的朋友，你的坑\"></a>ApplicationCache: 你的朋友，你的坑</h3><p>我没有说不应该使用 ApplicationCache，它是很有用的。我们都知道有些人需要特别提醒，或者需要特殊的“看管”来保证他们不做蠢事。嗯，ApplicationCache 就是其中一个。  </p>\n<p>在细心的照料下，ApplicationCache 能做一些其他人不能做的事情。但是当他对你说“你不用雇佣水管工，我自己就可以搞定那整个浴室，我曾经搞定了白金汉宫所有的浴室，你看…”的时候，请绅士的拒绝他。  </p>\n<p>如果你不是在创建一个不需要任何网络请求的完全客户端的应用的话，请使用尽可能小的 ApplicationCache，其余的事情交给 LocalStorage 吧，这样会减少很多的麻烦。</p>\n","excerpt":"<ul>\n<li>by  <a href=\"http://www.alistapart.com/authors/a/Jake%20Archibald\" title=\"Jake Archibald\">Jake Archibald</a>  </li>\n<li>原文地址 <a href=\"http://www.alistapart.com/articles/application-cache-is-a-douchebag/\" title=\"Application Cache is a Douchebag\">Application Cache is a Douchebag</a></li>\n</ul>\n<p><img src=\"http://www.alistapart.com/d/application-cache-is-a-douchebag/application-cache-is-a-douchebag.jpg\" alt=\"application-cache-is-a-douchebag\"></p>\n<p>早上好，我们最近发布了 <a href=\"http://m.lanyrd.com/\">我们的 Mobile 网站</a>，其中使用了离线缓存技术。我将离线缓存部分的代码简化成了<a href=\"http://appcache-demo.s3-website-us-east-1.amazonaws.com/localstorage-cache/\">一个小的实例</a>，并把代码放到了 <a href=\"https://github.com/jakearchibald/appcache-demo\">Github</a> 上。不过在深入代码之前，请允许我向您讲述一个真实的故事。  </p>","more":"<p>故事发生在一个大家彼此很陌生的派对上，我躲在一群尝试介绍自己的人群之中。这时候，一个漂亮的女士走过来对着一个略显羞涩的人说，”我是 Dev，你叫什么名字？”  </p>\n<p>“呃，我是 LocalStorage”，他回答的很不自然，”我提供了一个脚本接口来管理跨页面和会话的文本存储”。  </p>\n<p>“他其实只是个简单的柜子”，另外一个人打断道，其余人也纷纷嘲笑 LocalStorage 对于资源的浪费。我跟他很熟，所以我并没有参与其中。  </p>\n<p>这个时候，人群中的另一个人尖着嗓子说，”嗨，我是 ApplicationCache”，说话的同时，他伸手去与 Dev 握手，”我仅仅通过增加一个文件成功的提升了狗屎般的离线体验，小而美，不需要脚本控制”，他在说脚本控制的同时做了个砍价的动作。与此同时，我却是咬牙切齿，因为我知道他过分的夸大了他的能力，坏消息是其余的人并没有意识到这一点。但是如果在这种情况下指出他在胡说八道，我肯定会被认为是个混蛋。  </p>\n<p>没能在那个晚上指出 ApplicationCache 的问题，让我感到非常不舒服。看到那些只是顺路看了下 ApplicationCache 的人夸奖他的易用性真是让人痛苦。我想我必须来说点什么：我在这里告诉你 ApplicationCache 就是个坑。  </p>\n<p>并不是说 ApplicationCache 没有用，或者是需要尽量避免使用，只是在什么情况下使用以及怎么使用的问题上需要非常的谨慎。一旦出了差错，混乱会被传递给用户。通过了解我们使用 ApplicationCache 的痛苦经历，你也许可以了解到能够从 ApplicationCache 中得到什么以及应该怎么使用它。  </p>\n<h3 id=\"离线访问的适用场景是怎么样的\"><a href=\"#离线访问的适用场景是怎么样的\" class=\"headerlink\" title=\"离线访问的适用场景是怎么样的\"></a>离线访问的适用场景是怎么样的</h3><p>我们在接入网络方面变得越来越好了，可以却依然不能任何什么时候都保持在线。比如说正在一辆在萨塞克斯西部平原上穿行的火车上写这篇文章的我。另外，当我在国外使用数据服务的时候我几乎可以听到网络提供商办公室里开香槟庆祝的声音。在数据漫游时使用网络会让我大放血，但网络中有我需要的数据，有些时候又不得不通过网络连接来获得它。  </p>\n<p>可以在离线情况下访问的网站大概可以分为两类，一类”可以离线使用”的网站，而另一类则”可以离线查看”的网站。  </p>\n<p>“可以离线查看”的网站包括 <a href=\"http://www.wikipedia.com/\">Wikipedia</a>, <a href=\"http://youtube.com/\">YouTube</a>, 和 <a href=\"http://twitter.com/\">Twitter</a>。他们复杂的处理都在服务器上进行，虽然可以获得很多的数据，但是在用户只能使用其中很小的一部分。  </p>\n<p>“可以离线使用”的网站有 <a href=\"http://www.cuttherope.ie/\">Cut the Rope</a>, <a href=\"http://csslint.net/\">CSS Lint</a>, 和 <a href=\"http://docs.google.com/\">Google Docs</a>。这些网站复杂的业务逻辑很多是在客户端实现的。他们只提供了一定量的数据，但是可以通过各种方法是用这些数据，用户甚至创造自己的数据。这正是 ApplicationCache 被设计时想要针对的情况，我们来首先来看一个关于它的简单介绍。  </p>\n<h3 id=\"“可以离线使用”的网站\"><a href=\"#“可以离线使用”的网站\" class=\"headerlink\" title=\"“可以离线使用”的网站\"></a>“可以离线使用”的网站</h3><p><a href=\"http://www.spritecow.com/\">Sprite Cow</a> 是一个可以离线使用的网站，CSS sprites 对于<a href=\"http://css-tricks.com/css-sprites/\">提高性能</a>是很有好处的，但是在 sprite 页中找到一个元素的大小和位置是很复杂的。Sprite Cow 加载 sprite 页面，然后产生 CSS 来展示其中特定的部分。它包括一个 HTML 文件，一些静态文件，所有的处理都会在客户端执行，服务器只负责提供静态文件。  </p>\n<p>在火车上能像使用 Native App 一样使用 Sprite Cow 真的是很好的体验。为了做到这样，我们创建了一个 manifest 文件，其中列出了网站需要的所有静态文件：</p>\n<pre><code>CACHE MANIFEST\nassets/6/script/mainmin.js\nassets/6/style/mainmin.css\nassets/6/style/fonts/pro.ttf\nassets/6/style/imgs/sprites1.png\n...\n</code></pre><p>然后将 manifest 文件通过一个属性链接到 html 页面上。  </p>\n<pre><code>`&lt;html manifest=&quot;offline.appcache&quot;&gt;`\n</code></pre><p>HTML 页面本身没有在 manifest 文件中列出，但是包含 manifest 的页面自身会成为 manifest 的一部分。  </p>\n<p>实践表明，如果你在线的情况下访问了 <a href=\"http://www.spritecow.com/\">Sprite Cow</a>，你可以在以后离线时访问他。  </p>\n<p>Chrome 的 Web Inspector 中的 resource 标签可以展示 manifest 文件中记录的文件，它属于属于哪个页面。如果你需要清除这些缓存，访问 <a href=\"chrome://appcache-internals/\">chrome://appcache-internals/</a> 就可以了。  </p>\n<p>首先，这看上去像是一个很神奇的解决方案，不幸的是，我在说这会是个简单介绍的时候撒谎了，ApplicationCache 的规则更像是一个洋葱，它有很多很多层，随着你慢慢剥开它，眼泪也会慢慢流下来。  </p>\n<h2 id=\"坑-1：即便在线，文件也从-ApplicationCache-中加载\"><a href=\"#坑-1：即便在线，文件也从-ApplicationCache-中加载\" class=\"headerlink\" title=\"坑#1：即便在线，文件也从 ApplicationCache 中加载\"></a>坑#1：即便在线，文件也从 ApplicationCache 中加载</h2><p>当你访问 Sprite Cow 的时候，你会立即获得缓存中的版本，当页面渲染结束后（实际上不一定在渲染结束的情况下进行），浏览器会查看 manifest 文件以及被缓存的文件的更新情况。  </p>\n<p>这看上去像是很奇怪的处理方式，这决定了浏览器不用等到连接 Timeout 来决定你处于离线状态。  </p>\n<p>ApplicationCache 会抛出 <code>updateready</code> 事件来告诉我们内容有更新，但是我们并不能在这个时候简单的刷新页面，因为用户可能正在使用他们已经获得的旧版本。  </p>\n<p>这并不是一个大问题，因为旧版本可能也是足够好的，如果需要的话我们可以显示”发现了一个更新，请刷新页面获取更新”的信息。你可能曾经在 Google 的应用中看到过它，比如 Google Reader 或者是 Gmail。  </p>\n<p>还记得我在四段之前说 ApplicationCache 会在页面渲染结束后查看是否有更新吗? 我又撒谎了。</p>\n<h2 id=\"坑-2：ApplicationCache-只在-Manifest-文件改变的时候更新\"><a href=\"#坑-2：ApplicationCache-只在-Manifest-文件改变的时候更新\" class=\"headerlink\" title=\"坑#2：ApplicationCache 只在 Manifest 文件改变的时候更新\"></a>坑#2：ApplicationCache 只在 Manifest 文件改变的时候更新</h2><p>HTTP 已经有缓存模型了，每个文件可以定义怎样被浏览器缓存。最基本的，每个独立的文件可以声明”永远不要缓存我”或者”与服务器进行验证，它会告诉你有没有更新”或者”直到 2022 年 4 月 1 日我都是可以使用的”。  </p>\n<p>但是，如果在你的 manifest 中有 50 个 html 页面，每次你在线的情况下访问他们的时候，浏览器会创建 50 个网络请求来确认他们是不是需要更新。  </p>\n<p>作为一个不寻常的解决方式，浏览器只会在 manifest 文件发生更新时查看 manifest 文件中列出的文件是不是有更新。 manifest 文件比较是以二进制方式进行的。  </p>\n<p>这个处理对于通过 CDN 分发并且永远不会改变的静态文件来说是透明的。当 CSS/JavaScript 等等改变的时候，它们会使用与之前不同的 url，这意味着 manifest 文件改变了。如果你不熟悉缓存以及 CDN，请先查看 <a href=\"http://developer.yahoo.com/performance/rules.html#expires\">Yahoo 的性能最佳实践指引</a>。  </p>\n<p>有些资源不能简单的改变他们的 url，比如说我们的 HTML 页面。除非更新了 manifest 文件 ApplicationCache 不会查看文件的更新。最简单的方式是，在 manifest 文件中增加注释。</p>\n<pre><code>CACHE MANIFEST  \n# v1\nwhatever.html  \n</code></pre><p>在 manifest 文件中，注释以<code>#</code>开始，如果我更新了 html 页面，我需要更新注释到 <code># v2</code>，来触发更新。你可以使用脚本通过类似 ETag 的方式修改在 manifest 文件中的注释，这样每个文件的改变都可以保证 manifest 文件能够更新。  </p>\n<p>但是，更新 manifest 文件中的文本并不能保证其中的资源会访问服务器获得更新。  </p>\n<h2 id=\"坑-3：ApplicationCache-只是个附加的缓存，而不是替代品\"><a href=\"#坑-3：ApplicationCache-只是个附加的缓存，而不是替代品\" class=\"headerlink\" title=\"坑#3：ApplicationCache 只是个附加的缓存，而不是替代品\"></a>坑#3：ApplicationCache 只是个附加的缓存，而不是替代品</h2><p>当浏览器更新 ApplicationCache 时会像平常一样请求 manifest 文件的地址。它遵循普通的缓存逻辑，如果一个元素的头部声明”在 2022 年 4 月 1 日之前我都是足够新鲜的”，浏览器会假设其是最新的直到 2022 年 4 月 1 日，这会阻止 manifest 的更新。  </p>\n<p>这是件好事，因为你可以通过它在 manifest 文件改变时减少浏览器需要发送的请求数目。  </p>\n<p>但这也会坑人，所以有些人尝试服务器不提供缓存头。但是在不提供的情况下，浏览器会猜测文件的缓存过期时间，你可以更新 html 页面以及 manifest 文件，但是浏览器不一定会更新它，因为他”猜测”文件是不需要更新的。  </p>\n<p>服务器提供的所有文件都应该包含缓存头，他们对于 manifest 中的文件以及 manifest 自身来说都是很重要的。如果文件会被频繁更新，它应该带上 <code>no-cache</code> 头部。如果文件偶尔更新，<code>must-revalidate</code> 是个更好的选择，比如 <code>must-revalidate</code> 对于 manifest 自身来说是个很好的选择。好吧，有点跑题……  </p>\n<h2 id=\"坑-4：永远永远不要长期缓存-Manifest\"><a href=\"#坑-4：永远永远不要长期缓存-Manifest\" class=\"headerlink\" title=\"坑#4：永远永远不要长期缓存 Manifest\"></a>坑#4：永远永远不要长期缓存 Manifest</h2><p>你可能觉得 manifest 文件是个静态文件，就像”在 2022 年 4 月 1 日之前我都是足够新鲜的”,然后再更新的时候更新 manifest 文件的 url。  </p>\n<p>别！千万别这样！  </p>\n<p>记住坑#1中提到的内容，当用户第二次访问页面时，他们会获取 ApplicationCache 的版本，如果已经更改了 manifest 文件地址的话，很不幸的，用户缓存的版本依然指向旧的 manifest 文件，它就永远不会更新了，永远。  </p>\n<h2 id=\"坑-5：未缓存的资源不会在缓存的页面中展示\"><a href=\"#坑-5：未缓存的资源不会在缓存的页面中展示\" class=\"headerlink\" title=\"坑#5：未缓存的资源不会在缓存的页面中展示\"></a>坑#5：未缓存的资源不会在缓存的页面中展示</h2><p>如果你缓存了 index.html，但是没有缓存 cate.jpg，文件即便是在线的情况下也不会在 index.html 中显示，实际上这是预期的行为，<a href=\"http://appcache-demo.s3-website-us-east-1.amazonaws.com/without-network/\">自己看吧</a>。  </p>\n<p>为了禁止这个行为，需要使用 manifest 中的 NETWORK 段</p>\n<pre><code>CACHE MANIFEST\n# v1\nindex.html\nNETWORK:  \n*\n</code></pre><p>字符 * 表示，浏览器应该允许所有缓存页面中的的非缓存连接。这里，你可以看到<a href=\"http://appcache-demo.s3-website-us-east-1.amazonaws.com/with-network/\">设置 NETWORK 之后的实例</a>。显然，这些链接在离线情况会失败。  </p>\n<p>很好，你已经完成了使用 ApplicationCache 的简单示例。是的，虽然这只是个简单示例。让我们来点厉害的吧。</p>\n<h3 id=\"“可以离线查看”的网站\"><a href=\"#“可以离线查看”的网站\" class=\"headerlink\" title=\"“可以离线查看”的网站\"></a>“可以离线查看”的网站</h3><p>就像我在文章开始提到的那样，Lanyrd 最近发布了<a href=\"http://m.lanyrd.com/\">一个 Mobile 网站</a>，用户可以查看会议日程，地点，参与者等。离线访问这些数据对旅行和面临数据漫游费用的人来说是非常重要的。  </p>\n<p>离线所有内容简直太大了，但是通常一个用户只会对他们参与的事件感兴趣。  </p>\n<p>最近的 <a href=\"http://diveintohtml5.info/\">Dive into HTML5</a> 给我们<a href=\"http://diveintohtml5.info/offline.html#fallback\">一个关于离线 Wikipedia 的示例</a>，那是另外一个”可以离线查看”的网站。它的工作方式是每个链接使用一个几乎为空的 manifest 文件，当用户在网站中浏览时，这些网页立即成为他们缓存的一部分，当离线时，他们能够访问之前查看过的任意网页。  </p>\n<p>Wikipedia 的解决方案非常简单，但是由于规范中存在一些诡异的地方，这又是非常惨的。对于初级用户来说，用户没有收到任何指示来表明哪些内容在离线情况下是可用的，并且没有可以获取这些信息的 JavaScript API。我们可以下载 manifest 文件，然后使用 JavaScript 解析它，但是所有的  Wikipedia 的页面是隐式缓存的，所以他们没有在 manifest 文件中被列出。  </p>\n<p>更进一步，坑＃1：缓存中的版本会被显示，而不是服务器端的版本。当用户第一次访问时，页面会被冻结，但是我们在坑＃2中发现，我们可以通过修改 manifest 文件来触发浏览器查看更新。但是我们什么时候改变 manifest 文件呢？每当一个 Wikipedia 的条目被更新？那样就会变的过于频繁，实际上如果 manifest 文件在更新的开始以及结束之间被修改，浏览器会<a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/offline.html#downloading-or-updating-an-application-cache\">认为此次更新失败(step24)</a>。  </p>\n<p>更新的频率是个问题，但是更新的大小才是真正的杀手，想想你所看过的 Wikipedia 的数量吧，几百？几千？一个 AppCache 的更新会包括下载所有的页面。AppCache 没有提供删除隐式缓存元素的方法，所以数量会不断的增长，增长，直到达到浏览器的缓存最大限度，然后世界崩溃。这不是什么好事。  </p>\n<h3 id=\"我们希望从离线网站获得什么？\"><a href=\"#我们希望从离线网站获得什么？\" class=\"headerlink\" title=\"我们希望从离线网站获得什么？\"></a>我们希望从离线网站获得什么？</h3><p>我需要从一个提供离线能力的网站获得的是：  </p>\n<ul>\n<li>在线的情况下显示最新的数据，和没有 ApplicationCache 一样  </li>\n<li>允许我们（开发人员）控制哪些内容被缓存，什么时候被缓存以及怎样被缓存  </li>\n<li>允许我们提供给用户一些控制的能力，有可能以“保存为离线”或者“稍后阅读”按钮  </li>\n<li>每次对页面的访问必须提供给浏览器供离线显示需要的所有内容  </li>\n</ul>\n<p>ApplicationCache，甚至夸大了它的作用的那些说法，都没有让这些变得简单。如果页面中包含了 manifest，它就会被缓存，你没办法用一个页面告诉浏览器所有被缓存的内容。  </p>\n<h3 id=\"限制-ApplicationCache-的使用范围\"><a href=\"#限制-ApplicationCache-的使用范围\" class=\"headerlink\" title=\"限制 ApplicationCache 的使用范围\"></a>限制 ApplicationCache 的使用范围</h3><p>最简单的让一个页面像没有 ApplicationCache 一样的方法是提供它时不包含 manifest。我们可以通过插入一个不可见的 iframe 指向包含 manifest 的页面来告诉浏览器需要缓存的内容。</p>\n<p>让我们转个弯。在线的情况下<a href=\"http://appcache-demo.s3-website-us-east-1.amazonaws.com/offline-iframe/\">访问这个页面</a>。之后你可以在离线的状态下访问<a href=\"http://appcache-demo.s3-website-us-east-1.amazonaws.com/offline-iframe/offline.html\">这个页面</a>。第一个页面并不是缓存的一部分，所以用户一直可以通过它获取最新的内容。  </p>\n<h3 id=\"Fallback\"><a href=\"#Fallback\" class=\"headerlink\" title=\"Fallback\"></a>Fallback</h3><p>通过 ApplicationCache 的 manifest 文件可以定义一个如果一个请求失败的时候 Fallback 使用的资源。  </p>\n<pre><code>CACHE MANIFEST\nFALLBACK:  \n/ fallback.html  \n/assets/imgs/avatars/ assets/imgs/avatars/default-v1.png  \n</code></pre><p>这个 manifest 文件告诉 ApplicationCache 在任何网络请求失败的情况下显示 fallback.html，除非包含 /assets/imgs/avatars/ 的请求失败，这种情况下一个 Fallback 的图片会被使用。  </p>\n<p>了解 Fallback 实际怎么工作，<a href=\"http://appcache-demo.s3-website-us-east-1.amazonaws.com/simple-fallback/\">访问这个页面</a>。在没有网络请求的情况下再次访问页面，Fallback的页面会被显示。需要注意它强制重定向的方式，原始页面的 url 会被保留，这是很有用的。  </p>\n<p>顺便，存在 Fallback 资源<a href=\"http://appcache-demo.s3-website-us-east-1.amazonaws.com/with-fallback/\">解决了在坑＃5中提到的网络规则中遇到的疑难杂症</a>。现在同一域名中的连接都会被允许，但是对于其他域名来说网络通配符还是需要的。  </p>\n<p>现在我们更近了一步，我们在普通页面没有成功加载的情况下显示一个被缓存了的页面。  </p>\n<h3 id=\"只对静态内容使用-ApplicationCache\"><a href=\"#只对静态内容使用-ApplicationCache\" class=\"headerlink\" title=\"只对静态内容使用 ApplicationCache\"></a>只对静态内容使用 ApplicationCache</h3><p>说“静态内容”，我的意思是内容从来不会改变。可以是图片，脚本，样式表和我们的 Fallback 页面。  </p>\n<pre><code>CACHE MANIFEST\njs/script-v1.js\ncss/style-v1.css\nimg/logo-v1.png\nFALLBACK:\n/ fallback/v1.html\n/imgs/avatars/ imgs/avatars/default-v1.png\n</code></pre><p>如果我们需要改变 JavaScript，我们上传一个新的文件，并且使用新的 url，比如：script-v2.js。  </p>\n<p>这样就可以解决坑1＃以及坑2＃带来的问题：用户永远被不会提供过期的脚本或者样式，因为它们在改变的时候会拥有一个新的 url。我们不需要去处理一个包含注释的版本好的 manifest，因为 url 中的文本改变已经足够触发刷新。所有的资源都会拥有一个未来过期时间，这样只有更新了的文件需要 Http 请求来更新内容。  </p>\n<h2 id=\"坑6＃：再见吧，条件下载\"><a href=\"#坑6＃：再见吧，条件下载\" class=\"headerlink\" title=\"坑6＃：再见吧，条件下载\"></a>坑6＃：再见吧，条件下载</h2><p>等等，你不觉得整篇文章到现在还没有提到任何关于响应式设计的部分吗？  </p>\n<p>你有两套设计图片吗？是不是其中一个更小，以便使用 Mobile 设备的用户查看网站？你使用 Media Queries 来决定显示哪一个图片吗？好吧，ApplicationCache 讨厌你，讨厌你全家。  </p>\n<p>所有需要在网站中渲染的图片都需要在 manifest 中，并且浏览器会将所有图片下载。在这种响应式图片的情况下，用户最终会下载同样资源的所有版本，这显然违背了我们的意愿。用桌面版的图片吧，在客户端通过 <a href=\"https://developer.mozilla.org/en/CSS/background-size\">CSS background size</a> 重新处理图片的大小。  </p>\n<p>如果 Mobile 版本有一个完全不同的设计，至少将他们同高分辨率图片一起放置到一个 sprite 中，这样他们可以同时从 png 压缩中获益。  </p>\n<p>对于字体来说也是同样的道理。我看到过一些人建议使用<a href=\"http://speakerdeck.com/u/jaffathecake/p/in-your-font-face?slide=38\">很多的字体格式</a>，这对于普通网站来说是不错的，但是我们不能把他们都放到 manifest 文件里。对于离线用户，只使用 Trye Type Fonts (TTF) 吧，“嗨，未来不是属于 Web Open Font Format (WOFF) 的吗？”，是的，有可能，但是只是因为法律的原因。WOFF 相对于 TTF 并没有什么优势可言。是的，WOFF 可以在创建时进行压缩，但是并没有比 Gzip 的 TTF 好。另外，<a href=\"http://caniuse.com/woff\">WOFF 不支持很多的旧版本浏览器</a>，而 TTF 支持的浏览器多很多。  </p>\n<p>随他去吧，回到 Application Cache。</p>\n<h3 id=\"对于需要离线的动态内容使用-LocalStorage\"><a href=\"#对于需要离线的动态内容使用-LocalStorage\" class=\"headerlink\" title=\"对于需要离线的动态内容使用 LocalStorage\"></a>对于需要离线的动态内容使用 LocalStorage</h3><p>我们不能离线下载所有内容，它们确实太多了。我们希望用户获得他们离线情况下希望获得的内容。我们可以使用 LocalStorage 来保存数据。  </p>\n<p>是的，LocalStorage 就是个柜子，但是它是个使用很简单的有用柜子。在同一域名下的页面内，你可以放置任何的 text 数据到 LocalStorage 然后在之后获取它。  </p>\n<p>LocalStorage 是存储在硬盘的，虽然耗费不大，但是也<a href=\"http://，我们应该控制calendar.perfplanet.com/2011/localstorage-read-performance/\">不是完全没有耗费</a>的。所以我们应该控制读写的数量，只在必须的时候读写它。  </p>\n<p>我们给每一个存储的页面存储一个列表，然后另外设置一个列表跟踪我们离线缓存的内容和页面的标题，这意味着通过一次读取我们就可以列出我们已经缓存的列表，两次读取就可以显示一个特定的页面。  </p>\n<p>当我们保存页面 <code>articles/1.html</code> 供离线使用时，我们这样处理。</p>\n<pre><code>// Get the page content\nvar pageHtml = document.body.innerHTML;\nvar urlPath = location.pathName;\n// Save it in local storage\nlocalStorage.setItem( urlPath, pageHtml );\n// Get our index\nvar index = JSON.parse( localStorage.getItem( index&apos; ) );\n// Set the title and save it\nindex[ urlPath ] = document.title;\nlocalStorage.setItem( &apos;index&apos;, JSON.stringify( index ) );\n</code></pre><p>然后当用户离线情况下访问 <code>articles/1.html</code> 的时候，会得到 fallback.html，就像下面做的这样。  </p>\n<pre><code>var pageHtml = localStorage.getItem( urlPath );\nif ( !pageHtml ) {\n    document.body.innerHTML = `&apos;&lt;h1&gt;Page not available&lt;/h1&gt;&apos;`;\n}\nelse {\n    document.body.innerHTML = localStorage.getItem( urlPath );\n    document.title = localStorage.getItem( &apos;index&apos; )[ urlPath ];\n}\n</code></pre><p>我们也可以遍历 localStorage.getItem( ‘index’ ) 来获得用户缓存的所有页面的详细信息。  </p>\n<h3 id=\"同时使用-ApplicationCache-以及-LocalStorage\"><a href=\"#同时使用-ApplicationCache-以及-LocalStorage\" class=\"headerlink\" title=\"同时使用 ApplicationCache 以及 LocalStorage\"></a>同时使用 ApplicationCache 以及 LocalStorage</h3><p><a href=\"http://appcache-demo.s3-website-us-east-1.amazonaws.com/localstorage-cache/\">这里是个以上操作的 Demo</a>。文章页可以通过页面右上方的按钮进行缓存，index 页面会显示出哪些页面可以在离线状态下使用。  </p>\n<p>所有的代码<a href=\"https://github.com/jakearchibald/appcache-demo/tree/master/www/localstorage-cache\">可以从 Github 获得</a>。任何页面可以通过调用 <a href=\"https://github.com/jakearchibald/appcache-demo/blob/master/www/localstorage-cache/js/offliner-v1.js#L62\">offliner.cacheCurrentPage()</a> 来缓存。函数在每次进入 index 以及用户希望缓存的页面时被调用。  </p>\n<p>如果用户遇到了 fallback 页面。 <a href=\"https://github.com/jakearchibald/appcache-demo/blob/master/www/localstorage-cache/js/offliner-v1.js#L74\">offliner.renderCurrentPage()</a> 会被调用来渲染指定的页面。如果没有页面可以被显示，就会显示错误信息。哦，这提醒了我….  </p>\n<h2 id=\"坑-7：我们不知道怎么获得-Fallback-页面\"><a href=\"#坑-7：我们不知道怎么获得-Fallback-页面\" class=\"headerlink\" title=\"坑#7：我们不知道怎么获得 Fallback 页面\"></a>坑#7：我们不知道怎么获得 Fallback 页面</h2><p>当我们不能显示一个具体的页面的时候，我们可以显示的信息是<a href=\"https://github.com/jakearchibald/appcache-demo/blob/master/www/localstorage-cache/js/offliner-v1.js#L84\">非常不清晰</a>的。根据规范，如果初始请求遇到以下情况 Fallback 页面会被使用：”被重定向到了另外的来源，返回了 4XX 或 5XX 或者存在网络错误（不包括用户取消了下载）”。  </p>\n<p>某种程度上这不错。如果用户在线使用，但是网站挂掉了，浏览器只是会使用缓存的数据，用户甚至不会被通知。不幸的是，我们没办法提供用户使用 fallback 的原因。可能因为用户没有连接，可能是他们输入了不正确的 url，也可能是服务器报错。我们并不知道到底发生了什么。  </p>\n<p>接下来让我们看下重定向。</p>\n<h2 id=\"坑-8：重定向到其余网站的请求会被认为失败\"><a href=\"#坑-8：重定向到其余网站的请求会被认为失败\" class=\"headerlink\" title=\"坑#8：重定向到其余网站的请求会被认为失败\"></a>坑#8：重定向到其余网站的请求会被认为失败</h2><p>是的，又是一个坑，好高兴啊你还在读。如果你想要去把自己锁在厕所的隔间，直到没有网络的时候才出来，我表示完全可以理解你。<br>如果你的一个链接需要跳转到 Twitter 或者 Facebook 去做一些认证，我们友善的 Application Cache 会认为这是<strong>不被允许的</strong>，然后显示 Fallback 页面。  </p>\n<p>这个规则还是有好的方面的。如果用户想要访问你的网站，但是他们使用的 wifi 强制他们重定向到 <a href=\"http://rubbish-network/pay-for-wifi-access\">http://rubbish-network/pay-for-wifi-access</a> (付费使用 wifi 的链接)，这个时候显示我们网站的 Fallback 页面是很好的。  </p>\n<p>在需要验证的重定向的时候，NETWORK 段下的白名单并不能帮上什么。作为替代方案，你可以使用 JavaScript 或者 meta-redirect。呃。。  </p>\n<h3 id=\"LocalStorage-方式的缺点\"><a href=\"#LocalStorage-方式的缺点\" class=\"headerlink\" title=\"LocalStorage 方式的缺点\"></a>LocalStorage 方式的缺点</h3><p>“我们到了缺点的部分了吗？那刚刚说过的那些算什么啊？”，我知道，但是别烦我。单纯的 ApplicationCache 的解决方案有一些缺点。  </p>\n<p>需要 JavaScript，虽然 Sprite Cow 使用 ApplicationCache 没有依赖 JavaScript，但是其余的网站都有使用。我以项上人头保证，很少人支持 ApplicationCache 但是不支持 JavaScript 。这并不是说 no-JavaScript 的支持不重要。<a href=\"http://m.lanyrd.com/\">Lanyrd’s mobile 网站</a>在浏览器不支持 JavaScript 的情况下依然运行的很好，实际上我们在旧的设备上避免了依赖 JavaScript 来使它变的简单和迅速。  </p>\n<p>有些请求的体验并不好。FALLBACK 的问题是，在它之前原始链接必须已经失败，请求的发送和接受会消耗一定的时间。这样看 坑#1 (文件总会从 ApplicationCache 加载)，确实是蛮有用的。  </p>\n<p>Opera 下 Fallback 不工作。Opera 不支持 manifest 属性中的 FALLBACK 段。希望他们能尽快的修复这个问题。  </p>\n<h3 id=\"m-lanyrd-com-有什么不同点呢\"><a href=\"#m-lanyrd-com-有什么不同点呢\" class=\"headerlink\" title=\"m.lanyrd.com 有什么不同点呢\"></a>m.lanyrd.com 有什么不同点呢</h3><p><a href=\"http://appcache-demo.s3-website-us-east-1.amazonaws.com/localstorage-cache/\">之前看到的 Demo</a> 只是我在 lanyrd 所做的事情的简化版。我们在 LocalStorage 中存储 JSON 数据，在 ApplicationCache 中存储对应的模版，而不是直接存储 HTML 文件供离线使用。这意味着我们可以不关心数据，只更新模版，也可以在不同的模版中使用相同的数据。  </p>\n<p>我们的每个会议的 JSON 有个版本号。版本号在浏览网站的时候会被检测。如果他们与已经缓存的不匹配，则会更新。这意味着只在存在更新的时候发送更新请求。  </p>\n<p>我们在用户跟踪或者下载事件发生时缓存数据，而不是提供按钮使用户可以离线存储特定的页面。这样浏览器可以知道用户需要哪些数据离线使用，这样如果他们更换了设备或者莫名其妙丢失了缓存，我们可以迅速的重新填充。  </p>\n<p>通过 XMLHttpRequest 和 pushState 来切换页面。这在 Mobile 设备上更快，因为它不需要在每个页面加载的时候重新执行 JavaScript，也使网站更像一个 App。  </p>\n<p>继续，由于遗留问题…</p>\n<h2 id=\"坑-9：关于-XHR-额外的一点\"><a href=\"#坑-9：关于-XHR-额外的一点\" class=\"headerlink\" title=\"坑#9：关于 XHR 额外的一点\"></a>坑#9：关于 XHR 额外的一点</h2><p>离线情况下你可以发起 XHR 请求请求缓存资源，不幸的是，旧版本的 Webkit 以状态码为 0 返回这个请求，这种情况在流行的库中会被认为请求失败。  </p>\n<pre><code>// In jQuery...\n$.ajax( url ).done( function(response) {\n    // Hooray, it worked!\n}).fail( function(response) {\n    // Unfortunately, some requests\n    // that worked end up here\n});\n</code></pre><p>具体点，这个问题存在于 Blackberry Playbook 和 iOS3 设备以及 Android 3/4。Android 2 没有这个 Bug，奇怪的是，它看上去运行了新版的 Webkit 内核，它支持 <code>history.pushState</code> 而最新版的 Android 并不支持。他X的 ANDROID，以下是你需要处理这个问题的方式。  </p>\n<pre><code>$.ajax( url ).always( function(response) {\n// Exit if this request was deliberately aborted\nif (response.statusText === &apos;abort&apos;) { return; }\n// Does this smell like an error?\nif (response.responseText !== undefined) {\n    if (response.responseText &amp;&amp; response.status &lt; 400) {\n        // Not a real error, recover the content\n        response = response.responseText;\n    }\n    else {  \n        // This is a proper error, deal with it\n        return;\n    }\n}\n// do something with &apos;response&apos;\n</code></pre><p>});</p>\n<p>你可以在<a href=\"http://appcache-demo.s3-website-us-east-1.amazonaws.com/localstorage-cache/\">这个 Demo</a> 上进行测试。</p>\n<h3 id=\"ApplicationCache-你的朋友，你的坑\"><a href=\"#ApplicationCache-你的朋友，你的坑\" class=\"headerlink\" title=\"ApplicationCache: 你的朋友，你的坑\"></a>ApplicationCache: 你的朋友，你的坑</h3><p>我没有说不应该使用 ApplicationCache，它是很有用的。我们都知道有些人需要特别提醒，或者需要特殊的“看管”来保证他们不做蠢事。嗯，ApplicationCache 就是其中一个。  </p>\n<p>在细心的照料下，ApplicationCache 能做一些其他人不能做的事情。但是当他对你说“你不用雇佣水管工，我自己就可以搞定那整个浴室，我曾经搞定了白金汉宫所有的浴室，你看…”的时候，请绅士的拒绝他。  </p>\n<p>如果你不是在创建一个不需要任何网络请求的完全客户端的应用的话，请使用尽可能小的 ApplicationCache，其余的事情交给 LocalStorage 吧，这样会减少很多的麻烦。</p>"},{"layout":"post","title":"Medium 的 CSS 真他*的好","date":"2015-07-23T13:34:10.000Z","_content":"\n# Medium 的 CSS 真他*的好\n\n- 翻译自 [Medium by fat](https://medium.com/@fat/mediums-css-is-actually-pretty-fucking-good-b8e2a6c78b06)\n\n> I always believe that to be the best, you have to smell like the best, dress like the best, act like the best. When you throw your trash in the garbage can, it has to be better than anybody else who ever threw trash in the garbage can.   \n>\n> — Lil Wayne\n\n一段时间以来，我都想要写一些关于 Medium CSS 的东西。关于 Medium 的 CSS 有什么样的故事？我们做了哪些不一样的事情？怎么才能像我们一样做，或者可以从我们这学到点什么？\n\n以下包括一些 CSS 的记录，包括我们是怎么一步步走过来的，以及现状。\n\n<!-- more -->\n\n## 开始（一些历史）\n大概2年前，我加入了 Obvious Corp. 参与 *medium.com* 的开发工作。\n\n当时，Medium 已经进行了一系列的 “re-styles” (re-style 就是设计师通过一些比之前漂亮的东西来摧毁你的生活，结果就是，你要重写成吨的 CSS/LESS/SASS/等等)。由于这些 re-styles，代码中出现了非常多令人讨厌的东西 — 非常倚重 LESS 的语言特性，页面驱动的语义，non-sprited/non-retina 的图片资源，等等。\n\n我翻看 Git 以及其他代码管理工具获取到了 Medium 2012 年的个人资料页面的实现，*不寒而栗*。下面列出了发现的问题，请注意那些非常不应该的模式：\n\n- 所有样式都嵌套在 `.profile-page` class 下，没有任何重用组件（另外 *几乎* 所有样式都使用了 `.profile` 前缀）\n- 超级通用变量名形如 `@link-color` 只在 `profile-page.less` 中被使用，并没有其他用处\n- 非常深的嵌套（`.profile-page .profile-posts .home-post-summary .home-post-collection-image img` 是一个真实存在的选择器 - 性能会非常差）\n- 没有 image spriting\n- 没有 z-index 标准，没有 font 标准，没有 color 标准，没有 ** 标准\n\n[Old medium profile page](https://gist.github.com/fat/a4af78882d0003d2345e)\n\n## Project 1：图片\n当时，我参与了很多库 (Bootstrap, Ratchet, 等等)的开发工作，仔细处理每一个细节，希望能写出最好的 CSS 代码。\n\nMedium 的 CSS 代码当然非常不一样，不是简单的不同，而是屎一样的烂。我想解决这个问题。\n\n了解了所有需要处理的东西之后，我选择了 images 开始下手。我记得在了解到我们直到 2012 年没有做任何的 spriting 之后非常震惊。大约数百个图片资源，例如 placeholders, arrows, icons 等等，存在于 /img/ 文件夹中，简直是 icons 坟墓。\n\n为了解决这个问题，我做了两件事情。第一，我写了一个 CSS 工具脚本叫做 SUS（我们现在还在使用它，我将它开源在这里：[https://github.com/medium/sus](https://github.com/medium/sus)）,这个东西大部分是在 Guillermo Rauch 的帮助下用 IRC 编写完成，作用是从样式表中分离出图片，然后在另一个包含 data-uri 的文件中 lazy 加载。这只是一个小工具来帮助我们认识到怎么做。\n\n第二件事情，我和 Geoff Teehan 坐下来，创建了 Medium 的第一个 icon font。当时我们并不清楚具体要怎么做。经过几个漫长的夜晚，在 icomoon 和一个 Github 文章的帮助下，我们产出了一个对 Medium *非常* 好的东西。说它非常好，是因为我们可以删除 img 文件夹中 97% 的文件，每一个图标在我的 retina MacBook Pro 上都显示的非常好，并且只需要请求非常少的资源。\n\n## Project 2: 标准\n对我来说，另外一个大的工程是 z-index 标准。z-index 是个很容易就会失控到让人抓狂的东西。我不想让这种事情也出现在 Medium。 \n\n项目开始之前，很容易看到一个元素 `z-index:5;` 跟在一个 `z-index: 1000000;` 的节点后面，另外一个兄弟节点的样式是 `z-index: 1000001;`，还有一个 `z-index: 99999;`。\n\n在代码库这样的样式中比比皆是，因为并没有明确的方式指明应该怎么做。\n\n我开始了一项在整个代码库中人工审核 z-index 取值的艰巨任务，然后引入了一个可以被 z-indexing 组件使用（限制 1-10）的标准（z-index.less）。最终将所有的 z-index 定义都改用 z-index.less，这样就可以看出不同组件的相对位置了（实际上这是很方便的）。\n\n下面是当前 medium.com 使用的 z-index 文件。\n\n[https://gist.github.com/fat/1f6da6b3bd0311a1f8a0](https://gist.github.com/fat/1f6da6b3bd0311a1f8a0)\n\n当然，color 标准（黑色，灰色，logo 颜色），type 规范（字体大小，字重，字间距，行高）紧随 z-index 之后需要制定。\n\n另外，你可能注意到，变量命名遵循了一定的规范，并且采用了语义化命名，稍后会详细介绍。\n\n## Project 3: 新的样式指引\n\n制定了 Medium 规范后不久，我们开始了一场大的代码重构，代号 “Cocoon”。\n\nCocoon 抛弃了一些 post 模版（Medium 本来包含图片模版，引用模版等，不仅仅包括单个文章的模版），并且使用 post 列表替代了 post “cards”。\n\n我们将这次重构作为重新思考 Medium 并创建一个新的样式指引的机会。\n\n最初由我，Dave Gamache，Dustin Senos，和 Chris Erwin 共同来完成了这项工作。\n\n我们花了一些时间来着实加强我们在 Medium 编写生成环境 CSS/LESS 的想法。主要的更新如下：\n\n- 限制 LESS 的使用，只允许使用 variables 和 mixins (不允许使用 nesting, guards, extend, 等等) ，虽然其它的语言特性 *可以* 非常强大，但是我们发现经验没那么丰富的 LESS 开发者很容易就会陷入麻烦。我们同时选择了纯 CSS 的视觉审美（也包括它提供的一致性）并且想要我们的代码库向着这样的方向发展。\n- Classes 和 IDs 都是小写字母，中划线分割单词－这正是我们在 Bootstrap, Skeleton, Ratchet, 等等定义选择器的方式，我们认为我们在这里也可以这样做。另外一个原因是，这种定义方式遵循了 CSS 语言自身的定义方式，比如：border-radius-top-left。\n- 选择 components 而不是 page 层面的样式－我们希望我们的前端更像是一个库，根据这样的想法，我们将 profile.less 拆分成更加具体的文件，例如：button.less, dialog.less,tooltip.less 等。\n\n以下是完整的样式指引：\n[https://gist.github.com/fat/b27700946c777adacdf4](https://gist.github.com/fat/b27700946c777adacdf4)\n\n这并不完美，但是它理清了一些基础的思路，然后带领我们向着感觉上正确的方向前进。\n\n不幸的是，在样式指引更新之后，人们依然非常纠结，什么时候需要定义组件，什么时候需要定义子组件等等。并且我们偶尔会碰到一些并不很具体的东西，例如 classname：.nav-on-light-background-button 或者 .button-primary-sidebar-over-blur.\n\n现在人们不再使用 page 级别的前缀来定义 class 了（这是很好的），但是它们开始使用中划线间隔拼接很多任意单词，组成 classname。进化的过程如下：.button → .button-primary → .button-primary-dark → .button-primary-dark-container → .button-primary-dark-container-label，真是让人不舒服。\n\n## Project 4: 确定未来\n当时，我开始以成为“世界上最好代码”为目标在 Medium 内部写了 *很多* 的 CSS 代码，但并不是非常清楚最好的 CSS 代码到底是什么样子，但至少明白了当时的方向并不成功。\n\n> 人们编写代码的过程中会感到很困惑，更糟糕的是，他们以为自己写的 CSS 非常好，实际上却不是这样。\n\n所以，我开始四处观察－－了解一些框架，尝试不同的工具和哲学，与朋友沟通，与朋友的朋友沟通，等等。很快，我找到三个为了让我们的 CSS 代码向着正确的方向前进需要解决的问题。\n\n1. 引入新的 CSS variable, mixin, 和 classname 语义来避免过长的 classnames 以及增强可读性。\n2. 从 LESS 转到 Rework 来获得更强的 mixin support 和更佳接近于原生 CSS 的语法。\n3. 引入 CSS 性能（加载时间，fps，layout time 等）工具，使跟踪样式修改和回归更加简单。\n\n## Project 5: 语义\n我想要给我们的代码库一个更加严格的语义化标准。因为对于我们这种大小的团队，我觉得拥有一个可以依靠的规则是更简单的。并且我宁愿让事情变得更复杂一点，尽管这也意味着人们必须在创建新的 classes 的时候要更加留神。不过不惜一切代价，我希望能够避免过长的 classname，或者至少没那么容易出现。\n\n我开始就这个问题，与 Daryl Koopersmith 以及我的好朋友 Nicolas Gallagher 进行了长时间的讨论。\n\nNicolas 跟我的关系很有趣，Nicolas 经常告诉我一些事情，我说他是错的，叫着他的法语名字（Va te faire foutre, enculé），在他身边得瑟几个星期，直到不可避免的意识到他是对的，然后把他的想法划归己有。\n\n这一次也是一样，经过几个漫长的夜晚，我终于完成了一个与 Nicolas 的 SUITCSS 很像的语义化样式。很像，但是又那么 ~一丢丢~ 方面更好。\n\n于是，我开始抄袭 Nicolas 的东西，我扔掉了就的样式指引，然后复制粘贴了他的很大一部分，左改改，右改改。\n\n最终，我产出了我们当前使用的最新的样式指引，你可以在下面完整的阅读它，主要的更新是：\n\n- **.js-** 开头的 class names 代表依赖 javascript 选择器的元素\n- **.u-** 开头的 class name 单独目的的工具类，例如 .u-underline, .u-capitalize, 等等\n- 引入有意义的连字符以及驼峰－－区分 component, descendant components, 和 modifiers 的间隔符。\n- **.is-** 开头的 classes 表示有状态的 classes (经常被 js 切换) 例如 .is-disabled\n- 新的 CSS 变量语义： [property]-[value]—[component]\n- mixing 限制为只用在 polyfills 并且以 **.m-** 开头\n\n[https://gist.github.com/fat/a47b882eb5f84293c4ed](https://gist.github.com/fat/a47b882eb5f84293c4ed)\n\n复制粘贴样式指引是一回事，而重写你的 CSS 又是另一回事。\n\n庆幸的是我可以说服公司这个项目的重要性，然后他们给了 2½ 周的时间让我们重写 Medium.com 的所有 CSS－－如果你一直在关心我们的话，这只是我们[修复 CSS underline 问题](https://medium.com/designing-medium/crafting-link-underlines-on-medium-7c03a9274f9)所花费时间的很小一部分。\n\n也就是说，这次重写不只是宣泄，我们清理了一些比没用的样式，收集并整理了整个网站的实现，将文件拆解成小的子模块。让我惊喜的是，只造成了五次以内的回滚。\n\n当然，重构 CSS 意味着重构我们的模版－－增加更多的封装和严格的语义化。现在我们不再有数以百计使用随机 avatar classes 的一次性 <IMG> 标签，我们使用一个单独的集中式 avatar 模版，模版接受布尔选项，来触发不同的 modifiers 比如大小，样式等等。这让更新样式变的简单，而已实现细节时引入更少的 Bug。\n\n## Project X: 未来？\n毫无疑问，我们比两年之前变的更好了。在 Medium 写 CSS 变的非常愉快，不同经验的开发者们也在促进更加伟大的东西。\n\n大家都说，未来的 CSS 项目必须是关注性能。随着我们不断的完善我们的故事，然后推向下一个阶段，你可以想象怎样精确可靠的测量 layout 和 渲染性能是非常重要的。\n\n所以，还要更多的事情要做，但是我现在感觉我们已经非常好了，比我平时想的都要好。\n\n为你完成了这个冗长又无聊的 post 干杯。\n\n感谢 Katie, Dave, Mark, Koop, Kristofer, Nicolas 以及其它帮助我的人❤。","source":"_posts/2015-07-24-mediums-css-is-actually-pretty-fucking-good.md","raw":"---\nlayout: post\ncategory : front-end\ntitle: Medium 的 CSS 真他*的好\ndate: 2015-07-23 21:34:10\ntags : [Medium, CSS]\n---\n\n# Medium 的 CSS 真他*的好\n\n- 翻译自 [Medium by fat](https://medium.com/@fat/mediums-css-is-actually-pretty-fucking-good-b8e2a6c78b06)\n\n> I always believe that to be the best, you have to smell like the best, dress like the best, act like the best. When you throw your trash in the garbage can, it has to be better than anybody else who ever threw trash in the garbage can.   \n>\n> — Lil Wayne\n\n一段时间以来，我都想要写一些关于 Medium CSS 的东西。关于 Medium 的 CSS 有什么样的故事？我们做了哪些不一样的事情？怎么才能像我们一样做，或者可以从我们这学到点什么？\n\n以下包括一些 CSS 的记录，包括我们是怎么一步步走过来的，以及现状。\n\n<!-- more -->\n\n## 开始（一些历史）\n大概2年前，我加入了 Obvious Corp. 参与 *medium.com* 的开发工作。\n\n当时，Medium 已经进行了一系列的 “re-styles” (re-style 就是设计师通过一些比之前漂亮的东西来摧毁你的生活，结果就是，你要重写成吨的 CSS/LESS/SASS/等等)。由于这些 re-styles，代码中出现了非常多令人讨厌的东西 — 非常倚重 LESS 的语言特性，页面驱动的语义，non-sprited/non-retina 的图片资源，等等。\n\n我翻看 Git 以及其他代码管理工具获取到了 Medium 2012 年的个人资料页面的实现，*不寒而栗*。下面列出了发现的问题，请注意那些非常不应该的模式：\n\n- 所有样式都嵌套在 `.profile-page` class 下，没有任何重用组件（另外 *几乎* 所有样式都使用了 `.profile` 前缀）\n- 超级通用变量名形如 `@link-color` 只在 `profile-page.less` 中被使用，并没有其他用处\n- 非常深的嵌套（`.profile-page .profile-posts .home-post-summary .home-post-collection-image img` 是一个真实存在的选择器 - 性能会非常差）\n- 没有 image spriting\n- 没有 z-index 标准，没有 font 标准，没有 color 标准，没有 ** 标准\n\n[Old medium profile page](https://gist.github.com/fat/a4af78882d0003d2345e)\n\n## Project 1：图片\n当时，我参与了很多库 (Bootstrap, Ratchet, 等等)的开发工作，仔细处理每一个细节，希望能写出最好的 CSS 代码。\n\nMedium 的 CSS 代码当然非常不一样，不是简单的不同，而是屎一样的烂。我想解决这个问题。\n\n了解了所有需要处理的东西之后，我选择了 images 开始下手。我记得在了解到我们直到 2012 年没有做任何的 spriting 之后非常震惊。大约数百个图片资源，例如 placeholders, arrows, icons 等等，存在于 /img/ 文件夹中，简直是 icons 坟墓。\n\n为了解决这个问题，我做了两件事情。第一，我写了一个 CSS 工具脚本叫做 SUS（我们现在还在使用它，我将它开源在这里：[https://github.com/medium/sus](https://github.com/medium/sus)）,这个东西大部分是在 Guillermo Rauch 的帮助下用 IRC 编写完成，作用是从样式表中分离出图片，然后在另一个包含 data-uri 的文件中 lazy 加载。这只是一个小工具来帮助我们认识到怎么做。\n\n第二件事情，我和 Geoff Teehan 坐下来，创建了 Medium 的第一个 icon font。当时我们并不清楚具体要怎么做。经过几个漫长的夜晚，在 icomoon 和一个 Github 文章的帮助下，我们产出了一个对 Medium *非常* 好的东西。说它非常好，是因为我们可以删除 img 文件夹中 97% 的文件，每一个图标在我的 retina MacBook Pro 上都显示的非常好，并且只需要请求非常少的资源。\n\n## Project 2: 标准\n对我来说，另外一个大的工程是 z-index 标准。z-index 是个很容易就会失控到让人抓狂的东西。我不想让这种事情也出现在 Medium。 \n\n项目开始之前，很容易看到一个元素 `z-index:5;` 跟在一个 `z-index: 1000000;` 的节点后面，另外一个兄弟节点的样式是 `z-index: 1000001;`，还有一个 `z-index: 99999;`。\n\n在代码库这样的样式中比比皆是，因为并没有明确的方式指明应该怎么做。\n\n我开始了一项在整个代码库中人工审核 z-index 取值的艰巨任务，然后引入了一个可以被 z-indexing 组件使用（限制 1-10）的标准（z-index.less）。最终将所有的 z-index 定义都改用 z-index.less，这样就可以看出不同组件的相对位置了（实际上这是很方便的）。\n\n下面是当前 medium.com 使用的 z-index 文件。\n\n[https://gist.github.com/fat/1f6da6b3bd0311a1f8a0](https://gist.github.com/fat/1f6da6b3bd0311a1f8a0)\n\n当然，color 标准（黑色，灰色，logo 颜色），type 规范（字体大小，字重，字间距，行高）紧随 z-index 之后需要制定。\n\n另外，你可能注意到，变量命名遵循了一定的规范，并且采用了语义化命名，稍后会详细介绍。\n\n## Project 3: 新的样式指引\n\n制定了 Medium 规范后不久，我们开始了一场大的代码重构，代号 “Cocoon”。\n\nCocoon 抛弃了一些 post 模版（Medium 本来包含图片模版，引用模版等，不仅仅包括单个文章的模版），并且使用 post 列表替代了 post “cards”。\n\n我们将这次重构作为重新思考 Medium 并创建一个新的样式指引的机会。\n\n最初由我，Dave Gamache，Dustin Senos，和 Chris Erwin 共同来完成了这项工作。\n\n我们花了一些时间来着实加强我们在 Medium 编写生成环境 CSS/LESS 的想法。主要的更新如下：\n\n- 限制 LESS 的使用，只允许使用 variables 和 mixins (不允许使用 nesting, guards, extend, 等等) ，虽然其它的语言特性 *可以* 非常强大，但是我们发现经验没那么丰富的 LESS 开发者很容易就会陷入麻烦。我们同时选择了纯 CSS 的视觉审美（也包括它提供的一致性）并且想要我们的代码库向着这样的方向发展。\n- Classes 和 IDs 都是小写字母，中划线分割单词－这正是我们在 Bootstrap, Skeleton, Ratchet, 等等定义选择器的方式，我们认为我们在这里也可以这样做。另外一个原因是，这种定义方式遵循了 CSS 语言自身的定义方式，比如：border-radius-top-left。\n- 选择 components 而不是 page 层面的样式－我们希望我们的前端更像是一个库，根据这样的想法，我们将 profile.less 拆分成更加具体的文件，例如：button.less, dialog.less,tooltip.less 等。\n\n以下是完整的样式指引：\n[https://gist.github.com/fat/b27700946c777adacdf4](https://gist.github.com/fat/b27700946c777adacdf4)\n\n这并不完美，但是它理清了一些基础的思路，然后带领我们向着感觉上正确的方向前进。\n\n不幸的是，在样式指引更新之后，人们依然非常纠结，什么时候需要定义组件，什么时候需要定义子组件等等。并且我们偶尔会碰到一些并不很具体的东西，例如 classname：.nav-on-light-background-button 或者 .button-primary-sidebar-over-blur.\n\n现在人们不再使用 page 级别的前缀来定义 class 了（这是很好的），但是它们开始使用中划线间隔拼接很多任意单词，组成 classname。进化的过程如下：.button → .button-primary → .button-primary-dark → .button-primary-dark-container → .button-primary-dark-container-label，真是让人不舒服。\n\n## Project 4: 确定未来\n当时，我开始以成为“世界上最好代码”为目标在 Medium 内部写了 *很多* 的 CSS 代码，但并不是非常清楚最好的 CSS 代码到底是什么样子，但至少明白了当时的方向并不成功。\n\n> 人们编写代码的过程中会感到很困惑，更糟糕的是，他们以为自己写的 CSS 非常好，实际上却不是这样。\n\n所以，我开始四处观察－－了解一些框架，尝试不同的工具和哲学，与朋友沟通，与朋友的朋友沟通，等等。很快，我找到三个为了让我们的 CSS 代码向着正确的方向前进需要解决的问题。\n\n1. 引入新的 CSS variable, mixin, 和 classname 语义来避免过长的 classnames 以及增强可读性。\n2. 从 LESS 转到 Rework 来获得更强的 mixin support 和更佳接近于原生 CSS 的语法。\n3. 引入 CSS 性能（加载时间，fps，layout time 等）工具，使跟踪样式修改和回归更加简单。\n\n## Project 5: 语义\n我想要给我们的代码库一个更加严格的语义化标准。因为对于我们这种大小的团队，我觉得拥有一个可以依靠的规则是更简单的。并且我宁愿让事情变得更复杂一点，尽管这也意味着人们必须在创建新的 classes 的时候要更加留神。不过不惜一切代价，我希望能够避免过长的 classname，或者至少没那么容易出现。\n\n我开始就这个问题，与 Daryl Koopersmith 以及我的好朋友 Nicolas Gallagher 进行了长时间的讨论。\n\nNicolas 跟我的关系很有趣，Nicolas 经常告诉我一些事情，我说他是错的，叫着他的法语名字（Va te faire foutre, enculé），在他身边得瑟几个星期，直到不可避免的意识到他是对的，然后把他的想法划归己有。\n\n这一次也是一样，经过几个漫长的夜晚，我终于完成了一个与 Nicolas 的 SUITCSS 很像的语义化样式。很像，但是又那么 ~一丢丢~ 方面更好。\n\n于是，我开始抄袭 Nicolas 的东西，我扔掉了就的样式指引，然后复制粘贴了他的很大一部分，左改改，右改改。\n\n最终，我产出了我们当前使用的最新的样式指引，你可以在下面完整的阅读它，主要的更新是：\n\n- **.js-** 开头的 class names 代表依赖 javascript 选择器的元素\n- **.u-** 开头的 class name 单独目的的工具类，例如 .u-underline, .u-capitalize, 等等\n- 引入有意义的连字符以及驼峰－－区分 component, descendant components, 和 modifiers 的间隔符。\n- **.is-** 开头的 classes 表示有状态的 classes (经常被 js 切换) 例如 .is-disabled\n- 新的 CSS 变量语义： [property]-[value]—[component]\n- mixing 限制为只用在 polyfills 并且以 **.m-** 开头\n\n[https://gist.github.com/fat/a47b882eb5f84293c4ed](https://gist.github.com/fat/a47b882eb5f84293c4ed)\n\n复制粘贴样式指引是一回事，而重写你的 CSS 又是另一回事。\n\n庆幸的是我可以说服公司这个项目的重要性，然后他们给了 2½ 周的时间让我们重写 Medium.com 的所有 CSS－－如果你一直在关心我们的话，这只是我们[修复 CSS underline 问题](https://medium.com/designing-medium/crafting-link-underlines-on-medium-7c03a9274f9)所花费时间的很小一部分。\n\n也就是说，这次重写不只是宣泄，我们清理了一些比没用的样式，收集并整理了整个网站的实现，将文件拆解成小的子模块。让我惊喜的是，只造成了五次以内的回滚。\n\n当然，重构 CSS 意味着重构我们的模版－－增加更多的封装和严格的语义化。现在我们不再有数以百计使用随机 avatar classes 的一次性 <IMG> 标签，我们使用一个单独的集中式 avatar 模版，模版接受布尔选项，来触发不同的 modifiers 比如大小，样式等等。这让更新样式变的简单，而已实现细节时引入更少的 Bug。\n\n## Project X: 未来？\n毫无疑问，我们比两年之前变的更好了。在 Medium 写 CSS 变的非常愉快，不同经验的开发者们也在促进更加伟大的东西。\n\n大家都说，未来的 CSS 项目必须是关注性能。随着我们不断的完善我们的故事，然后推向下一个阶段，你可以想象怎样精确可靠的测量 layout 和 渲染性能是非常重要的。\n\n所以，还要更多的事情要做，但是我现在感觉我们已经非常好了，比我平时想的都要好。\n\n为你完成了这个冗长又无聊的 post 干杯。\n\n感谢 Katie, Dave, Mark, Koop, Kristofer, Nicolas 以及其它帮助我的人❤。","slug":"mediums-css-is-actually-pretty-fucking-good","published":1,"updated":"2016-12-27T08:12:50.000Z","_id":"cix78b8ku00034as6je67sg9i","comments":1,"photos":[],"link":"","content":"<h1 id=\"Medium-的-CSS-真他-的好\"><a href=\"#Medium-的-CSS-真他-的好\" class=\"headerlink\" title=\"Medium 的 CSS 真他*的好\"></a>Medium 的 CSS 真他*的好</h1><ul>\n<li>翻译自 <a href=\"https://medium.com/@fat/mediums-css-is-actually-pretty-fucking-good-b8e2a6c78b06\" target=\"_blank\" rel=\"external\">Medium by fat</a></li>\n</ul>\n<blockquote>\n<p>I always believe that to be the best, you have to smell like the best, dress like the best, act like the best. When you throw your trash in the garbage can, it has to be better than anybody else who ever threw trash in the garbage can.   </p>\n<p>— Lil Wayne</p>\n</blockquote>\n<p>一段时间以来，我都想要写一些关于 Medium CSS 的东西。关于 Medium 的 CSS 有什么样的故事？我们做了哪些不一样的事情？怎么才能像我们一样做，或者可以从我们这学到点什么？</p>\n<p>以下包括一些 CSS 的记录，包括我们是怎么一步步走过来的，以及现状。</p>\n<a id=\"more\"></a>\n<h2 id=\"开始（一些历史）\"><a href=\"#开始（一些历史）\" class=\"headerlink\" title=\"开始（一些历史）\"></a>开始（一些历史）</h2><p>大概2年前，我加入了 Obvious Corp. 参与 <em>medium.com</em> 的开发工作。</p>\n<p>当时，Medium 已经进行了一系列的 “re-styles” (re-style 就是设计师通过一些比之前漂亮的东西来摧毁你的生活，结果就是，你要重写成吨的 CSS/LESS/SASS/等等)。由于这些 re-styles，代码中出现了非常多令人讨厌的东西 — 非常倚重 LESS 的语言特性，页面驱动的语义，non-sprited/non-retina 的图片资源，等等。</p>\n<p>我翻看 Git 以及其他代码管理工具获取到了 Medium 2012 年的个人资料页面的实现，<em>不寒而栗</em>。下面列出了发现的问题，请注意那些非常不应该的模式：</p>\n<ul>\n<li>所有样式都嵌套在 <code>.profile-page</code> class 下，没有任何重用组件（另外 <em>几乎</em> 所有样式都使用了 <code>.profile</code> 前缀）</li>\n<li>超级通用变量名形如 <code>@link-color</code> 只在 <code>profile-page.less</code> 中被使用，并没有其他用处</li>\n<li>非常深的嵌套（<code>.profile-page .profile-posts .home-post-summary .home-post-collection-image img</code> 是一个真实存在的选择器 - 性能会非常差）</li>\n<li>没有 image spriting</li>\n<li>没有 z-index 标准，没有 font 标准，没有 color 标准，没有 ** 标准</li>\n</ul>\n<p><a href=\"https://gist.github.com/fat/a4af78882d0003d2345e\" target=\"_blank\" rel=\"external\">Old medium profile page</a></p>\n<h2 id=\"Project-1：图片\"><a href=\"#Project-1：图片\" class=\"headerlink\" title=\"Project 1：图片\"></a>Project 1：图片</h2><p>当时，我参与了很多库 (Bootstrap, Ratchet, 等等)的开发工作，仔细处理每一个细节，希望能写出最好的 CSS 代码。</p>\n<p>Medium 的 CSS 代码当然非常不一样，不是简单的不同，而是屎一样的烂。我想解决这个问题。</p>\n<p>了解了所有需要处理的东西之后，我选择了 images 开始下手。我记得在了解到我们直到 2012 年没有做任何的 spriting 之后非常震惊。大约数百个图片资源，例如 placeholders, arrows, icons 等等，存在于 /img/ 文件夹中，简直是 icons 坟墓。</p>\n<p>为了解决这个问题，我做了两件事情。第一，我写了一个 CSS 工具脚本叫做 SUS（我们现在还在使用它，我将它开源在这里：<a href=\"https://github.com/medium/sus\" target=\"_blank\" rel=\"external\">https://github.com/medium/sus</a>）,这个东西大部分是在 Guillermo Rauch 的帮助下用 IRC 编写完成，作用是从样式表中分离出图片，然后在另一个包含 data-uri 的文件中 lazy 加载。这只是一个小工具来帮助我们认识到怎么做。</p>\n<p>第二件事情，我和 Geoff Teehan 坐下来，创建了 Medium 的第一个 icon font。当时我们并不清楚具体要怎么做。经过几个漫长的夜晚，在 icomoon 和一个 Github 文章的帮助下，我们产出了一个对 Medium <em>非常</em> 好的东西。说它非常好，是因为我们可以删除 img 文件夹中 97% 的文件，每一个图标在我的 retina MacBook Pro 上都显示的非常好，并且只需要请求非常少的资源。</p>\n<h2 id=\"Project-2-标准\"><a href=\"#Project-2-标准\" class=\"headerlink\" title=\"Project 2: 标准\"></a>Project 2: 标准</h2><p>对我来说，另外一个大的工程是 z-index 标准。z-index 是个很容易就会失控到让人抓狂的东西。我不想让这种事情也出现在 Medium。 </p>\n<p>项目开始之前，很容易看到一个元素 <code>z-index:5;</code> 跟在一个 <code>z-index: 1000000;</code> 的节点后面，另外一个兄弟节点的样式是 <code>z-index: 1000001;</code>，还有一个 <code>z-index: 99999;</code>。</p>\n<p>在代码库这样的样式中比比皆是，因为并没有明确的方式指明应该怎么做。</p>\n<p>我开始了一项在整个代码库中人工审核 z-index 取值的艰巨任务，然后引入了一个可以被 z-indexing 组件使用（限制 1-10）的标准（z-index.less）。最终将所有的 z-index 定义都改用 z-index.less，这样就可以看出不同组件的相对位置了（实际上这是很方便的）。</p>\n<p>下面是当前 medium.com 使用的 z-index 文件。</p>\n<p><a href=\"https://gist.github.com/fat/1f6da6b3bd0311a1f8a0\" target=\"_blank\" rel=\"external\">https://gist.github.com/fat/1f6da6b3bd0311a1f8a0</a></p>\n<p>当然，color 标准（黑色，灰色，logo 颜色），type 规范（字体大小，字重，字间距，行高）紧随 z-index 之后需要制定。</p>\n<p>另外，你可能注意到，变量命名遵循了一定的规范，并且采用了语义化命名，稍后会详细介绍。</p>\n<h2 id=\"Project-3-新的样式指引\"><a href=\"#Project-3-新的样式指引\" class=\"headerlink\" title=\"Project 3: 新的样式指引\"></a>Project 3: 新的样式指引</h2><p>制定了 Medium 规范后不久，我们开始了一场大的代码重构，代号 “Cocoon”。</p>\n<p>Cocoon 抛弃了一些 post 模版（Medium 本来包含图片模版，引用模版等，不仅仅包括单个文章的模版），并且使用 post 列表替代了 post “cards”。</p>\n<p>我们将这次重构作为重新思考 Medium 并创建一个新的样式指引的机会。</p>\n<p>最初由我，Dave Gamache，Dustin Senos，和 Chris Erwin 共同来完成了这项工作。</p>\n<p>我们花了一些时间来着实加强我们在 Medium 编写生成环境 CSS/LESS 的想法。主要的更新如下：</p>\n<ul>\n<li>限制 LESS 的使用，只允许使用 variables 和 mixins (不允许使用 nesting, guards, extend, 等等) ，虽然其它的语言特性 <em>可以</em> 非常强大，但是我们发现经验没那么丰富的 LESS 开发者很容易就会陷入麻烦。我们同时选择了纯 CSS 的视觉审美（也包括它提供的一致性）并且想要我们的代码库向着这样的方向发展。</li>\n<li>Classes 和 IDs 都是小写字母，中划线分割单词－这正是我们在 Bootstrap, Skeleton, Ratchet, 等等定义选择器的方式，我们认为我们在这里也可以这样做。另外一个原因是，这种定义方式遵循了 CSS 语言自身的定义方式，比如：border-radius-top-left。</li>\n<li>选择 components 而不是 page 层面的样式－我们希望我们的前端更像是一个库，根据这样的想法，我们将 profile.less 拆分成更加具体的文件，例如：button.less, dialog.less,tooltip.less 等。</li>\n</ul>\n<p>以下是完整的样式指引：<br><a href=\"https://gist.github.com/fat/b27700946c777adacdf4\" target=\"_blank\" rel=\"external\">https://gist.github.com/fat/b27700946c777adacdf4</a></p>\n<p>这并不完美，但是它理清了一些基础的思路，然后带领我们向着感觉上正确的方向前进。</p>\n<p>不幸的是，在样式指引更新之后，人们依然非常纠结，什么时候需要定义组件，什么时候需要定义子组件等等。并且我们偶尔会碰到一些并不很具体的东西，例如 classname：.nav-on-light-background-button 或者 .button-primary-sidebar-over-blur.</p>\n<p>现在人们不再使用 page 级别的前缀来定义 class 了（这是很好的），但是它们开始使用中划线间隔拼接很多任意单词，组成 classname。进化的过程如下：.button → .button-primary → .button-primary-dark → .button-primary-dark-container → .button-primary-dark-container-label，真是让人不舒服。</p>\n<h2 id=\"Project-4-确定未来\"><a href=\"#Project-4-确定未来\" class=\"headerlink\" title=\"Project 4: 确定未来\"></a>Project 4: 确定未来</h2><p>当时，我开始以成为“世界上最好代码”为目标在 Medium 内部写了 <em>很多</em> 的 CSS 代码，但并不是非常清楚最好的 CSS 代码到底是什么样子，但至少明白了当时的方向并不成功。</p>\n<blockquote>\n<p>人们编写代码的过程中会感到很困惑，更糟糕的是，他们以为自己写的 CSS 非常好，实际上却不是这样。</p>\n</blockquote>\n<p>所以，我开始四处观察－－了解一些框架，尝试不同的工具和哲学，与朋友沟通，与朋友的朋友沟通，等等。很快，我找到三个为了让我们的 CSS 代码向着正确的方向前进需要解决的问题。</p>\n<ol>\n<li>引入新的 CSS variable, mixin, 和 classname 语义来避免过长的 classnames 以及增强可读性。</li>\n<li>从 LESS 转到 Rework 来获得更强的 mixin support 和更佳接近于原生 CSS 的语法。</li>\n<li>引入 CSS 性能（加载时间，fps，layout time 等）工具，使跟踪样式修改和回归更加简单。</li>\n</ol>\n<h2 id=\"Project-5-语义\"><a href=\"#Project-5-语义\" class=\"headerlink\" title=\"Project 5: 语义\"></a>Project 5: 语义</h2><p>我想要给我们的代码库一个更加严格的语义化标准。因为对于我们这种大小的团队，我觉得拥有一个可以依靠的规则是更简单的。并且我宁愿让事情变得更复杂一点，尽管这也意味着人们必须在创建新的 classes 的时候要更加留神。不过不惜一切代价，我希望能够避免过长的 classname，或者至少没那么容易出现。</p>\n<p>我开始就这个问题，与 Daryl Koopersmith 以及我的好朋友 Nicolas Gallagher 进行了长时间的讨论。</p>\n<p>Nicolas 跟我的关系很有趣，Nicolas 经常告诉我一些事情，我说他是错的，叫着他的法语名字（Va te faire foutre, enculé），在他身边得瑟几个星期，直到不可避免的意识到他是对的，然后把他的想法划归己有。</p>\n<p>这一次也是一样，经过几个漫长的夜晚，我终于完成了一个与 Nicolas 的 SUITCSS 很像的语义化样式。很像，但是又那么 ~一丢丢~ 方面更好。</p>\n<p>于是，我开始抄袭 Nicolas 的东西，我扔掉了就的样式指引，然后复制粘贴了他的很大一部分，左改改，右改改。</p>\n<p>最终，我产出了我们当前使用的最新的样式指引，你可以在下面完整的阅读它，主要的更新是：</p>\n<ul>\n<li><strong>.js-</strong> 开头的 class names 代表依赖 javascript 选择器的元素</li>\n<li><strong>.u-</strong> 开头的 class name 单独目的的工具类，例如 .u-underline, .u-capitalize, 等等</li>\n<li>引入有意义的连字符以及驼峰－－区分 component, descendant components, 和 modifiers 的间隔符。</li>\n<li><strong>.is-</strong> 开头的 classes 表示有状态的 classes (经常被 js 切换) 例如 .is-disabled</li>\n<li>新的 CSS 变量语义： [property]-[value]—[component]</li>\n<li>mixing 限制为只用在 polyfills 并且以 <strong>.m-</strong> 开头</li>\n</ul>\n<p><a href=\"https://gist.github.com/fat/a47b882eb5f84293c4ed\" target=\"_blank\" rel=\"external\">https://gist.github.com/fat/a47b882eb5f84293c4ed</a></p>\n<p>复制粘贴样式指引是一回事，而重写你的 CSS 又是另一回事。</p>\n<p>庆幸的是我可以说服公司这个项目的重要性，然后他们给了 2½ 周的时间让我们重写 Medium.com 的所有 CSS－－如果你一直在关心我们的话，这只是我们<a href=\"https://medium.com/designing-medium/crafting-link-underlines-on-medium-7c03a9274f9\" target=\"_blank\" rel=\"external\">修复 CSS underline 问题</a>所花费时间的很小一部分。</p>\n<p>也就是说，这次重写不只是宣泄，我们清理了一些比没用的样式，收集并整理了整个网站的实现，将文件拆解成小的子模块。让我惊喜的是，只造成了五次以内的回滚。</p>\n<p>当然，重构 CSS 意味着重构我们的模版－－增加更多的封装和严格的语义化。现在我们不再有数以百计使用随机 avatar classes 的一次性 <img> 标签，我们使用一个单独的集中式 avatar 模版，模版接受布尔选项，来触发不同的 modifiers 比如大小，样式等等。这让更新样式变的简单，而已实现细节时引入更少的 Bug。</p>\n<h2 id=\"Project-X-未来？\"><a href=\"#Project-X-未来？\" class=\"headerlink\" title=\"Project X: 未来？\"></a>Project X: 未来？</h2><p>毫无疑问，我们比两年之前变的更好了。在 Medium 写 CSS 变的非常愉快，不同经验的开发者们也在促进更加伟大的东西。</p>\n<p>大家都说，未来的 CSS 项目必须是关注性能。随着我们不断的完善我们的故事，然后推向下一个阶段，你可以想象怎样精确可靠的测量 layout 和 渲染性能是非常重要的。</p>\n<p>所以，还要更多的事情要做，但是我现在感觉我们已经非常好了，比我平时想的都要好。</p>\n<p>为你完成了这个冗长又无聊的 post 干杯。</p>\n<p>感谢 Katie, Dave, Mark, Koop, Kristofer, Nicolas 以及其它帮助我的人❤。</p>\n","excerpt":"<h1 id=\"Medium-的-CSS-真他-的好\"><a href=\"#Medium-的-CSS-真他-的好\" class=\"headerlink\" title=\"Medium 的 CSS 真他*的好\"></a>Medium 的 CSS 真他*的好</h1><ul>\n<li>翻译自 <a href=\"https://medium.com/@fat/mediums-css-is-actually-pretty-fucking-good-b8e2a6c78b06\">Medium by fat</a></li>\n</ul>\n<blockquote>\n<p>I always believe that to be the best, you have to smell like the best, dress like the best, act like the best. When you throw your trash in the garbage can, it has to be better than anybody else who ever threw trash in the garbage can.   </p>\n<p>— Lil Wayne</p>\n</blockquote>\n<p>一段时间以来，我都想要写一些关于 Medium CSS 的东西。关于 Medium 的 CSS 有什么样的故事？我们做了哪些不一样的事情？怎么才能像我们一样做，或者可以从我们这学到点什么？</p>\n<p>以下包括一些 CSS 的记录，包括我们是怎么一步步走过来的，以及现状。</p>","more":"<h2 id=\"开始（一些历史）\"><a href=\"#开始（一些历史）\" class=\"headerlink\" title=\"开始（一些历史）\"></a>开始（一些历史）</h2><p>大概2年前，我加入了 Obvious Corp. 参与 <em>medium.com</em> 的开发工作。</p>\n<p>当时，Medium 已经进行了一系列的 “re-styles” (re-style 就是设计师通过一些比之前漂亮的东西来摧毁你的生活，结果就是，你要重写成吨的 CSS/LESS/SASS/等等)。由于这些 re-styles，代码中出现了非常多令人讨厌的东西 — 非常倚重 LESS 的语言特性，页面驱动的语义，non-sprited/non-retina 的图片资源，等等。</p>\n<p>我翻看 Git 以及其他代码管理工具获取到了 Medium 2012 年的个人资料页面的实现，<em>不寒而栗</em>。下面列出了发现的问题，请注意那些非常不应该的模式：</p>\n<ul>\n<li>所有样式都嵌套在 <code>.profile-page</code> class 下，没有任何重用组件（另外 <em>几乎</em> 所有样式都使用了 <code>.profile</code> 前缀）</li>\n<li>超级通用变量名形如 <code>@link-color</code> 只在 <code>profile-page.less</code> 中被使用，并没有其他用处</li>\n<li>非常深的嵌套（<code>.profile-page .profile-posts .home-post-summary .home-post-collection-image img</code> 是一个真实存在的选择器 - 性能会非常差）</li>\n<li>没有 image spriting</li>\n<li>没有 z-index 标准，没有 font 标准，没有 color 标准，没有 ** 标准</li>\n</ul>\n<p><a href=\"https://gist.github.com/fat/a4af78882d0003d2345e\">Old medium profile page</a></p>\n<h2 id=\"Project-1：图片\"><a href=\"#Project-1：图片\" class=\"headerlink\" title=\"Project 1：图片\"></a>Project 1：图片</h2><p>当时，我参与了很多库 (Bootstrap, Ratchet, 等等)的开发工作，仔细处理每一个细节，希望能写出最好的 CSS 代码。</p>\n<p>Medium 的 CSS 代码当然非常不一样，不是简单的不同，而是屎一样的烂。我想解决这个问题。</p>\n<p>了解了所有需要处理的东西之后，我选择了 images 开始下手。我记得在了解到我们直到 2012 年没有做任何的 spriting 之后非常震惊。大约数百个图片资源，例如 placeholders, arrows, icons 等等，存在于 /img/ 文件夹中，简直是 icons 坟墓。</p>\n<p>为了解决这个问题，我做了两件事情。第一，我写了一个 CSS 工具脚本叫做 SUS（我们现在还在使用它，我将它开源在这里：<a href=\"https://github.com/medium/sus\">https://github.com/medium/sus</a>）,这个东西大部分是在 Guillermo Rauch 的帮助下用 IRC 编写完成，作用是从样式表中分离出图片，然后在另一个包含 data-uri 的文件中 lazy 加载。这只是一个小工具来帮助我们认识到怎么做。</p>\n<p>第二件事情，我和 Geoff Teehan 坐下来，创建了 Medium 的第一个 icon font。当时我们并不清楚具体要怎么做。经过几个漫长的夜晚，在 icomoon 和一个 Github 文章的帮助下，我们产出了一个对 Medium <em>非常</em> 好的东西。说它非常好，是因为我们可以删除 img 文件夹中 97% 的文件，每一个图标在我的 retina MacBook Pro 上都显示的非常好，并且只需要请求非常少的资源。</p>\n<h2 id=\"Project-2-标准\"><a href=\"#Project-2-标准\" class=\"headerlink\" title=\"Project 2: 标准\"></a>Project 2: 标准</h2><p>对我来说，另外一个大的工程是 z-index 标准。z-index 是个很容易就会失控到让人抓狂的东西。我不想让这种事情也出现在 Medium。 </p>\n<p>项目开始之前，很容易看到一个元素 <code>z-index:5;</code> 跟在一个 <code>z-index: 1000000;</code> 的节点后面，另外一个兄弟节点的样式是 <code>z-index: 1000001;</code>，还有一个 <code>z-index: 99999;</code>。</p>\n<p>在代码库这样的样式中比比皆是，因为并没有明确的方式指明应该怎么做。</p>\n<p>我开始了一项在整个代码库中人工审核 z-index 取值的艰巨任务，然后引入了一个可以被 z-indexing 组件使用（限制 1-10）的标准（z-index.less）。最终将所有的 z-index 定义都改用 z-index.less，这样就可以看出不同组件的相对位置了（实际上这是很方便的）。</p>\n<p>下面是当前 medium.com 使用的 z-index 文件。</p>\n<p><a href=\"https://gist.github.com/fat/1f6da6b3bd0311a1f8a0\">https://gist.github.com/fat/1f6da6b3bd0311a1f8a0</a></p>\n<p>当然，color 标准（黑色，灰色，logo 颜色），type 规范（字体大小，字重，字间距，行高）紧随 z-index 之后需要制定。</p>\n<p>另外，你可能注意到，变量命名遵循了一定的规范，并且采用了语义化命名，稍后会详细介绍。</p>\n<h2 id=\"Project-3-新的样式指引\"><a href=\"#Project-3-新的样式指引\" class=\"headerlink\" title=\"Project 3: 新的样式指引\"></a>Project 3: 新的样式指引</h2><p>制定了 Medium 规范后不久，我们开始了一场大的代码重构，代号 “Cocoon”。</p>\n<p>Cocoon 抛弃了一些 post 模版（Medium 本来包含图片模版，引用模版等，不仅仅包括单个文章的模版），并且使用 post 列表替代了 post “cards”。</p>\n<p>我们将这次重构作为重新思考 Medium 并创建一个新的样式指引的机会。</p>\n<p>最初由我，Dave Gamache，Dustin Senos，和 Chris Erwin 共同来完成了这项工作。</p>\n<p>我们花了一些时间来着实加强我们在 Medium 编写生成环境 CSS/LESS 的想法。主要的更新如下：</p>\n<ul>\n<li>限制 LESS 的使用，只允许使用 variables 和 mixins (不允许使用 nesting, guards, extend, 等等) ，虽然其它的语言特性 <em>可以</em> 非常强大，但是我们发现经验没那么丰富的 LESS 开发者很容易就会陷入麻烦。我们同时选择了纯 CSS 的视觉审美（也包括它提供的一致性）并且想要我们的代码库向着这样的方向发展。</li>\n<li>Classes 和 IDs 都是小写字母，中划线分割单词－这正是我们在 Bootstrap, Skeleton, Ratchet, 等等定义选择器的方式，我们认为我们在这里也可以这样做。另外一个原因是，这种定义方式遵循了 CSS 语言自身的定义方式，比如：border-radius-top-left。</li>\n<li>选择 components 而不是 page 层面的样式－我们希望我们的前端更像是一个库，根据这样的想法，我们将 profile.less 拆分成更加具体的文件，例如：button.less, dialog.less,tooltip.less 等。</li>\n</ul>\n<p>以下是完整的样式指引：<br><a href=\"https://gist.github.com/fat/b27700946c777adacdf4\">https://gist.github.com/fat/b27700946c777adacdf4</a></p>\n<p>这并不完美，但是它理清了一些基础的思路，然后带领我们向着感觉上正确的方向前进。</p>\n<p>不幸的是，在样式指引更新之后，人们依然非常纠结，什么时候需要定义组件，什么时候需要定义子组件等等。并且我们偶尔会碰到一些并不很具体的东西，例如 classname：.nav-on-light-background-button 或者 .button-primary-sidebar-over-blur.</p>\n<p>现在人们不再使用 page 级别的前缀来定义 class 了（这是很好的），但是它们开始使用中划线间隔拼接很多任意单词，组成 classname。进化的过程如下：.button → .button-primary → .button-primary-dark → .button-primary-dark-container → .button-primary-dark-container-label，真是让人不舒服。</p>\n<h2 id=\"Project-4-确定未来\"><a href=\"#Project-4-确定未来\" class=\"headerlink\" title=\"Project 4: 确定未来\"></a>Project 4: 确定未来</h2><p>当时，我开始以成为“世界上最好代码”为目标在 Medium 内部写了 <em>很多</em> 的 CSS 代码，但并不是非常清楚最好的 CSS 代码到底是什么样子，但至少明白了当时的方向并不成功。</p>\n<blockquote>\n<p>人们编写代码的过程中会感到很困惑，更糟糕的是，他们以为自己写的 CSS 非常好，实际上却不是这样。</p>\n</blockquote>\n<p>所以，我开始四处观察－－了解一些框架，尝试不同的工具和哲学，与朋友沟通，与朋友的朋友沟通，等等。很快，我找到三个为了让我们的 CSS 代码向着正确的方向前进需要解决的问题。</p>\n<ol>\n<li>引入新的 CSS variable, mixin, 和 classname 语义来避免过长的 classnames 以及增强可读性。</li>\n<li>从 LESS 转到 Rework 来获得更强的 mixin support 和更佳接近于原生 CSS 的语法。</li>\n<li>引入 CSS 性能（加载时间，fps，layout time 等）工具，使跟踪样式修改和回归更加简单。</li>\n</ol>\n<h2 id=\"Project-5-语义\"><a href=\"#Project-5-语义\" class=\"headerlink\" title=\"Project 5: 语义\"></a>Project 5: 语义</h2><p>我想要给我们的代码库一个更加严格的语义化标准。因为对于我们这种大小的团队，我觉得拥有一个可以依靠的规则是更简单的。并且我宁愿让事情变得更复杂一点，尽管这也意味着人们必须在创建新的 classes 的时候要更加留神。不过不惜一切代价，我希望能够避免过长的 classname，或者至少没那么容易出现。</p>\n<p>我开始就这个问题，与 Daryl Koopersmith 以及我的好朋友 Nicolas Gallagher 进行了长时间的讨论。</p>\n<p>Nicolas 跟我的关系很有趣，Nicolas 经常告诉我一些事情，我说他是错的，叫着他的法语名字（Va te faire foutre, enculé），在他身边得瑟几个星期，直到不可避免的意识到他是对的，然后把他的想法划归己有。</p>\n<p>这一次也是一样，经过几个漫长的夜晚，我终于完成了一个与 Nicolas 的 SUITCSS 很像的语义化样式。很像，但是又那么 ~一丢丢~ 方面更好。</p>\n<p>于是，我开始抄袭 Nicolas 的东西，我扔掉了就的样式指引，然后复制粘贴了他的很大一部分，左改改，右改改。</p>\n<p>最终，我产出了我们当前使用的最新的样式指引，你可以在下面完整的阅读它，主要的更新是：</p>\n<ul>\n<li><strong>.js-</strong> 开头的 class names 代表依赖 javascript 选择器的元素</li>\n<li><strong>.u-</strong> 开头的 class name 单独目的的工具类，例如 .u-underline, .u-capitalize, 等等</li>\n<li>引入有意义的连字符以及驼峰－－区分 component, descendant components, 和 modifiers 的间隔符。</li>\n<li><strong>.is-</strong> 开头的 classes 表示有状态的 classes (经常被 js 切换) 例如 .is-disabled</li>\n<li>新的 CSS 变量语义： [property]-[value]—[component]</li>\n<li>mixing 限制为只用在 polyfills 并且以 <strong>.m-</strong> 开头</li>\n</ul>\n<p><a href=\"https://gist.github.com/fat/a47b882eb5f84293c4ed\">https://gist.github.com/fat/a47b882eb5f84293c4ed</a></p>\n<p>复制粘贴样式指引是一回事，而重写你的 CSS 又是另一回事。</p>\n<p>庆幸的是我可以说服公司这个项目的重要性，然后他们给了 2½ 周的时间让我们重写 Medium.com 的所有 CSS－－如果你一直在关心我们的话，这只是我们<a href=\"https://medium.com/designing-medium/crafting-link-underlines-on-medium-7c03a9274f9\">修复 CSS underline 问题</a>所花费时间的很小一部分。</p>\n<p>也就是说，这次重写不只是宣泄，我们清理了一些比没用的样式，收集并整理了整个网站的实现，将文件拆解成小的子模块。让我惊喜的是，只造成了五次以内的回滚。</p>\n<p>当然，重构 CSS 意味着重构我们的模版－－增加更多的封装和严格的语义化。现在我们不再有数以百计使用随机 avatar classes 的一次性 <IMG> 标签，我们使用一个单独的集中式 avatar 模版，模版接受布尔选项，来触发不同的 modifiers 比如大小，样式等等。这让更新样式变的简单，而已实现细节时引入更少的 Bug。</p>\n<h2 id=\"Project-X-未来？\"><a href=\"#Project-X-未来？\" class=\"headerlink\" title=\"Project X: 未来？\"></a>Project X: 未来？</h2><p>毫无疑问，我们比两年之前变的更好了。在 Medium 写 CSS 变的非常愉快，不同经验的开发者们也在促进更加伟大的东西。</p>\n<p>大家都说，未来的 CSS 项目必须是关注性能。随着我们不断的完善我们的故事，然后推向下一个阶段，你可以想象怎样精确可靠的测量 layout 和 渲染性能是非常重要的。</p>\n<p>所以，还要更多的事情要做，但是我现在感觉我们已经非常好了，比我平时想的都要好。</p>\n<p>为你完成了这个冗长又无聊的 post 干杯。</p>\n<p>感谢 Katie, Dave, Mark, Koop, Kristofer, Nicolas 以及其它帮助我的人❤。</p>"},{"layout":"post","title":"Medium LESS 编码指引","date":"2015-07-30T08:27:49.000Z","_content":"\n# Medium LESS 编码指引\n\nMedium 使用 [LESS](http://lesscss.org/) 的一个严格子集来进行 CSS 预处理。严格子集只包括变量和 mixin，不包含任何其它内容（嵌套等）。\n\nMedium 的命名约定改编自 SUIT CSS 框架。具体的说，它依赖于 _结构化的类名_ 和 _有意义的分隔符_ （分隔符不仅仅用来分隔单词）来约定命名。这样的设计可以帮助拟补当前给 DOM 设置 CSS 的不足（例如，缺少样式封装），同时可以改善不同 class 之间的联系。\n\n<!-- more -->\n\n**Table of contents**\n\n- [JavaScript](#javascript)\n- [Utilities](#utilities)\n    - [u-utilityName](#u-utilityName)\n- [Components](#components)\n    - [componentName](#componentName)\n    - [componentName--modifierName](#componentName--modifierName)\n    - [componentName-descendantName](#componentName-descendantName)\n    - [componentName.is-stateOfComponent](#is-stateOfComponent)\n- [Variables](#variables)\n    - [colors](#colors)\n    - [z-index](#zindex)\n    - [font-weight](#fontweight)\n    - [line-height](#lineheight)\n    - [letter-spacing](#letterspacing)\n- [Polyfills](#polyfills)\n- [Formatting](#formatting)\n    - [Spacing](#spacing)\n    - [Quotes](#quotes)\n- [Performance](#performance)\n    - [Specificity](#specificity)\n\n<a name=\"javascript\"></a>\n\n## JavaScript\n\n语法: `js-<targetName>`\n\nJavaScript 特有的 classes 可以减少改变组件的结构或者样式时不经意间影响关联的 JavaScript 行为的风险。它只是个工具，并不是所有情况下都必要。如果你需要创建一个并不会对它添加样式，而只是 JavaScript 中的一个选择器的 class，你就应该添加 `js-` 前缀。实际使用，会像下面这样：\n\n``` html\n<a href=\"/login\" class=\"ban ban-primary js-login\"></a>\n```\n\n**再次强调，JavaScript 特有的 classes 在任何情况下，都不应该被设置样式。**\n\n<a name=\"utilities\"></a>\n\n## Utilities\n\nMedium 的工具 classes 包括一些低层次的结构和位置。工具类可以直接作用到任意的元素上；多个工具类可以同时使用；并且工具类可以和组件类同事使用。\n\n工具类的存在是因为特定的 CSS 属性和模式很常用。比如：浮动，内容浮动，垂直居中，文本截断等。通过工具类可以去重并且提供一致的实现。它们同时充当一个功能性（比如： non-polypill） mixin 的替代品。\n\n\n``` html\n<div class=\"u-clearfix\">\n  <p class=\"u-textTruncate\">{$text}</p>\n  <img class=\"u-pullLeft\" src=\"{$src}\" alt=\"\">\n  <img class=\"u-pullLeft\" src=\"{$src}\" alt=\"\">\n  <img class=\"u-pullLeft\" src=\"{$src}\" alt=\"\">\n</div>\n```\n\n<a name=\"u-utilityName\"></a>\n\n### u-utilityName\n\n语法: `u-<utilityName>`\n\n工具类必须使用驼峰式命名法，使用 `u` 作为命名空间前缀。以下展示一个示例，怎样在一个组件中，使用不同的工具类建立一个简单的结构。\n\n``` html\n<div class=\"u-clearfix\">\n  <a class=\"u-pullLeft\" href=\"{$url}\">\n    <img class=\"u-block\" src=\"{$src}\" alt=\"\">\n  </a>\n  <p class=\"u-sizeFill u-textBreak\">\n    …\n  </p>\n</div>\n```\n\n<a name=\"components\"></a>\n\n## Components 组件\n\n语法: `<componentName>[--modifierName|-descendantName]`\n\n组件驱动开发为阅读和编写 HTML CSS 代码提供了很多好处：\n\n- 帮助区分组件 root 节点，子节点，以及修改器的 class。\n- 保持底层选择器的唯一性\n- 帮助从文档语义中分离展现语义\n\n你可以认为组件是一个封装了语义，样式和行为的特殊元素。\n\n\n<a name=\"componentName\"></a>\n\n### ComponentName\n\n组件名称必须使用驼峰式命名法。\n\n``` css\n.myComponent { /* … */ }\n```\n\n``` html\n<article class=\"myComponent\">\n  …\n</article>\n```\n\n<a name=\"componentName--modifierName\"></a>\n\n### componentName--modifierName\n\n组件修改器的作用是在某些方面修改基础组件的展现。修改器必须使用驼峰式命名法，并且使用两个分隔符与组件名称分割。修改器 class 必须在组件 class _之外_ 被添加到 HTML 中。\n\n``` css\n/* Core button */\n.btn { /* … */ }\n/* Default button style */\n.btn--default { /* … */ }\n```\n\n``` html\n<button class=\"ban btn--primary\">…</button>\n```\n\n<a name=\"componentName-descendantName\"></a>\n\n### componentName-descendantName\n\n一个组件后代是一个附加到一个组件子元素上的 class。它负责给特定组件的子元素提供展现。组件后代必须以驼峰式命名法命名。\n\n``` html\n<article class=\"tweet\">\n  <header class=\"tweet-header\">\n    <img class=\"tweet-avatar\" src=\"{$src}\" alt=\"{$alt}\">\n    …\n  </header>\n  <div class=\"tweet-body\">\n    …\n  </div>\n</article>\n```\n\n<a name=\"is-stateOfComponent\"></a>\n\n### componentName.is-stateOfComponent\n\n使用 `is-stateName` 来给状态相关的组件修改器命名。状态名称必须使用驼峰式命名法。**永远不要直接给这些 class 定义样式；它们应该始终被当作辅助 class 使用。**\n\nJS 可以添加/删除这些 classes。这意味着相同的状态名称可以在不同的上下文同时使用，但是每个组件必须给状态定义自己的样式。\n\n``` css\n.tweet { /* … */ }\n.tweet.is-expanded { /* … */ }\n```\n\n``` html\n<article class=\"tweet is-expanded\">\n  …\n</article>\n```\n\n\n\n<a name=\"variables\"></a>\n\n## Variables 变量\n\n语法: `<property>-<value>[—componentName]`\n\n我们的 CSS 中变量名也是严格限制格式的。这种语法为属性，使用和组件中提供了强关联。\n\n下面的变量定义是一个颜色属性，使用 grayLight 颜色，使用到 highlightMenu 组件中。\n\n``` CSS\n@color-grayLight—highlightMenu: rgb(51, 51, 50);\n```\n\n<a name=\"colors\"></a>\n\n### Colors\n\n当实现样式属性值时，你只可以使用 colors.less 提供的颜色变量。\n\n向 colors.less 中添加颜色变量时，优先使用 RGB 和 RGBA，而不是 hex，名称，HSL 或者 HSLA。\n\n**Right:**\n\n``` css\nrgb(50, 50, 50);\nrgba(50, 50, 50, 0.2);\n```\n\n**Wrong:**\n\n``` css\n#FFF;\n#FFFFFF;\nwhite;\nhsl(120, 100%, 50%);\nhsla(120, 100%, 50%, 1);\n```\n\n<a name=\"index\"></a>\n\n### z-index scale\n\n请使用 z-index.less 文件中限制的 z-index 取值。\n\n`@zIndex-1 - @zIndex-9` 可供选择。不应该有取值超过 `@zIndex-9`。\n\n\n\n<a name=\"font weight\"></a>\n\n### Font Weight\n\n由于 web fonts 的支持，`font-weight` 的角色比原来更加重要了。不像原来 `bold` 是个可以加粗文字的算法，现在不同的字重会渲染对应的不同文字。当然，使用 `font-weight` 的数值取值可以强化文本的展现。下面是一些指引。\n\n直接定义字重应该被避免，使用合适的字体变量：`.font-sansI7, .font-sansN7, 等等`\n\n后缀定义了字重和样式：\n\n``` CSS\nN = normal\nI = italic\n4 = normal font-weight\n7 = bold font-weight\n```\n\n查看 type.less 来定义 type size, letter-spacing 和 line height。\n\nRaw sizes, spaces, and line heights 取值应该从 type.less 中选择。\n\n\n\n``` CSS\nex:\n\n@fontSize-micro\n@fontSize-smallest\n@fontSize-smaller\n@fontSize-small\n@fontSize-base\n@fontSize-large\n@fontSize-larger\n@fontSize-largest\n@fontSize-jumbo\n```\n\nSee [Mozilla Developer Network — font-weight](https://developer.mozilla.org/en/CSS/font-weight) for further reading.\n\n\n\n<a name=\"line height\"></a>\n\n### Line Height\n\nType.less 同时提供了行高标尺。它应该被用于块状文本。\n\n``` CSS\nex:\n\n@lineHeight-tightest\n@lineHeight-tighter\n@lineHeight-tight\n@lineHeight-baseSans\n@lineHeight-base\n@lineHeight-loose\n@lineHeight-looser\n```\n\nAlternatively, when using line height to vertically center a single line of text, be sure to set the line height to the height of the container - 1.\n\n``` CSS\n.btn {\n  height: 50px;\n  line-height: 49px;\n}\n```\n\n<a name=\"letterspacing\"></a>\n\n### Letter spacing\n\n文本间距同样需要从以下变量标尺中选择。\n\n``` CSS\n@letterSpacing-tightest\n@letterSpacing-tighter\n@letterSpacing-tight\n@letterSpacing-normal\n@letterSpacing-loose\n@letterSpacing-looser\n​````\n\n<a name=\"polyfills\"></a>\n## Polyfills\n\nmixin syntax: `m-<propertyName>`\n\n在 Medium 我们只使用 mixin 来生成浏览器前缀 polyfills。\n\nborder radius mixin 示例:\n\n​```css\n.m-borderRadius(@radius) {\n  -webkit-border-radius: @radius;\n     -moz-border-radius: @radius;\n          border-radius: @radius;\n}\n```\n\n\n\n<a name=\"formatting\"></a>\n\n## Formatting\n\n以下是高层次页面构建样式规则。\n\n<a name=\"spacing\"></a>\n\n### Spacing\n\nCSS 规则需要逗号分割并另起一行：\n\n**Right:**\n\n``` css\n.content,\n.content-edit {\n  …\n}\n```\n\n**Wrong:**\n\n``` css\n.content, .content-edit {\n  …\n}\n```\n\nCSS 块需要间隔一行，不可以是两行也不可不隔行。\n\n**Right:**\n\n``` css\n.content {\n  …\n}\n.content-edit {\n  …\n}\n```\n\n**Wrong:**\n\n``` css\n.content {\n  …\n}\n\n.content-edit {\n  …\n}\n```\n\n\n\n<a name=\"quotes\"></a>\n\n### Quotes\n\n引号在 CSS 和 LESS 是可选的。我们使用双引号让视觉上更清楚的区分字符串和选择器或者样式属性。\n\n**Right:**\n\n``` css\nbackground-image: url(\"/img/you.jpg\");\nfont-family: \"Helvetica Neue Light\", \"Helvetica Neue\", Helvetica, Arial;\n```\n\n**Wrong:**\n\n``` css\nbackground-image: url(/img/you.jpg);\nfont-family: Helvetica Neue Light, Helvetica Neue, Helvetica, Arial;\n```\n\n<a name=\"performance\"></a>\n\n## Performance\n\n<a name=\"specificity\"></a>\n\n### Specificity\n\n虽然层叠式存在与名字（层递式样式表）中，它带来了非不要的性能问题。参照以下示例：\n\n``` css\nul.user-list li span a:hover { color: red; }\n```\n\n样式在页面渲染 layout 的过程中解析。选择器自右向左解析，在选择器无法适配时退出。因此，在上面的示例中，每一个 a 标签都会被检查是不是处在一个 span 和 li 中。就像想象中的一样，这需要一系列的 DOM 遍历，对于大型文档来说可以带来显著的 layout 耗时增加。访问 [https://developers.google.com/speed/docs/best-practices/rendering#UseEfficientCSSSelectors](https://developers.google.com/speed/docs/best-practices/rendering#UseEfficientCSSSelectors) 查看更多信息。\n\n如果只是想在 `.user-list` 下的所有 `a` 元素 hover 时变红，可以将样式简化为：\n\n``` css\n.user-list > a:hover {\n  color: red;\n}\n```\n\n如果你只想给予 `.user-list` 下的部分 `a` 元素一些样式，可以给它们一个特定的 class：\n\n``` css\n.user-list > .link-primary:hover {\n  color: red;\n}\n```\n","source":"_posts/2015-07-30-medium-style-guide.md","raw":"---\nlayout: post\ncategory : front-end\ntitle: Medium LESS 编码指引\ndate: 2015-07-30 16:27:49\ntags : [Medium, CSS]\n---\n\n# Medium LESS 编码指引\n\nMedium 使用 [LESS](http://lesscss.org/) 的一个严格子集来进行 CSS 预处理。严格子集只包括变量和 mixin，不包含任何其它内容（嵌套等）。\n\nMedium 的命名约定改编自 SUIT CSS 框架。具体的说，它依赖于 _结构化的类名_ 和 _有意义的分隔符_ （分隔符不仅仅用来分隔单词）来约定命名。这样的设计可以帮助拟补当前给 DOM 设置 CSS 的不足（例如，缺少样式封装），同时可以改善不同 class 之间的联系。\n\n<!-- more -->\n\n**Table of contents**\n\n- [JavaScript](#javascript)\n- [Utilities](#utilities)\n    - [u-utilityName](#u-utilityName)\n- [Components](#components)\n    - [componentName](#componentName)\n    - [componentName--modifierName](#componentName--modifierName)\n    - [componentName-descendantName](#componentName-descendantName)\n    - [componentName.is-stateOfComponent](#is-stateOfComponent)\n- [Variables](#variables)\n    - [colors](#colors)\n    - [z-index](#zindex)\n    - [font-weight](#fontweight)\n    - [line-height](#lineheight)\n    - [letter-spacing](#letterspacing)\n- [Polyfills](#polyfills)\n- [Formatting](#formatting)\n    - [Spacing](#spacing)\n    - [Quotes](#quotes)\n- [Performance](#performance)\n    - [Specificity](#specificity)\n\n<a name=\"javascript\"></a>\n\n## JavaScript\n\n语法: `js-<targetName>`\n\nJavaScript 特有的 classes 可以减少改变组件的结构或者样式时不经意间影响关联的 JavaScript 行为的风险。它只是个工具，并不是所有情况下都必要。如果你需要创建一个并不会对它添加样式，而只是 JavaScript 中的一个选择器的 class，你就应该添加 `js-` 前缀。实际使用，会像下面这样：\n\n``` html\n<a href=\"/login\" class=\"ban ban-primary js-login\"></a>\n```\n\n**再次强调，JavaScript 特有的 classes 在任何情况下，都不应该被设置样式。**\n\n<a name=\"utilities\"></a>\n\n## Utilities\n\nMedium 的工具 classes 包括一些低层次的结构和位置。工具类可以直接作用到任意的元素上；多个工具类可以同时使用；并且工具类可以和组件类同事使用。\n\n工具类的存在是因为特定的 CSS 属性和模式很常用。比如：浮动，内容浮动，垂直居中，文本截断等。通过工具类可以去重并且提供一致的实现。它们同时充当一个功能性（比如： non-polypill） mixin 的替代品。\n\n\n``` html\n<div class=\"u-clearfix\">\n  <p class=\"u-textTruncate\">{$text}</p>\n  <img class=\"u-pullLeft\" src=\"{$src}\" alt=\"\">\n  <img class=\"u-pullLeft\" src=\"{$src}\" alt=\"\">\n  <img class=\"u-pullLeft\" src=\"{$src}\" alt=\"\">\n</div>\n```\n\n<a name=\"u-utilityName\"></a>\n\n### u-utilityName\n\n语法: `u-<utilityName>`\n\n工具类必须使用驼峰式命名法，使用 `u` 作为命名空间前缀。以下展示一个示例，怎样在一个组件中，使用不同的工具类建立一个简单的结构。\n\n``` html\n<div class=\"u-clearfix\">\n  <a class=\"u-pullLeft\" href=\"{$url}\">\n    <img class=\"u-block\" src=\"{$src}\" alt=\"\">\n  </a>\n  <p class=\"u-sizeFill u-textBreak\">\n    …\n  </p>\n</div>\n```\n\n<a name=\"components\"></a>\n\n## Components 组件\n\n语法: `<componentName>[--modifierName|-descendantName]`\n\n组件驱动开发为阅读和编写 HTML CSS 代码提供了很多好处：\n\n- 帮助区分组件 root 节点，子节点，以及修改器的 class。\n- 保持底层选择器的唯一性\n- 帮助从文档语义中分离展现语义\n\n你可以认为组件是一个封装了语义，样式和行为的特殊元素。\n\n\n<a name=\"componentName\"></a>\n\n### ComponentName\n\n组件名称必须使用驼峰式命名法。\n\n``` css\n.myComponent { /* … */ }\n```\n\n``` html\n<article class=\"myComponent\">\n  …\n</article>\n```\n\n<a name=\"componentName--modifierName\"></a>\n\n### componentName--modifierName\n\n组件修改器的作用是在某些方面修改基础组件的展现。修改器必须使用驼峰式命名法，并且使用两个分隔符与组件名称分割。修改器 class 必须在组件 class _之外_ 被添加到 HTML 中。\n\n``` css\n/* Core button */\n.btn { /* … */ }\n/* Default button style */\n.btn--default { /* … */ }\n```\n\n``` html\n<button class=\"ban btn--primary\">…</button>\n```\n\n<a name=\"componentName-descendantName\"></a>\n\n### componentName-descendantName\n\n一个组件后代是一个附加到一个组件子元素上的 class。它负责给特定组件的子元素提供展现。组件后代必须以驼峰式命名法命名。\n\n``` html\n<article class=\"tweet\">\n  <header class=\"tweet-header\">\n    <img class=\"tweet-avatar\" src=\"{$src}\" alt=\"{$alt}\">\n    …\n  </header>\n  <div class=\"tweet-body\">\n    …\n  </div>\n</article>\n```\n\n<a name=\"is-stateOfComponent\"></a>\n\n### componentName.is-stateOfComponent\n\n使用 `is-stateName` 来给状态相关的组件修改器命名。状态名称必须使用驼峰式命名法。**永远不要直接给这些 class 定义样式；它们应该始终被当作辅助 class 使用。**\n\nJS 可以添加/删除这些 classes。这意味着相同的状态名称可以在不同的上下文同时使用，但是每个组件必须给状态定义自己的样式。\n\n``` css\n.tweet { /* … */ }\n.tweet.is-expanded { /* … */ }\n```\n\n``` html\n<article class=\"tweet is-expanded\">\n  …\n</article>\n```\n\n\n\n<a name=\"variables\"></a>\n\n## Variables 变量\n\n语法: `<property>-<value>[—componentName]`\n\n我们的 CSS 中变量名也是严格限制格式的。这种语法为属性，使用和组件中提供了强关联。\n\n下面的变量定义是一个颜色属性，使用 grayLight 颜色，使用到 highlightMenu 组件中。\n\n``` CSS\n@color-grayLight—highlightMenu: rgb(51, 51, 50);\n```\n\n<a name=\"colors\"></a>\n\n### Colors\n\n当实现样式属性值时，你只可以使用 colors.less 提供的颜色变量。\n\n向 colors.less 中添加颜色变量时，优先使用 RGB 和 RGBA，而不是 hex，名称，HSL 或者 HSLA。\n\n**Right:**\n\n``` css\nrgb(50, 50, 50);\nrgba(50, 50, 50, 0.2);\n```\n\n**Wrong:**\n\n``` css\n#FFF;\n#FFFFFF;\nwhite;\nhsl(120, 100%, 50%);\nhsla(120, 100%, 50%, 1);\n```\n\n<a name=\"index\"></a>\n\n### z-index scale\n\n请使用 z-index.less 文件中限制的 z-index 取值。\n\n`@zIndex-1 - @zIndex-9` 可供选择。不应该有取值超过 `@zIndex-9`。\n\n\n\n<a name=\"font weight\"></a>\n\n### Font Weight\n\n由于 web fonts 的支持，`font-weight` 的角色比原来更加重要了。不像原来 `bold` 是个可以加粗文字的算法，现在不同的字重会渲染对应的不同文字。当然，使用 `font-weight` 的数值取值可以强化文本的展现。下面是一些指引。\n\n直接定义字重应该被避免，使用合适的字体变量：`.font-sansI7, .font-sansN7, 等等`\n\n后缀定义了字重和样式：\n\n``` CSS\nN = normal\nI = italic\n4 = normal font-weight\n7 = bold font-weight\n```\n\n查看 type.less 来定义 type size, letter-spacing 和 line height。\n\nRaw sizes, spaces, and line heights 取值应该从 type.less 中选择。\n\n\n\n``` CSS\nex:\n\n@fontSize-micro\n@fontSize-smallest\n@fontSize-smaller\n@fontSize-small\n@fontSize-base\n@fontSize-large\n@fontSize-larger\n@fontSize-largest\n@fontSize-jumbo\n```\n\nSee [Mozilla Developer Network — font-weight](https://developer.mozilla.org/en/CSS/font-weight) for further reading.\n\n\n\n<a name=\"line height\"></a>\n\n### Line Height\n\nType.less 同时提供了行高标尺。它应该被用于块状文本。\n\n``` CSS\nex:\n\n@lineHeight-tightest\n@lineHeight-tighter\n@lineHeight-tight\n@lineHeight-baseSans\n@lineHeight-base\n@lineHeight-loose\n@lineHeight-looser\n```\n\nAlternatively, when using line height to vertically center a single line of text, be sure to set the line height to the height of the container - 1.\n\n``` CSS\n.btn {\n  height: 50px;\n  line-height: 49px;\n}\n```\n\n<a name=\"letterspacing\"></a>\n\n### Letter spacing\n\n文本间距同样需要从以下变量标尺中选择。\n\n``` CSS\n@letterSpacing-tightest\n@letterSpacing-tighter\n@letterSpacing-tight\n@letterSpacing-normal\n@letterSpacing-loose\n@letterSpacing-looser\n​````\n\n<a name=\"polyfills\"></a>\n## Polyfills\n\nmixin syntax: `m-<propertyName>`\n\n在 Medium 我们只使用 mixin 来生成浏览器前缀 polyfills。\n\nborder radius mixin 示例:\n\n​```css\n.m-borderRadius(@radius) {\n  -webkit-border-radius: @radius;\n     -moz-border-radius: @radius;\n          border-radius: @radius;\n}\n```\n\n\n\n<a name=\"formatting\"></a>\n\n## Formatting\n\n以下是高层次页面构建样式规则。\n\n<a name=\"spacing\"></a>\n\n### Spacing\n\nCSS 规则需要逗号分割并另起一行：\n\n**Right:**\n\n``` css\n.content,\n.content-edit {\n  …\n}\n```\n\n**Wrong:**\n\n``` css\n.content, .content-edit {\n  …\n}\n```\n\nCSS 块需要间隔一行，不可以是两行也不可不隔行。\n\n**Right:**\n\n``` css\n.content {\n  …\n}\n.content-edit {\n  …\n}\n```\n\n**Wrong:**\n\n``` css\n.content {\n  …\n}\n\n.content-edit {\n  …\n}\n```\n\n\n\n<a name=\"quotes\"></a>\n\n### Quotes\n\n引号在 CSS 和 LESS 是可选的。我们使用双引号让视觉上更清楚的区分字符串和选择器或者样式属性。\n\n**Right:**\n\n``` css\nbackground-image: url(\"/img/you.jpg\");\nfont-family: \"Helvetica Neue Light\", \"Helvetica Neue\", Helvetica, Arial;\n```\n\n**Wrong:**\n\n``` css\nbackground-image: url(/img/you.jpg);\nfont-family: Helvetica Neue Light, Helvetica Neue, Helvetica, Arial;\n```\n\n<a name=\"performance\"></a>\n\n## Performance\n\n<a name=\"specificity\"></a>\n\n### Specificity\n\n虽然层叠式存在与名字（层递式样式表）中，它带来了非不要的性能问题。参照以下示例：\n\n``` css\nul.user-list li span a:hover { color: red; }\n```\n\n样式在页面渲染 layout 的过程中解析。选择器自右向左解析，在选择器无法适配时退出。因此，在上面的示例中，每一个 a 标签都会被检查是不是处在一个 span 和 li 中。就像想象中的一样，这需要一系列的 DOM 遍历，对于大型文档来说可以带来显著的 layout 耗时增加。访问 [https://developers.google.com/speed/docs/best-practices/rendering#UseEfficientCSSSelectors](https://developers.google.com/speed/docs/best-practices/rendering#UseEfficientCSSSelectors) 查看更多信息。\n\n如果只是想在 `.user-list` 下的所有 `a` 元素 hover 时变红，可以将样式简化为：\n\n``` css\n.user-list > a:hover {\n  color: red;\n}\n```\n\n如果你只想给予 `.user-list` 下的部分 `a` 元素一些样式，可以给它们一个特定的 class：\n\n``` css\n.user-list > .link-primary:hover {\n  color: red;\n}\n```\n","slug":"medium-style-guide","published":1,"updated":"2016-12-27T08:11:58.000Z","_id":"cix78b8ky00044as6g4ln466y","comments":1,"photos":[],"link":"","content":"<h1 id=\"Medium-LESS-编码指引\"><a href=\"#Medium-LESS-编码指引\" class=\"headerlink\" title=\"Medium LESS 编码指引\"></a>Medium LESS 编码指引</h1><p>Medium 使用 <a href=\"http://lesscss.org/\" target=\"_blank\" rel=\"external\">LESS</a> 的一个严格子集来进行 CSS 预处理。严格子集只包括变量和 mixin，不包含任何其它内容（嵌套等）。</p>\n<p>Medium 的命名约定改编自 SUIT CSS 框架。具体的说，它依赖于 <em>结构化的类名</em> 和 <em>有意义的分隔符</em> （分隔符不仅仅用来分隔单词）来约定命名。这样的设计可以帮助拟补当前给 DOM 设置 CSS 的不足（例如，缺少样式封装），同时可以改善不同 class 之间的联系。</p>\n<a id=\"more\"></a>\n<p><strong>Table of contents</strong></p>\n<ul>\n<li><a href=\"#javascript\">JavaScript</a></li>\n<li><a href=\"#utilities\">Utilities</a><ul>\n<li><a href=\"#u-utilityName\">u-utilityName</a></li>\n</ul>\n</li>\n<li><a href=\"#components\">Components</a><ul>\n<li><a href=\"#componentName\">componentName</a></li>\n<li><a href=\"#componentName--modifierName\">componentName–modifierName</a></li>\n<li><a href=\"#componentName-descendantName\">componentName-descendantName</a></li>\n<li><a href=\"#is-stateOfComponent\">componentName.is-stateOfComponent</a></li>\n</ul>\n</li>\n<li><a href=\"#variables\">Variables</a><ul>\n<li><a href=\"#colors\">colors</a></li>\n<li><a href=\"#zindex\">z-index</a></li>\n<li><a href=\"#fontweight\">font-weight</a></li>\n<li><a href=\"#lineheight\">line-height</a></li>\n<li><a href=\"#letterspacing\">letter-spacing</a></li>\n</ul>\n</li>\n<li><a href=\"#polyfills\">Polyfills</a></li>\n<li><a href=\"#formatting\">Formatting</a><ul>\n<li><a href=\"#spacing\">Spacing</a></li>\n<li><a href=\"#quotes\">Quotes</a></li>\n</ul>\n</li>\n<li><a href=\"#performance\">Performance</a><ul>\n<li><a href=\"#specificity\">Specificity</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"javascript\"></a></p>\n<h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h2><p>语法: <code>js-&lt;targetName&gt;</code></p>\n<p>JavaScript 特有的 classes 可以减少改变组件的结构或者样式时不经意间影响关联的 JavaScript 行为的风险。它只是个工具，并不是所有情况下都必要。如果你需要创建一个并不会对它添加样式，而只是 JavaScript 中的一个选择器的 class，你就应该添加 <code>js-</code> 前缀。实际使用，会像下面这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/login\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"ban ban-primary js-login\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>再次强调，JavaScript 特有的 classes 在任何情况下，都不应该被设置样式。</strong></p>\n<p><a name=\"utilities\"></a></p>\n<h2 id=\"Utilities\"><a href=\"#Utilities\" class=\"headerlink\" title=\"Utilities\"></a>Utilities</h2><p>Medium 的工具 classes 包括一些低层次的结构和位置。工具类可以直接作用到任意的元素上；多个工具类可以同时使用；并且工具类可以和组件类同事使用。</p>\n<p>工具类的存在是因为特定的 CSS 属性和模式很常用。比如：浮动，内容浮动，垂直居中，文本截断等。通过工具类可以去重并且提供一致的实现。它们同时充当一个功能性（比如： non-polypill） mixin 的替代品。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"u-clearfix\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"u-textTruncate\"</span>&gt;</span>&#123;$text&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">class</span>=<span class=\"string\">\"u-pullLeft\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&#123;$src&#125;\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">class</span>=<span class=\"string\">\"u-pullLeft\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&#123;$src&#125;\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">class</span>=<span class=\"string\">\"u-pullLeft\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&#123;$src&#125;\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><a name=\"u-utilityName\"></a></p>\n<h3 id=\"u-utilityName\"><a href=\"#u-utilityName\" class=\"headerlink\" title=\"u-utilityName\"></a>u-utilityName</h3><p>语法: <code>u-&lt;utilityName&gt;</code></p>\n<p>工具类必须使用驼峰式命名法，使用 <code>u</code> 作为命名空间前缀。以下展示一个示例，怎样在一个组件中，使用不同的工具类建立一个简单的结构。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"u-clearfix\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">class</span>=<span class=\"string\">\"u-pullLeft\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"&#123;$url&#125;\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">class</span>=<span class=\"string\">\"u-block\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&#123;$src&#125;\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"u-sizeFill u-textBreak\"</span>&gt;</span></div><div class=\"line\">    …</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><a name=\"components\"></a></p>\n<h2 id=\"Components-组件\"><a href=\"#Components-组件\" class=\"headerlink\" title=\"Components 组件\"></a>Components 组件</h2><p>语法: <code>&lt;componentName&gt;[--modifierName|-descendantName]</code></p>\n<p>组件驱动开发为阅读和编写 HTML CSS 代码提供了很多好处：</p>\n<ul>\n<li>帮助区分组件 root 节点，子节点，以及修改器的 class。</li>\n<li>保持底层选择器的唯一性</li>\n<li>帮助从文档语义中分离展现语义</li>\n</ul>\n<p>你可以认为组件是一个封装了语义，样式和行为的特殊元素。</p>\n<p><a name=\"componentName\"></a></p>\n<h3 id=\"ComponentName\"><a href=\"#ComponentName\" class=\"headerlink\" title=\"ComponentName\"></a>ComponentName</h3><p>组件名称必须使用驼峰式命名法。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.myComponent</span> &#123; <span class=\"comment\">/* … */</span> &#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">article</span> <span class=\"attr\">class</span>=<span class=\"string\">\"myComponent\"</span>&gt;</span></div><div class=\"line\">  …</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">article</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><a name=\"componentName--modifierName\"></a></p>\n<h3 id=\"componentName–modifierName\"><a href=\"#componentName–modifierName\" class=\"headerlink\" title=\"componentName–modifierName\"></a>componentName–modifierName</h3><p>组件修改器的作用是在某些方面修改基础组件的展现。修改器必须使用驼峰式命名法，并且使用两个分隔符与组件名称分割。修改器 class 必须在组件 class <em>之外</em> 被添加到 HTML 中。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* Core button */</span></div><div class=\"line\"><span class=\"selector-class\">.btn</span> &#123; <span class=\"comment\">/* … */</span> &#125;</div><div class=\"line\"><span class=\"comment\">/* Default button style */</span></div><div class=\"line\"><span class=\"selector-class\">.btn--default</span> &#123; <span class=\"comment\">/* … */</span> &#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"ban btn--primary\"</span>&gt;</span>…<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><a name=\"componentName-descendantName\"></a></p>\n<h3 id=\"componentName-descendantName\"><a href=\"#componentName-descendantName\" class=\"headerlink\" title=\"componentName-descendantName\"></a>componentName-descendantName</h3><p>一个组件后代是一个附加到一个组件子元素上的 class。它负责给特定组件的子元素提供展现。组件后代必须以驼峰式命名法命名。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">article</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tweet\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">header</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tweet-header\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tweet-avatar\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&#123;$src&#125;\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"&#123;$alt&#125;\"</span>&gt;</span></div><div class=\"line\">    …</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tweet-body\"</span>&gt;</span></div><div class=\"line\">    …</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">article</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><a name=\"is-stateOfComponent\"></a></p>\n<h3 id=\"componentName-is-stateOfComponent\"><a href=\"#componentName-is-stateOfComponent\" class=\"headerlink\" title=\"componentName.is-stateOfComponent\"></a>componentName.is-stateOfComponent</h3><p>使用 <code>is-stateName</code> 来给状态相关的组件修改器命名。状态名称必须使用驼峰式命名法。<strong>永远不要直接给这些 class 定义样式；它们应该始终被当作辅助 class 使用。</strong></p>\n<p>JS 可以添加/删除这些 classes。这意味着相同的状态名称可以在不同的上下文同时使用，但是每个组件必须给状态定义自己的样式。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.tweet</span> &#123; <span class=\"comment\">/* … */</span> &#125;</div><div class=\"line\"><span class=\"selector-class\">.tweet</span><span class=\"selector-class\">.is-expanded</span> &#123; <span class=\"comment\">/* … */</span> &#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">article</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tweet is-expanded\"</span>&gt;</span></div><div class=\"line\">  …</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">article</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><a name=\"variables\"></a></p>\n<h2 id=\"Variables-变量\"><a href=\"#Variables-变量\" class=\"headerlink\" title=\"Variables 变量\"></a>Variables 变量</h2><p>语法: <code>&lt;property&gt;-&lt;value&gt;[—componentName]</code></p>\n<p>我们的 CSS 中变量名也是严格限制格式的。这种语法为属性，使用和组件中提供了强关联。</p>\n<p>下面的变量定义是一个颜色属性，使用 grayLight 颜色，使用到 highlightMenu 组件中。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">@color-grayLight—highlightMenu: rgb(51, 51, 50);</div></pre></td></tr></table></figure>\n<p><a name=\"colors\"></a></p>\n<h3 id=\"Colors\"><a href=\"#Colors\" class=\"headerlink\" title=\"Colors\"></a>Colors</h3><p>当实现样式属性值时，你只可以使用 colors.less 提供的颜色变量。</p>\n<p>向 colors.less 中添加颜色变量时，优先使用 RGB 和 RGBA，而不是 hex，名称，HSL 或者 HSLA。</p>\n<p><strong>Right:</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">rgb</span>(50, 50, 50);</div><div class=\"line\"><span class=\"selector-tag\">rgba</span>(50, 50, 50, 0<span class=\"selector-class\">.2</span>);</div></pre></td></tr></table></figure>\n<p><strong>Wrong:</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#FFF</span>;</div><div class=\"line\"><span class=\"selector-id\">#FFFFFF</span>;</div><div class=\"line\"><span class=\"selector-tag\">white</span>;</div><div class=\"line\"><span class=\"selector-tag\">hsl</span>(120, 100%, 50%);</div><div class=\"line\"><span class=\"selector-tag\">hsla</span>(120, 100%, 50%, 1);</div></pre></td></tr></table></figure>\n<p><a name=\"index\"></a></p>\n<h3 id=\"z-index-scale\"><a href=\"#z-index-scale\" class=\"headerlink\" title=\"z-index scale\"></a>z-index scale</h3><p>请使用 z-index.less 文件中限制的 z-index 取值。</p>\n<p><code>@zIndex-1 - @zIndex-9</code> 可供选择。不应该有取值超过 <code>@zIndex-9</code>。</p>\n<p><a name=\"font weight\"></a></p>\n<h3 id=\"Font-Weight\"><a href=\"#Font-Weight\" class=\"headerlink\" title=\"Font Weight\"></a>Font Weight</h3><p>由于 web fonts 的支持，<code>font-weight</code> 的角色比原来更加重要了。不像原来 <code>bold</code> 是个可以加粗文字的算法，现在不同的字重会渲染对应的不同文字。当然，使用 <code>font-weight</code> 的数值取值可以强化文本的展现。下面是一些指引。</p>\n<p>直接定义字重应该被避免，使用合适的字体变量：<code>.font-sansI7, .font-sansN7, 等等</code></p>\n<p>后缀定义了字重和样式：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">N = normal</div><div class=\"line\">I = italic</div><div class=\"line\">4 = normal font-weight</div><div class=\"line\">7 = bold font-weight</div></pre></td></tr></table></figure>\n<p>查看 type.less 来定义 type size, letter-spacing 和 line height。</p>\n<p>Raw sizes, spaces, and line heights 取值应该从 type.less 中选择。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">ex</span>:</div><div class=\"line\"></div><div class=\"line\">@<span class=\"keyword\">fontSize</span>-<span class=\"keyword\">micro</span></div><div class=\"line\">@fontSize-smallest</div><div class=\"line\">@fontSize-smaller</div><div class=\"line\">@fontSize-small</div><div class=\"line\">@fontSize-base</div><div class=\"line\">@fontSize-large</div><div class=\"line\">@fontSize-larger</div><div class=\"line\">@fontSize-largest</div><div class=\"line\">@fontSize-jumbo</div></pre></td></tr></table></figure>\n<p>See <a href=\"https://developer.mozilla.org/en/CSS/font-weight\" target=\"_blank\" rel=\"external\">Mozilla Developer Network — font-weight</a> for further reading.</p>\n<p><a name=\"line height\"></a></p>\n<h3 id=\"Line-Height\"><a href=\"#Line-Height\" class=\"headerlink\" title=\"Line Height\"></a>Line Height</h3><p>Type.less 同时提供了行高标尺。它应该被用于块状文本。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">ex</span>:</div><div class=\"line\"></div><div class=\"line\">@<span class=\"keyword\">lineHeight</span>-<span class=\"keyword\">tightest</span></div><div class=\"line\">@lineHeight-tighter</div><div class=\"line\">@lineHeight-tight</div><div class=\"line\">@lineHeight-baseSans</div><div class=\"line\">@lineHeight-base</div><div class=\"line\">@lineHeight-loose</div><div class=\"line\">@lineHeight-looser</div></pre></td></tr></table></figure>\n<p>Alternatively, when using line height to vertically center a single line of text, be sure to set the line height to the height of the container - 1.</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.btn</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">  <span class=\"attribute\">line-height</span>: <span class=\"number\">49px</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><a name=\"letterspacing\"></a></p>\n<h3 id=\"Letter-spacing\"><a href=\"#Letter-spacing\" class=\"headerlink\" title=\"Letter spacing\"></a>Letter spacing</h3><p>文本间距同样需要从以下变量标尺中选择。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">@<span class=\"keyword\">letterSpacing</span>-<span class=\"keyword\">tightest</span></div><div class=\"line\">@letterSpacing-tighter</div><div class=\"line\">@letterSpacing-tight</div><div class=\"line\">@letterSpacing-normal</div><div class=\"line\">@letterSpacing-loose</div><div class=\"line\">@letterSpacing-looser</div><div class=\"line\">​`</div></pre></td></tr></table></figure>\n<p><a name=\"polyfills\"></a></p>\n<h2 id=\"Polyfills\"><a href=\"#Polyfills\" class=\"headerlink\" title=\"Polyfills\"></a>Polyfills</h2><p>mixin syntax: <code>m-&lt;propertyName&gt;</code></p>\n<p>在 Medium 我们只使用 mixin 来生成浏览器前缀 polyfills。</p>\n<p>border radius mixin 示例:</p>\n<p>​<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.m-borderRadius</span>(@<span class=\"keyword\">radius</span>) &#123;</div><div class=\"line\">  <span class=\"selector-tag\">-webkit-border-radius</span>: @<span class=\"keyword\">radius</span>;</div><div class=\"line\">     <span class=\"selector-tag\">-moz-border-radius</span>: @<span class=\"keyword\">radius</span>;</div><div class=\"line\">          <span class=\"selector-tag\">border-radius</span>: @<span class=\"keyword\">radius</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><a name=\"formatting\"></a></p>\n<h2 id=\"Formatting\"><a href=\"#Formatting\" class=\"headerlink\" title=\"Formatting\"></a>Formatting</h2><p>以下是高层次页面构建样式规则。</p>\n<p><a name=\"spacing\"></a></p>\n<h3 id=\"Spacing\"><a href=\"#Spacing\" class=\"headerlink\" title=\"Spacing\"></a>Spacing</h3><p>CSS 规则需要逗号分割并另起一行：</p>\n<p><strong>Right:</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">.content,</div><div class=\"line\">.content-edit &#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>Wrong:</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">.content, .content-edit &#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>CSS 块需要间隔一行，不可以是两行也不可不隔行。</p>\n<p><strong>Right:</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">.content &#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\">.content-edit &#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>Wrong:</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">.content &#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">.content-edit &#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><a name=\"quotes\"></a></p>\n<h3 id=\"Quotes\"><a href=\"#Quotes\" class=\"headerlink\" title=\"Quotes\"></a>Quotes</h3><p>引号在 CSS 和 LESS 是可选的。我们使用双引号让视觉上更清楚的区分字符串和选择器或者样式属性。</p>\n<p><strong>Right:</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">background-image: url(\"/img/you.jpg\");</div><div class=\"line\">font-family: \"Helvetica Neue Light\", \"Helvetica Neue\", Helvetica, Arial;</div></pre></td></tr></table></figure>\n<p><strong>Wrong:</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">background-image: url(/img/you.jpg);</div><div class=\"line\">font-family: Helvetica Neue Light, Helvetica Neue, Helvetica, Arial;</div></pre></td></tr></table></figure>\n<p><a name=\"performance\"></a></p>\n<h2 id=\"Performance\"><a href=\"#Performance\" class=\"headerlink\" title=\"Performance\"></a>Performance</h2><p><a name=\"specificity\"></a></p>\n<h3 id=\"Specificity\"><a href=\"#Specificity\" class=\"headerlink\" title=\"Specificity\"></a>Specificity</h3><p>虽然层叠式存在与名字（层递式样式表）中，它带来了非不要的性能问题。参照以下示例：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">ul</span><span class=\"selector-class\">.user-list</span> <span class=\"selector-tag\">li</span> <span class=\"selector-tag\">span</span> <span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span> &#123; <span class=\"attribute\">color</span>: red; &#125;</div></pre></td></tr></table></figure>\n<p>样式在页面渲染 layout 的过程中解析。选择器自右向左解析，在选择器无法适配时退出。因此，在上面的示例中，每一个 a 标签都会被检查是不是处在一个 span 和 li 中。就像想象中的一样，这需要一系列的 DOM 遍历，对于大型文档来说可以带来显著的 layout 耗时增加。访问 <a href=\"https://developers.google.com/speed/docs/best-practices/rendering#UseEfficientCSSSelectors\" target=\"_blank\" rel=\"external\">https://developers.google.com/speed/docs/best-practices/rendering#UseEfficientCSSSelectors</a> 查看更多信息。</p>\n<p>如果只是想在 <code>.user-list</code> 下的所有 <code>a</code> 元素 hover 时变红，可以将样式简化为：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.user-list</span> &gt; <span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果你只想给予 <code>.user-list</code> 下的部分 <code>a</code> 元素一些样式，可以给它们一个特定的 class：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.user-list</span> &gt; <span class=\"selector-class\">.link-primary</span><span class=\"selector-pseudo\">:hover</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<h1 id=\"Medium-LESS-编码指引\"><a href=\"#Medium-LESS-编码指引\" class=\"headerlink\" title=\"Medium LESS 编码指引\"></a>Medium LESS 编码指引</h1><p>Medium 使用 <a href=\"http://lesscss.org/\">LESS</a> 的一个严格子集来进行 CSS 预处理。严格子集只包括变量和 mixin，不包含任何其它内容（嵌套等）。</p>\n<p>Medium 的命名约定改编自 SUIT CSS 框架。具体的说，它依赖于 <em>结构化的类名</em> 和 <em>有意义的分隔符</em> （分隔符不仅仅用来分隔单词）来约定命名。这样的设计可以帮助拟补当前给 DOM 设置 CSS 的不足（例如，缺少样式封装），同时可以改善不同 class 之间的联系。</p>","more":"<p><strong>Table of contents</strong></p>\n<ul>\n<li><a href=\"#javascript\">JavaScript</a></li>\n<li><a href=\"#utilities\">Utilities</a><ul>\n<li><a href=\"#u-utilityName\">u-utilityName</a></li>\n</ul>\n</li>\n<li><a href=\"#components\">Components</a><ul>\n<li><a href=\"#componentName\">componentName</a></li>\n<li><a href=\"#componentName--modifierName\">componentName–modifierName</a></li>\n<li><a href=\"#componentName-descendantName\">componentName-descendantName</a></li>\n<li><a href=\"#is-stateOfComponent\">componentName.is-stateOfComponent</a></li>\n</ul>\n</li>\n<li><a href=\"#variables\">Variables</a><ul>\n<li><a href=\"#colors\">colors</a></li>\n<li><a href=\"#zindex\">z-index</a></li>\n<li><a href=\"#fontweight\">font-weight</a></li>\n<li><a href=\"#lineheight\">line-height</a></li>\n<li><a href=\"#letterspacing\">letter-spacing</a></li>\n</ul>\n</li>\n<li><a href=\"#polyfills\">Polyfills</a></li>\n<li><a href=\"#formatting\">Formatting</a><ul>\n<li><a href=\"#spacing\">Spacing</a></li>\n<li><a href=\"#quotes\">Quotes</a></li>\n</ul>\n</li>\n<li><a href=\"#performance\">Performance</a><ul>\n<li><a href=\"#specificity\">Specificity</a></li>\n</ul>\n</li>\n</ul>\n<p><a name=\"javascript\"></a></p>\n<h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h2><p>语法: <code>js-&lt;targetName&gt;</code></p>\n<p>JavaScript 特有的 classes 可以减少改变组件的结构或者样式时不经意间影响关联的 JavaScript 行为的风险。它只是个工具，并不是所有情况下都必要。如果你需要创建一个并不会对它添加样式，而只是 JavaScript 中的一个选择器的 class，你就应该添加 <code>js-</code> 前缀。实际使用，会像下面这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/login\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"ban ban-primary js-login\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>再次强调，JavaScript 特有的 classes 在任何情况下，都不应该被设置样式。</strong></p>\n<p><a name=\"utilities\"></a></p>\n<h2 id=\"Utilities\"><a href=\"#Utilities\" class=\"headerlink\" title=\"Utilities\"></a>Utilities</h2><p>Medium 的工具 classes 包括一些低层次的结构和位置。工具类可以直接作用到任意的元素上；多个工具类可以同时使用；并且工具类可以和组件类同事使用。</p>\n<p>工具类的存在是因为特定的 CSS 属性和模式很常用。比如：浮动，内容浮动，垂直居中，文本截断等。通过工具类可以去重并且提供一致的实现。它们同时充当一个功能性（比如： non-polypill） mixin 的替代品。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"u-clearfix\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"u-textTruncate\"</span>&gt;</span>&#123;$text&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">class</span>=<span class=\"string\">\"u-pullLeft\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&#123;$src&#125;\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">class</span>=<span class=\"string\">\"u-pullLeft\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&#123;$src&#125;\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">class</span>=<span class=\"string\">\"u-pullLeft\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&#123;$src&#125;\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><a name=\"u-utilityName\"></a></p>\n<h3 id=\"u-utilityName\"><a href=\"#u-utilityName\" class=\"headerlink\" title=\"u-utilityName\"></a>u-utilityName</h3><p>语法: <code>u-&lt;utilityName&gt;</code></p>\n<p>工具类必须使用驼峰式命名法，使用 <code>u</code> 作为命名空间前缀。以下展示一个示例，怎样在一个组件中，使用不同的工具类建立一个简单的结构。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"u-clearfix\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">class</span>=<span class=\"string\">\"u-pullLeft\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"&#123;$url&#125;\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">class</span>=<span class=\"string\">\"u-block\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&#123;$src&#125;\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"u-sizeFill u-textBreak\"</span>&gt;</span></div><div class=\"line\">    …</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><a name=\"components\"></a></p>\n<h2 id=\"Components-组件\"><a href=\"#Components-组件\" class=\"headerlink\" title=\"Components 组件\"></a>Components 组件</h2><p>语法: <code>&lt;componentName&gt;[--modifierName|-descendantName]</code></p>\n<p>组件驱动开发为阅读和编写 HTML CSS 代码提供了很多好处：</p>\n<ul>\n<li>帮助区分组件 root 节点，子节点，以及修改器的 class。</li>\n<li>保持底层选择器的唯一性</li>\n<li>帮助从文档语义中分离展现语义</li>\n</ul>\n<p>你可以认为组件是一个封装了语义，样式和行为的特殊元素。</p>\n<p><a name=\"componentName\"></a></p>\n<h3 id=\"ComponentName\"><a href=\"#ComponentName\" class=\"headerlink\" title=\"ComponentName\"></a>ComponentName</h3><p>组件名称必须使用驼峰式命名法。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.myComponent</span> &#123; <span class=\"comment\">/* … */</span> &#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">article</span> <span class=\"attr\">class</span>=<span class=\"string\">\"myComponent\"</span>&gt;</span></div><div class=\"line\">  …</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">article</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><a name=\"componentName--modifierName\"></a></p>\n<h3 id=\"componentName–modifierName\"><a href=\"#componentName–modifierName\" class=\"headerlink\" title=\"componentName–modifierName\"></a>componentName–modifierName</h3><p>组件修改器的作用是在某些方面修改基础组件的展现。修改器必须使用驼峰式命名法，并且使用两个分隔符与组件名称分割。修改器 class 必须在组件 class <em>之外</em> 被添加到 HTML 中。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* Core button */</span></div><div class=\"line\"><span class=\"selector-class\">.btn</span> &#123; <span class=\"comment\">/* … */</span> &#125;</div><div class=\"line\"><span class=\"comment\">/* Default button style */</span></div><div class=\"line\"><span class=\"selector-class\">.btn--default</span> &#123; <span class=\"comment\">/* … */</span> &#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"ban btn--primary\"</span>&gt;</span>…<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><a name=\"componentName-descendantName\"></a></p>\n<h3 id=\"componentName-descendantName\"><a href=\"#componentName-descendantName\" class=\"headerlink\" title=\"componentName-descendantName\"></a>componentName-descendantName</h3><p>一个组件后代是一个附加到一个组件子元素上的 class。它负责给特定组件的子元素提供展现。组件后代必须以驼峰式命名法命名。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">article</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tweet\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">header</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tweet-header\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tweet-avatar\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&#123;$src&#125;\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"&#123;$alt&#125;\"</span>&gt;</span></div><div class=\"line\">    …</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tweet-body\"</span>&gt;</span></div><div class=\"line\">    …</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">article</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><a name=\"is-stateOfComponent\"></a></p>\n<h3 id=\"componentName-is-stateOfComponent\"><a href=\"#componentName-is-stateOfComponent\" class=\"headerlink\" title=\"componentName.is-stateOfComponent\"></a>componentName.is-stateOfComponent</h3><p>使用 <code>is-stateName</code> 来给状态相关的组件修改器命名。状态名称必须使用驼峰式命名法。<strong>永远不要直接给这些 class 定义样式；它们应该始终被当作辅助 class 使用。</strong></p>\n<p>JS 可以添加/删除这些 classes。这意味着相同的状态名称可以在不同的上下文同时使用，但是每个组件必须给状态定义自己的样式。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.tweet</span> &#123; <span class=\"comment\">/* … */</span> &#125;</div><div class=\"line\"><span class=\"selector-class\">.tweet</span><span class=\"selector-class\">.is-expanded</span> &#123; <span class=\"comment\">/* … */</span> &#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">article</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tweet is-expanded\"</span>&gt;</span></div><div class=\"line\">  …</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">article</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><a name=\"variables\"></a></p>\n<h2 id=\"Variables-变量\"><a href=\"#Variables-变量\" class=\"headerlink\" title=\"Variables 变量\"></a>Variables 变量</h2><p>语法: <code>&lt;property&gt;-&lt;value&gt;[—componentName]</code></p>\n<p>我们的 CSS 中变量名也是严格限制格式的。这种语法为属性，使用和组件中提供了强关联。</p>\n<p>下面的变量定义是一个颜色属性，使用 grayLight 颜色，使用到 highlightMenu 组件中。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">@color-grayLight—highlightMenu: rgb(51, 51, 50);</div></pre></td></tr></table></figure>\n<p><a name=\"colors\"></a></p>\n<h3 id=\"Colors\"><a href=\"#Colors\" class=\"headerlink\" title=\"Colors\"></a>Colors</h3><p>当实现样式属性值时，你只可以使用 colors.less 提供的颜色变量。</p>\n<p>向 colors.less 中添加颜色变量时，优先使用 RGB 和 RGBA，而不是 hex，名称，HSL 或者 HSLA。</p>\n<p><strong>Right:</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">rgb</span>(50, 50, 50);</div><div class=\"line\"><span class=\"selector-tag\">rgba</span>(50, 50, 50, 0<span class=\"selector-class\">.2</span>);</div></pre></td></tr></table></figure>\n<p><strong>Wrong:</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#FFF</span>;</div><div class=\"line\"><span class=\"selector-id\">#FFFFFF</span>;</div><div class=\"line\"><span class=\"selector-tag\">white</span>;</div><div class=\"line\"><span class=\"selector-tag\">hsl</span>(120, 100%, 50%);</div><div class=\"line\"><span class=\"selector-tag\">hsla</span>(120, 100%, 50%, 1);</div></pre></td></tr></table></figure>\n<p><a name=\"index\"></a></p>\n<h3 id=\"z-index-scale\"><a href=\"#z-index-scale\" class=\"headerlink\" title=\"z-index scale\"></a>z-index scale</h3><p>请使用 z-index.less 文件中限制的 z-index 取值。</p>\n<p><code>@zIndex-1 - @zIndex-9</code> 可供选择。不应该有取值超过 <code>@zIndex-9</code>。</p>\n<p><a name=\"font weight\"></a></p>\n<h3 id=\"Font-Weight\"><a href=\"#Font-Weight\" class=\"headerlink\" title=\"Font Weight\"></a>Font Weight</h3><p>由于 web fonts 的支持，<code>font-weight</code> 的角色比原来更加重要了。不像原来 <code>bold</code> 是个可以加粗文字的算法，现在不同的字重会渲染对应的不同文字。当然，使用 <code>font-weight</code> 的数值取值可以强化文本的展现。下面是一些指引。</p>\n<p>直接定义字重应该被避免，使用合适的字体变量：<code>.font-sansI7, .font-sansN7, 等等</code></p>\n<p>后缀定义了字重和样式：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">N = normal</div><div class=\"line\">I = italic</div><div class=\"line\">4 = normal font-weight</div><div class=\"line\">7 = bold font-weight</div></pre></td></tr></table></figure>\n<p>查看 type.less 来定义 type size, letter-spacing 和 line height。</p>\n<p>Raw sizes, spaces, and line heights 取值应该从 type.less 中选择。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">ex</span>:</div><div class=\"line\"></div><div class=\"line\">@<span class=\"keyword\">fontSize</span>-<span class=\"keyword\">micro</span></div><div class=\"line\">@fontSize-smallest</div><div class=\"line\">@fontSize-smaller</div><div class=\"line\">@fontSize-small</div><div class=\"line\">@fontSize-base</div><div class=\"line\">@fontSize-large</div><div class=\"line\">@fontSize-larger</div><div class=\"line\">@fontSize-largest</div><div class=\"line\">@fontSize-jumbo</div></pre></td></tr></table></figure>\n<p>See <a href=\"https://developer.mozilla.org/en/CSS/font-weight\">Mozilla Developer Network — font-weight</a> for further reading.</p>\n<p><a name=\"line height\"></a></p>\n<h3 id=\"Line-Height\"><a href=\"#Line-Height\" class=\"headerlink\" title=\"Line Height\"></a>Line Height</h3><p>Type.less 同时提供了行高标尺。它应该被用于块状文本。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">ex</span>:</div><div class=\"line\"></div><div class=\"line\">@<span class=\"keyword\">lineHeight</span>-<span class=\"keyword\">tightest</span></div><div class=\"line\">@lineHeight-tighter</div><div class=\"line\">@lineHeight-tight</div><div class=\"line\">@lineHeight-baseSans</div><div class=\"line\">@lineHeight-base</div><div class=\"line\">@lineHeight-loose</div><div class=\"line\">@lineHeight-looser</div></pre></td></tr></table></figure>\n<p>Alternatively, when using line height to vertically center a single line of text, be sure to set the line height to the height of the container - 1.</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.btn</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</div><div class=\"line\">  <span class=\"attribute\">line-height</span>: <span class=\"number\">49px</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><a name=\"letterspacing\"></a></p>\n<h3 id=\"Letter-spacing\"><a href=\"#Letter-spacing\" class=\"headerlink\" title=\"Letter spacing\"></a>Letter spacing</h3><p>文本间距同样需要从以下变量标尺中选择。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">@<span class=\"keyword\">letterSpacing</span>-<span class=\"keyword\">tightest</span></div><div class=\"line\">@letterSpacing-tighter</div><div class=\"line\">@letterSpacing-tight</div><div class=\"line\">@letterSpacing-normal</div><div class=\"line\">@letterSpacing-loose</div><div class=\"line\">@letterSpacing-looser</div><div class=\"line\">​`</div></pre></td></tr></table></figure>\n<p><a name=\"polyfills\"></a></p>\n<h2 id=\"Polyfills\"><a href=\"#Polyfills\" class=\"headerlink\" title=\"Polyfills\"></a>Polyfills</h2><p>mixin syntax: <code>m-&lt;propertyName&gt;</code></p>\n<p>在 Medium 我们只使用 mixin 来生成浏览器前缀 polyfills。</p>\n<p>border radius mixin 示例:</p>\n<p>​<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.m-borderRadius</span>(@<span class=\"keyword\">radius</span>) &#123;</div><div class=\"line\">  <span class=\"selector-tag\">-webkit-border-radius</span>: @<span class=\"keyword\">radius</span>;</div><div class=\"line\">     <span class=\"selector-tag\">-moz-border-radius</span>: @<span class=\"keyword\">radius</span>;</div><div class=\"line\">          <span class=\"selector-tag\">border-radius</span>: @<span class=\"keyword\">radius</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><a name=\"formatting\"></a></p>\n<h2 id=\"Formatting\"><a href=\"#Formatting\" class=\"headerlink\" title=\"Formatting\"></a>Formatting</h2><p>以下是高层次页面构建样式规则。</p>\n<p><a name=\"spacing\"></a></p>\n<h3 id=\"Spacing\"><a href=\"#Spacing\" class=\"headerlink\" title=\"Spacing\"></a>Spacing</h3><p>CSS 规则需要逗号分割并另起一行：</p>\n<p><strong>Right:</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">.content,</div><div class=\"line\">.content-edit &#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>Wrong:</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">.content, .content-edit &#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>CSS 块需要间隔一行，不可以是两行也不可不隔行。</p>\n<p><strong>Right:</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">.content &#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\">.content-edit &#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>Wrong:</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">.content &#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">.content-edit &#123;</div><div class=\"line\">  …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><a name=\"quotes\"></a></p>\n<h3 id=\"Quotes\"><a href=\"#Quotes\" class=\"headerlink\" title=\"Quotes\"></a>Quotes</h3><p>引号在 CSS 和 LESS 是可选的。我们使用双引号让视觉上更清楚的区分字符串和选择器或者样式属性。</p>\n<p><strong>Right:</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">background-image: url(\"/img/you.jpg\");</div><div class=\"line\">font-family: \"Helvetica Neue Light\", \"Helvetica Neue\", Helvetica, Arial;</div></pre></td></tr></table></figure>\n<p><strong>Wrong:</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">background-image: url(/img/you.jpg);</div><div class=\"line\">font-family: Helvetica Neue Light, Helvetica Neue, Helvetica, Arial;</div></pre></td></tr></table></figure>\n<p><a name=\"performance\"></a></p>\n<h2 id=\"Performance\"><a href=\"#Performance\" class=\"headerlink\" title=\"Performance\"></a>Performance</h2><p><a name=\"specificity\"></a></p>\n<h3 id=\"Specificity\"><a href=\"#Specificity\" class=\"headerlink\" title=\"Specificity\"></a>Specificity</h3><p>虽然层叠式存在与名字（层递式样式表）中，它带来了非不要的性能问题。参照以下示例：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">ul</span><span class=\"selector-class\">.user-list</span> <span class=\"selector-tag\">li</span> <span class=\"selector-tag\">span</span> <span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span> &#123; <span class=\"attribute\">color</span>: red; &#125;</div></pre></td></tr></table></figure>\n<p>样式在页面渲染 layout 的过程中解析。选择器自右向左解析，在选择器无法适配时退出。因此，在上面的示例中，每一个 a 标签都会被检查是不是处在一个 span 和 li 中。就像想象中的一样，这需要一系列的 DOM 遍历，对于大型文档来说可以带来显著的 layout 耗时增加。访问 <a href=\"https://developers.google.com/speed/docs/best-practices/rendering#UseEfficientCSSSelectors\">https://developers.google.com/speed/docs/best-practices/rendering#UseEfficientCSSSelectors</a> 查看更多信息。</p>\n<p>如果只是想在 <code>.user-list</code> 下的所有 <code>a</code> 元素 hover 时变红，可以将样式简化为：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.user-list</span> &gt; <span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果你只想给予 <code>.user-list</code> 下的部分 <code>a</code> 元素一些样式，可以给它们一个特定的 class：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.user-list</span> &gt; <span class=\"selector-class\">.link-primary</span><span class=\"selector-pseudo\">:hover</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"layout":"post","title":"Vuejs 中的 Reactivity 的实现","_content":"\nReactivity (Vue 中文文档中翻译为响应式) 是 Vue 的非常关键的一部分。通过 Model 与视图的双向绑定，让使用者可以简单的更新页面状态，不再需要直接操作 DOM 进行处理。\n\n除了 Reactivity，Vue 中还有很多其他的部分，包括：模版解析、VDOM、组件等。\n为了更好的学习 Vue 中 Reactivity 的实现，将其中 Reactivity 相关部分拿出来成为了单独的部分。这样更容易单独的看这一部分的实现。\n相关的代码在 [vue-observer](https://github.com/ZoomZhao/vue-observer)\n\n<!-- more -->\n\n运行：\n\n```\nnpm install;\nnpm run dev;\n```\n\n通过访问 `example/base` 下的 `index.html`，并修改源码，了解其中的实现。\n\n\nReactivity 监控变化的处理流程参考 Vue 文档中给出的图片：\n\n![vue-reactivity](https://cn.vuejs.org/images/data.png)\n\n\n下面从文件介绍以及处理流程两个方面，介绍 Vue 中 Reactivity 的具体实现。\n\n## 文件功能介绍\n\n### instance \n\ninstance 中相关的文件，主要是两个：\n\n1.  `state.js`\n\n    Vue 中初始化传入的 `props`，`data`，`compute`，`watch` 的逻辑\n\n2.  `render.js`\n\n     vue-observer 示例中将 Vue 的 `render` 方法作了精简，并将 `render` 方法的调用（其实是 `new Watcher()`）从 lifecycle 移到了 render.js 文件中。\n\n### observer\n\nvue-observer 的这部分代码，基本完全与 Vue 中的代码一致，是 Vue 中 Reactivity 实现的核心代码。主要包含以下几个文件\n\n1. `inde.xjs`\n\n    包含类 `Observer`，主要是为各个需要观察的目标埋点 （`new Dep()`）\n    \n2. `dep.js`\n\n    包含类 `Dep`  （观察点 类）\n    \n3. `watcher.js`\n\n    包含类 `Watcher`  （观察者 类）\n    \n4. `scheduler.js`\n\n    观察者的调度逻辑，主要负责处理，多个 Watcher 需要被调用的情况。防止多次被调用以及在特定情况下按顺序调用。\n    \n5. `array.js`\n\n    辅助方法，用于重写 Array 的一些方法，使 Array 的变化可以被观察。\n\n\n其中的两个重要的类，属性方法如下：\n#### Dep 类\n\n**属性**\n\n- `target`  静态属性，全局唯一，标识当前正在处理的 Watcher\n- `id`  ID\n- `subs`  Watcher 的列表\n\n\n**方法**\n\n- `addSub`  添加 Watcher\n- `removeSub`  移除 Watcher\n- `depend`  为自己添加当前 target Watcher，并更新 Watcher 的观察列表\n- `notify`  通知所有 Watcher 更新\n\n\n#### Watcher\n\n根据传入的 expression，得到 value，传给 cb 进行处理。\n\n**属性**\n\n- `deep` 用于决定是否完整的轮训，来保证每一个属性都被重新计算依赖\n- `user` 是否是用户创建的，是的话会尝试捕获 cb 调用时产生的异常，并提醒\n- `lazy` 是否 new 之后不立即执行\n- `sync` 是否需要在每次需要 update 的时候立即执行 （不设置的话会交由 scheduler 处理）\n- `expression` 传入的方法或表达式\n- `cb` 执行之后的回调函数\n- `id` \n- `active` 是否当前激活状态\n- `dirty` 是否是脏数据\n- `deps` 与下面的三个一起，用来做 观察目标 （Dep）的动态更新\n- `newDeps`\n- `depIds`\n- `newDepIds`\n- `getter` 从 expression 来的 getter 方法\n- `value` 当前的取值\n\n**方法**\n\n- `get` 默认初始化之后调用，调用传入的 expression，收集依赖，并调用 `cleanupDeps` 更新依赖关系\n- `addDep` 把自身添加到制定 Dep 的观察列表中，另外如果依赖有变化则记录\n- `cleanupDeps` 更新依赖关系\n- `update` 更新\n- `run` 具体的执行方法，负责调用 `get` 然后根据情况决定是否调用 `cb`\n- `evaluate` 只是调用 `get`，用于清除 `dirty` 状态\n- `depend` 把收集的 deps 统一进行处理，跟 `evaluate` 一样，都是为 `lazy` 的 Watcher 服务的\n- `teardown` 销毁\n\n\n### util + share 一些工具代码\n\n一些工具方法\n\n## Reactivity 相关处理流程\n\n大概了解了各个文件的功能之后，我们从处理流程的角度，了解下 Vue 中 Reactivity 的具体处理过程。\n\nReactivity 的处理包含三个部分：\n\n- 初始化观察目标，负责埋点\n- 初始化 Watcher 并进行依赖收集，等待变更出现\n- 出现变更，进行更新\n\n\n### 初始化观察目标\n\n初始化的时候（在 Vue 中 `new Vue` 或者创建 `Component`），根据传入的 `$options` 进行初始化处理。\n\n- 初始化 `$options.props`\n- 初始化 `$options.data`\n\n  通过调用 `observer/index.js` 文件中的 `observer` 方法，进行埋点。\n\n  - 每个对象（Object 和 Array）都会被分配个观察者 `Observer`\n  \n    主要是用于对象变更的观察，例如 Array 的 push 操作；另外一个使用的地方是 Vue.set ，可以在初始化之后依然提供观察的能力。\n    这里有一个很厉害的细节，`Observer` 对象被放到了 Object 的 `__ob__` 属性中，既可以在拿到对象的时候都可以回去到对应的 `Observer`，还起到缓存的作用，防止多次观察同一对象，一举两得。\n\n  - 每个属性也会被分配个观察者\n\n  这里的观察者采用了闭包的方式，通过 Object.defineProperty 来处理 getter 和 setter。在 get 的时候，处理观察关系，将当前 Watcher 加入到属性的观察者列表中。set 的时候，通过 dep.notify() 触发观察者进行更新。\n\n  这里也有个 childOb 的概念，如果当前的属性存在 childOb，那么 childOb 也要同时被当前 Watcher 观察。\n\n### 初始化 Watcher 并进行依赖收集，等待变更出现\n\n初始化 Watcher 分为三个部分：\n\n- 初始化 $options.computed 的 Watcher\n\n  Vue 中可以通过给 `$options` 传入 computed 对象来处理一些比较复杂的显示逻辑。这个时候就要根据所依赖的属性，进行观察和重新计算。computed 对应的 Watcher 通过 makeComputedGetter 方法创建，他的特点是，创建的为 Lazy Watcher，new 之后不会立即调用，在 computed 的属性被 get 的时候才需要重新计算。\n\n  对于这类 Watcher，处理的流程为\n\n  1. 初始化的时候，只设置 dirty 为 true，不直接执行传入的 expression。\n  2. 每次 Dep 通过 update 的时候只设置 Watcher 的 dirty 为 true，标识需要重新计算。\n  3. 在需要获取最新值得时候（这里就是 computed 属性被 get 的时候）调用 watcher.evaluate() 方法，计算 watcher 的最新值，并且手动调用 watcher.depend() 方法来重新计算依赖。\n\n- 初始化 $options.watch 的 Watcher\n\n  `$options.watch` 提供观察 `data` 的功能，在 `data` 被修改之后，触发提供的回调函数。\n\n  具体的实现过程中，使用了 Vue 暴露出的全局 API：`Vue.$watch`，创建一个普通的 watcher，在指定的 expression 的发生改变的时候触发 cb。\n\n- 初始化 render Watcher\n\n  在 Vue 的处理流程中，会把 temple 编译为 render 函数（具体的实现会更加复杂），在 Vue Component 初始化完成的时候，会创建一个 Watcher(render, patchVDom)，根据传入的 render 函数创建依赖关系，如果发现变化，则 PatchVDom， 实现 View 的更新。\n\n### 出现变更，进行更新\n\n经过 Watcher 的初始化，Vue 中的 Watcher，分为三类（不包括用户调用 `Vue.$watch` 传入 sync 参数的情况）\n    \n- Computed Watcher（lazy Watcher），update 的时候只标记 dirty 状态，不会进入 queue（后面具体讲队列），属性被 get 的时候直接调用 `watcher.evaluate()` 进行取值。\n- 普通 Watcher，包含用户通过 `$options.watch` 或 `Vue.$watch` 生成的 watch，在 update 的时候会进入 queue\n- Component Watcher，render 方法作为 expOrFn 的 watcher，实现 Model -> DOM 的关键 Watcher，在 update 的时候会进入 queue\n\n在 Model 被改变的时候，对应的 dep 被触发 notify 方法。dep 会调用所有 watcher 的 update 方法。\n\n- Computed Watcher 的处理逻辑在 *初始化 $options.computed 的 Watcher* 部分已经做了描述\n- 其他的 watcher （不包括设置 sync 为 true，下同）都会交由 queueWatcher 进行处理\n\n想过逻辑存在于文件 `observer/scheduler.js`\n\nqueueWatcher 的作用主要有以下几点：\n\n1. 同一个 watcher 只会被添加到列表中一次，防止被多次调用\n2. 如果正在执行队列，则会判断当前插入的 watcher id，如果已经过了，则立即执行，否则插入到合适位置\n3. 当前处理的所有 watcher 被插入到队列之后进行执行\n\n执行队列的时候，会先对需要执行的 watcher 进行排序处理：\n\n1. 大的方面，从父组件到子组件的方向执行，因为父组件总是先被创建的。\n2. 用户定义的 watcher 先于 render watcher 被处理（用户定义的 watcher 可能会影响 Model 的取值）\n3. 如果子组件被父组件干掉了，那么它会被跳过。\n\n这个顺序也是 watcher 被创建的顺序，这样的话，按照 watcher 的 id 从小到大进行排列就可以了。\n\n然后执行 排重 + 排序 之后的 watcher 队列，这样就保证了，每次数据变更，只会按顺序处理一次需要更新的 watcher。\n\n\n----\n\n这就是 Vue 中的 Reactivity 的具体实现。\n\n可以看到，这部分的整体的实现真的是非常的好。\n\n其中 Dep 和 Watcher 这两个类的设计非常优秀。在 Watcher 中存储了 Dep 的列表，也在 Dep 中存储了 Watcher 的列表。通过这样的设计，既可以在 Watcher 实例中，初始化及更新依赖关系（通过 Deps 和 newDeps），也可以在 dep 中直接通知所有的 watcher 进行更新。\n\nscheduler 的引入很好的解决了什么时候调用 watcher 的问题，最大化的减少了 DOM 操作，再加上 VDOM，就完成了 Model 到 View 的高性能的映射。\n \n\n\n\n\n\n\n​\t\n\n","source":"_posts/2016-12-23-reactivity-system-of-vuejs.md","raw":"---\nlayout: post\ntitle: Vuejs 中的 Reactivity 的实现\n---\n\nReactivity (Vue 中文文档中翻译为响应式) 是 Vue 的非常关键的一部分。通过 Model 与视图的双向绑定，让使用者可以简单的更新页面状态，不再需要直接操作 DOM 进行处理。\n\n除了 Reactivity，Vue 中还有很多其他的部分，包括：模版解析、VDOM、组件等。\n为了更好的学习 Vue 中 Reactivity 的实现，将其中 Reactivity 相关部分拿出来成为了单独的部分。这样更容易单独的看这一部分的实现。\n相关的代码在 [vue-observer](https://github.com/ZoomZhao/vue-observer)\n\n<!-- more -->\n\n运行：\n\n```\nnpm install;\nnpm run dev;\n```\n\n通过访问 `example/base` 下的 `index.html`，并修改源码，了解其中的实现。\n\n\nReactivity 监控变化的处理流程参考 Vue 文档中给出的图片：\n\n![vue-reactivity](https://cn.vuejs.org/images/data.png)\n\n\n下面从文件介绍以及处理流程两个方面，介绍 Vue 中 Reactivity 的具体实现。\n\n## 文件功能介绍\n\n### instance \n\ninstance 中相关的文件，主要是两个：\n\n1.  `state.js`\n\n    Vue 中初始化传入的 `props`，`data`，`compute`，`watch` 的逻辑\n\n2.  `render.js`\n\n     vue-observer 示例中将 Vue 的 `render` 方法作了精简，并将 `render` 方法的调用（其实是 `new Watcher()`）从 lifecycle 移到了 render.js 文件中。\n\n### observer\n\nvue-observer 的这部分代码，基本完全与 Vue 中的代码一致，是 Vue 中 Reactivity 实现的核心代码。主要包含以下几个文件\n\n1. `inde.xjs`\n\n    包含类 `Observer`，主要是为各个需要观察的目标埋点 （`new Dep()`）\n    \n2. `dep.js`\n\n    包含类 `Dep`  （观察点 类）\n    \n3. `watcher.js`\n\n    包含类 `Watcher`  （观察者 类）\n    \n4. `scheduler.js`\n\n    观察者的调度逻辑，主要负责处理，多个 Watcher 需要被调用的情况。防止多次被调用以及在特定情况下按顺序调用。\n    \n5. `array.js`\n\n    辅助方法，用于重写 Array 的一些方法，使 Array 的变化可以被观察。\n\n\n其中的两个重要的类，属性方法如下：\n#### Dep 类\n\n**属性**\n\n- `target`  静态属性，全局唯一，标识当前正在处理的 Watcher\n- `id`  ID\n- `subs`  Watcher 的列表\n\n\n**方法**\n\n- `addSub`  添加 Watcher\n- `removeSub`  移除 Watcher\n- `depend`  为自己添加当前 target Watcher，并更新 Watcher 的观察列表\n- `notify`  通知所有 Watcher 更新\n\n\n#### Watcher\n\n根据传入的 expression，得到 value，传给 cb 进行处理。\n\n**属性**\n\n- `deep` 用于决定是否完整的轮训，来保证每一个属性都被重新计算依赖\n- `user` 是否是用户创建的，是的话会尝试捕获 cb 调用时产生的异常，并提醒\n- `lazy` 是否 new 之后不立即执行\n- `sync` 是否需要在每次需要 update 的时候立即执行 （不设置的话会交由 scheduler 处理）\n- `expression` 传入的方法或表达式\n- `cb` 执行之后的回调函数\n- `id` \n- `active` 是否当前激活状态\n- `dirty` 是否是脏数据\n- `deps` 与下面的三个一起，用来做 观察目标 （Dep）的动态更新\n- `newDeps`\n- `depIds`\n- `newDepIds`\n- `getter` 从 expression 来的 getter 方法\n- `value` 当前的取值\n\n**方法**\n\n- `get` 默认初始化之后调用，调用传入的 expression，收集依赖，并调用 `cleanupDeps` 更新依赖关系\n- `addDep` 把自身添加到制定 Dep 的观察列表中，另外如果依赖有变化则记录\n- `cleanupDeps` 更新依赖关系\n- `update` 更新\n- `run` 具体的执行方法，负责调用 `get` 然后根据情况决定是否调用 `cb`\n- `evaluate` 只是调用 `get`，用于清除 `dirty` 状态\n- `depend` 把收集的 deps 统一进行处理，跟 `evaluate` 一样，都是为 `lazy` 的 Watcher 服务的\n- `teardown` 销毁\n\n\n### util + share 一些工具代码\n\n一些工具方法\n\n## Reactivity 相关处理流程\n\n大概了解了各个文件的功能之后，我们从处理流程的角度，了解下 Vue 中 Reactivity 的具体处理过程。\n\nReactivity 的处理包含三个部分：\n\n- 初始化观察目标，负责埋点\n- 初始化 Watcher 并进行依赖收集，等待变更出现\n- 出现变更，进行更新\n\n\n### 初始化观察目标\n\n初始化的时候（在 Vue 中 `new Vue` 或者创建 `Component`），根据传入的 `$options` 进行初始化处理。\n\n- 初始化 `$options.props`\n- 初始化 `$options.data`\n\n  通过调用 `observer/index.js` 文件中的 `observer` 方法，进行埋点。\n\n  - 每个对象（Object 和 Array）都会被分配个观察者 `Observer`\n  \n    主要是用于对象变更的观察，例如 Array 的 push 操作；另外一个使用的地方是 Vue.set ，可以在初始化之后依然提供观察的能力。\n    这里有一个很厉害的细节，`Observer` 对象被放到了 Object 的 `__ob__` 属性中，既可以在拿到对象的时候都可以回去到对应的 `Observer`，还起到缓存的作用，防止多次观察同一对象，一举两得。\n\n  - 每个属性也会被分配个观察者\n\n  这里的观察者采用了闭包的方式，通过 Object.defineProperty 来处理 getter 和 setter。在 get 的时候，处理观察关系，将当前 Watcher 加入到属性的观察者列表中。set 的时候，通过 dep.notify() 触发观察者进行更新。\n\n  这里也有个 childOb 的概念，如果当前的属性存在 childOb，那么 childOb 也要同时被当前 Watcher 观察。\n\n### 初始化 Watcher 并进行依赖收集，等待变更出现\n\n初始化 Watcher 分为三个部分：\n\n- 初始化 $options.computed 的 Watcher\n\n  Vue 中可以通过给 `$options` 传入 computed 对象来处理一些比较复杂的显示逻辑。这个时候就要根据所依赖的属性，进行观察和重新计算。computed 对应的 Watcher 通过 makeComputedGetter 方法创建，他的特点是，创建的为 Lazy Watcher，new 之后不会立即调用，在 computed 的属性被 get 的时候才需要重新计算。\n\n  对于这类 Watcher，处理的流程为\n\n  1. 初始化的时候，只设置 dirty 为 true，不直接执行传入的 expression。\n  2. 每次 Dep 通过 update 的时候只设置 Watcher 的 dirty 为 true，标识需要重新计算。\n  3. 在需要获取最新值得时候（这里就是 computed 属性被 get 的时候）调用 watcher.evaluate() 方法，计算 watcher 的最新值，并且手动调用 watcher.depend() 方法来重新计算依赖。\n\n- 初始化 $options.watch 的 Watcher\n\n  `$options.watch` 提供观察 `data` 的功能，在 `data` 被修改之后，触发提供的回调函数。\n\n  具体的实现过程中，使用了 Vue 暴露出的全局 API：`Vue.$watch`，创建一个普通的 watcher，在指定的 expression 的发生改变的时候触发 cb。\n\n- 初始化 render Watcher\n\n  在 Vue 的处理流程中，会把 temple 编译为 render 函数（具体的实现会更加复杂），在 Vue Component 初始化完成的时候，会创建一个 Watcher(render, patchVDom)，根据传入的 render 函数创建依赖关系，如果发现变化，则 PatchVDom， 实现 View 的更新。\n\n### 出现变更，进行更新\n\n经过 Watcher 的初始化，Vue 中的 Watcher，分为三类（不包括用户调用 `Vue.$watch` 传入 sync 参数的情况）\n    \n- Computed Watcher（lazy Watcher），update 的时候只标记 dirty 状态，不会进入 queue（后面具体讲队列），属性被 get 的时候直接调用 `watcher.evaluate()` 进行取值。\n- 普通 Watcher，包含用户通过 `$options.watch` 或 `Vue.$watch` 生成的 watch，在 update 的时候会进入 queue\n- Component Watcher，render 方法作为 expOrFn 的 watcher，实现 Model -> DOM 的关键 Watcher，在 update 的时候会进入 queue\n\n在 Model 被改变的时候，对应的 dep 被触发 notify 方法。dep 会调用所有 watcher 的 update 方法。\n\n- Computed Watcher 的处理逻辑在 *初始化 $options.computed 的 Watcher* 部分已经做了描述\n- 其他的 watcher （不包括设置 sync 为 true，下同）都会交由 queueWatcher 进行处理\n\n想过逻辑存在于文件 `observer/scheduler.js`\n\nqueueWatcher 的作用主要有以下几点：\n\n1. 同一个 watcher 只会被添加到列表中一次，防止被多次调用\n2. 如果正在执行队列，则会判断当前插入的 watcher id，如果已经过了，则立即执行，否则插入到合适位置\n3. 当前处理的所有 watcher 被插入到队列之后进行执行\n\n执行队列的时候，会先对需要执行的 watcher 进行排序处理：\n\n1. 大的方面，从父组件到子组件的方向执行，因为父组件总是先被创建的。\n2. 用户定义的 watcher 先于 render watcher 被处理（用户定义的 watcher 可能会影响 Model 的取值）\n3. 如果子组件被父组件干掉了，那么它会被跳过。\n\n这个顺序也是 watcher 被创建的顺序，这样的话，按照 watcher 的 id 从小到大进行排列就可以了。\n\n然后执行 排重 + 排序 之后的 watcher 队列，这样就保证了，每次数据变更，只会按顺序处理一次需要更新的 watcher。\n\n\n----\n\n这就是 Vue 中的 Reactivity 的具体实现。\n\n可以看到，这部分的整体的实现真的是非常的好。\n\n其中 Dep 和 Watcher 这两个类的设计非常优秀。在 Watcher 中存储了 Dep 的列表，也在 Dep 中存储了 Watcher 的列表。通过这样的设计，既可以在 Watcher 实例中，初始化及更新依赖关系（通过 Deps 和 newDeps），也可以在 dep 中直接通知所有的 watcher 进行更新。\n\nscheduler 的引入很好的解决了什么时候调用 watcher 的问题，最大化的减少了 DOM 操作，再加上 VDOM，就完成了 Model 到 View 的高性能的映射。\n \n\n\n\n\n\n\n​\t\n\n","slug":"reactivity-system-of-vuejs","published":1,"date":"2016-12-22T16:00:00.000Z","updated":"2016-12-27T08:14:38.000Z","_id":"cix78b8l000054as6iuxde2o4","comments":1,"photos":[],"link":"","content":"<p>Reactivity (Vue 中文文档中翻译为响应式) 是 Vue 的非常关键的一部分。通过 Model 与视图的双向绑定，让使用者可以简单的更新页面状态，不再需要直接操作 DOM 进行处理。</p>\n<p>除了 Reactivity，Vue 中还有很多其他的部分，包括：模版解析、VDOM、组件等。<br>为了更好的学习 Vue 中 Reactivity 的实现，将其中 Reactivity 相关部分拿出来成为了单独的部分。这样更容易单独的看这一部分的实现。<br>相关的代码在 <a href=\"https://github.com/ZoomZhao/vue-observer\" target=\"_blank\" rel=\"external\">vue-observer</a></p>\n<a id=\"more\"></a>\n<p>运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install;</div><div class=\"line\">npm run dev;</div></pre></td></tr></table></figure>\n<p>通过访问 <code>example/base</code> 下的 <code>index.html</code>，并修改源码，了解其中的实现。</p>\n<p>Reactivity 监控变化的处理流程参考 Vue 文档中给出的图片：</p>\n<p><img src=\"https://cn.vuejs.org/images/data.png\" alt=\"vue-reactivity\"></p>\n<p>下面从文件介绍以及处理流程两个方面，介绍 Vue 中 Reactivity 的具体实现。</p>\n<h2 id=\"文件功能介绍\"><a href=\"#文件功能介绍\" class=\"headerlink\" title=\"文件功能介绍\"></a>文件功能介绍</h2><h3 id=\"instance\"><a href=\"#instance\" class=\"headerlink\" title=\"instance\"></a>instance</h3><p>instance 中相关的文件，主要是两个：</p>\n<ol>\n<li><p><code>state.js</code></p>\n<p>Vue 中初始化传入的 <code>props</code>，<code>data</code>，<code>compute</code>，<code>watch</code> 的逻辑</p>\n</li>\n<li><p><code>render.js</code></p>\n<p> vue-observer 示例中将 Vue 的 <code>render</code> 方法作了精简，并将 <code>render</code> 方法的调用（其实是 <code>new Watcher()</code>）从 lifecycle 移到了 render.js 文件中。</p>\n</li>\n</ol>\n<h3 id=\"observer\"><a href=\"#observer\" class=\"headerlink\" title=\"observer\"></a>observer</h3><p>vue-observer 的这部分代码，基本完全与 Vue 中的代码一致，是 Vue 中 Reactivity 实现的核心代码。主要包含以下几个文件</p>\n<ol>\n<li><p><code>inde.xjs</code></p>\n<p> 包含类 <code>Observer</code>，主要是为各个需要观察的目标埋点 （<code>new Dep()</code>）</p>\n</li>\n<li><p><code>dep.js</code></p>\n<p> 包含类 <code>Dep</code>  （观察点 类）</p>\n</li>\n<li><p><code>watcher.js</code></p>\n<p> 包含类 <code>Watcher</code>  （观察者 类）</p>\n</li>\n<li><p><code>scheduler.js</code></p>\n<p> 观察者的调度逻辑，主要负责处理，多个 Watcher 需要被调用的情况。防止多次被调用以及在特定情况下按顺序调用。</p>\n</li>\n<li><p><code>array.js</code></p>\n<p> 辅助方法，用于重写 Array 的一些方法，使 Array 的变化可以被观察。</p>\n</li>\n</ol>\n<p>其中的两个重要的类，属性方法如下：</p>\n<h4 id=\"Dep-类\"><a href=\"#Dep-类\" class=\"headerlink\" title=\"Dep 类\"></a>Dep 类</h4><p><strong>属性</strong></p>\n<ul>\n<li><code>target</code>  静态属性，全局唯一，标识当前正在处理的 Watcher</li>\n<li><code>id</code>  ID</li>\n<li><code>subs</code>  Watcher 的列表</li>\n</ul>\n<p><strong>方法</strong></p>\n<ul>\n<li><code>addSub</code>  添加 Watcher</li>\n<li><code>removeSub</code>  移除 Watcher</li>\n<li><code>depend</code>  为自己添加当前 target Watcher，并更新 Watcher 的观察列表</li>\n<li><code>notify</code>  通知所有 Watcher 更新</li>\n</ul>\n<h4 id=\"Watcher\"><a href=\"#Watcher\" class=\"headerlink\" title=\"Watcher\"></a>Watcher</h4><p>根据传入的 expression，得到 value，传给 cb 进行处理。</p>\n<p><strong>属性</strong></p>\n<ul>\n<li><code>deep</code> 用于决定是否完整的轮训，来保证每一个属性都被重新计算依赖</li>\n<li><code>user</code> 是否是用户创建的，是的话会尝试捕获 cb 调用时产生的异常，并提醒</li>\n<li><code>lazy</code> 是否 new 之后不立即执行</li>\n<li><code>sync</code> 是否需要在每次需要 update 的时候立即执行 （不设置的话会交由 scheduler 处理）</li>\n<li><code>expression</code> 传入的方法或表达式</li>\n<li><code>cb</code> 执行之后的回调函数</li>\n<li><code>id</code> </li>\n<li><code>active</code> 是否当前激活状态</li>\n<li><code>dirty</code> 是否是脏数据</li>\n<li><code>deps</code> 与下面的三个一起，用来做 观察目标 （Dep）的动态更新</li>\n<li><code>newDeps</code></li>\n<li><code>depIds</code></li>\n<li><code>newDepIds</code></li>\n<li><code>getter</code> 从 expression 来的 getter 方法</li>\n<li><code>value</code> 当前的取值</li>\n</ul>\n<p><strong>方法</strong></p>\n<ul>\n<li><code>get</code> 默认初始化之后调用，调用传入的 expression，收集依赖，并调用 <code>cleanupDeps</code> 更新依赖关系</li>\n<li><code>addDep</code> 把自身添加到制定 Dep 的观察列表中，另外如果依赖有变化则记录</li>\n<li><code>cleanupDeps</code> 更新依赖关系</li>\n<li><code>update</code> 更新</li>\n<li><code>run</code> 具体的执行方法，负责调用 <code>get</code> 然后根据情况决定是否调用 <code>cb</code></li>\n<li><code>evaluate</code> 只是调用 <code>get</code>，用于清除 <code>dirty</code> 状态</li>\n<li><code>depend</code> 把收集的 deps 统一进行处理，跟 <code>evaluate</code> 一样，都是为 <code>lazy</code> 的 Watcher 服务的</li>\n<li><code>teardown</code> 销毁</li>\n</ul>\n<h3 id=\"util-share-一些工具代码\"><a href=\"#util-share-一些工具代码\" class=\"headerlink\" title=\"util + share 一些工具代码\"></a>util + share 一些工具代码</h3><p>一些工具方法</p>\n<h2 id=\"Reactivity-相关处理流程\"><a href=\"#Reactivity-相关处理流程\" class=\"headerlink\" title=\"Reactivity 相关处理流程\"></a>Reactivity 相关处理流程</h2><p>大概了解了各个文件的功能之后，我们从处理流程的角度，了解下 Vue 中 Reactivity 的具体处理过程。</p>\n<p>Reactivity 的处理包含三个部分：</p>\n<ul>\n<li>初始化观察目标，负责埋点</li>\n<li>初始化 Watcher 并进行依赖收集，等待变更出现</li>\n<li>出现变更，进行更新</li>\n</ul>\n<h3 id=\"初始化观察目标\"><a href=\"#初始化观察目标\" class=\"headerlink\" title=\"初始化观察目标\"></a>初始化观察目标</h3><p>初始化的时候（在 Vue 中 <code>new Vue</code> 或者创建 <code>Component</code>），根据传入的 <code>$options</code> 进行初始化处理。</p>\n<ul>\n<li>初始化 <code>$options.props</code></li>\n<li><p>初始化 <code>$options.data</code></p>\n<p>通过调用 <code>observer/index.js</code> 文件中的 <code>observer</code> 方法，进行埋点。</p>\n<ul>\n<li><p>每个对象（Object 和 Array）都会被分配个观察者 <code>Observer</code></p>\n<p>主要是用于对象变更的观察，例如 Array 的 push 操作；另外一个使用的地方是 Vue.set ，可以在初始化之后依然提供观察的能力。<br>这里有一个很厉害的细节，<code>Observer</code> 对象被放到了 Object 的 <code>__ob__</code> 属性中，既可以在拿到对象的时候都可以回去到对应的 <code>Observer</code>，还起到缓存的作用，防止多次观察同一对象，一举两得。</p>\n</li>\n<li><p>每个属性也会被分配个观察者</p>\n</li>\n</ul>\n<p>这里的观察者采用了闭包的方式，通过 Object.defineProperty 来处理 getter 和 setter。在 get 的时候，处理观察关系，将当前 Watcher 加入到属性的观察者列表中。set 的时候，通过 dep.notify() 触发观察者进行更新。</p>\n<p>这里也有个 childOb 的概念，如果当前的属性存在 childOb，那么 childOb 也要同时被当前 Watcher 观察。</p>\n</li>\n</ul>\n<h3 id=\"初始化-Watcher-并进行依赖收集，等待变更出现\"><a href=\"#初始化-Watcher-并进行依赖收集，等待变更出现\" class=\"headerlink\" title=\"初始化 Watcher 并进行依赖收集，等待变更出现\"></a>初始化 Watcher 并进行依赖收集，等待变更出现</h3><p>初始化 Watcher 分为三个部分：</p>\n<ul>\n<li><p>初始化 $options.computed 的 Watcher</p>\n<p>Vue 中可以通过给 <code>$options</code> 传入 computed 对象来处理一些比较复杂的显示逻辑。这个时候就要根据所依赖的属性，进行观察和重新计算。computed 对应的 Watcher 通过 makeComputedGetter 方法创建，他的特点是，创建的为 Lazy Watcher，new 之后不会立即调用，在 computed 的属性被 get 的时候才需要重新计算。</p>\n<p>对于这类 Watcher，处理的流程为</p>\n<ol>\n<li>初始化的时候，只设置 dirty 为 true，不直接执行传入的 expression。</li>\n<li>每次 Dep 通过 update 的时候只设置 Watcher 的 dirty 为 true，标识需要重新计算。</li>\n<li>在需要获取最新值得时候（这里就是 computed 属性被 get 的时候）调用 watcher.evaluate() 方法，计算 watcher 的最新值，并且手动调用 watcher.depend() 方法来重新计算依赖。</li>\n</ol>\n</li>\n<li><p>初始化 $options.watch 的 Watcher</p>\n<p><code>$options.watch</code> 提供观察 <code>data</code> 的功能，在 <code>data</code> 被修改之后，触发提供的回调函数。</p>\n<p>具体的实现过程中，使用了 Vue 暴露出的全局 API：<code>Vue.$watch</code>，创建一个普通的 watcher，在指定的 expression 的发生改变的时候触发 cb。</p>\n</li>\n<li><p>初始化 render Watcher</p>\n<p>在 Vue 的处理流程中，会把 temple 编译为 render 函数（具体的实现会更加复杂），在 Vue Component 初始化完成的时候，会创建一个 Watcher(render, patchVDom)，根据传入的 render 函数创建依赖关系，如果发现变化，则 PatchVDom， 实现 View 的更新。</p>\n</li>\n</ul>\n<h3 id=\"出现变更，进行更新\"><a href=\"#出现变更，进行更新\" class=\"headerlink\" title=\"出现变更，进行更新\"></a>出现变更，进行更新</h3><p>经过 Watcher 的初始化，Vue 中的 Watcher，分为三类（不包括用户调用 <code>Vue.$watch</code> 传入 sync 参数的情况）</p>\n<ul>\n<li>Computed Watcher（lazy Watcher），update 的时候只标记 dirty 状态，不会进入 queue（后面具体讲队列），属性被 get 的时候直接调用 <code>watcher.evaluate()</code> 进行取值。</li>\n<li>普通 Watcher，包含用户通过 <code>$options.watch</code> 或 <code>Vue.$watch</code> 生成的 watch，在 update 的时候会进入 queue</li>\n<li>Component Watcher，render 方法作为 expOrFn 的 watcher，实现 Model -&gt; DOM 的关键 Watcher，在 update 的时候会进入 queue</li>\n</ul>\n<p>在 Model 被改变的时候，对应的 dep 被触发 notify 方法。dep 会调用所有 watcher 的 update 方法。</p>\n<ul>\n<li>Computed Watcher 的处理逻辑在 <em>初始化 $options.computed 的 Watcher</em> 部分已经做了描述</li>\n<li>其他的 watcher （不包括设置 sync 为 true，下同）都会交由 queueWatcher 进行处理</li>\n</ul>\n<p>想过逻辑存在于文件 <code>observer/scheduler.js</code></p>\n<p>queueWatcher 的作用主要有以下几点：</p>\n<ol>\n<li>同一个 watcher 只会被添加到列表中一次，防止被多次调用</li>\n<li>如果正在执行队列，则会判断当前插入的 watcher id，如果已经过了，则立即执行，否则插入到合适位置</li>\n<li>当前处理的所有 watcher 被插入到队列之后进行执行</li>\n</ol>\n<p>执行队列的时候，会先对需要执行的 watcher 进行排序处理：</p>\n<ol>\n<li>大的方面，从父组件到子组件的方向执行，因为父组件总是先被创建的。</li>\n<li>用户定义的 watcher 先于 render watcher 被处理（用户定义的 watcher 可能会影响 Model 的取值）</li>\n<li>如果子组件被父组件干掉了，那么它会被跳过。</li>\n</ol>\n<p>这个顺序也是 watcher 被创建的顺序，这样的话，按照 watcher 的 id 从小到大进行排列就可以了。</p>\n<p>然后执行 排重 + 排序 之后的 watcher 队列，这样就保证了，每次数据变更，只会按顺序处理一次需要更新的 watcher。</p>\n<hr>\n<p>这就是 Vue 中的 Reactivity 的具体实现。</p>\n<p>可以看到，这部分的整体的实现真的是非常的好。</p>\n<p>其中 Dep 和 Watcher 这两个类的设计非常优秀。在 Watcher 中存储了 Dep 的列表，也在 Dep 中存储了 Watcher 的列表。通过这样的设计，既可以在 Watcher 实例中，初始化及更新依赖关系（通过 Deps 和 newDeps），也可以在 dep 中直接通知所有的 watcher 进行更新。</p>\n<p>scheduler 的引入很好的解决了什么时候调用 watcher 的问题，最大化的减少了 DOM 操作，再加上 VDOM，就完成了 Model 到 View 的高性能的映射。</p>\n<p>​    </p>\n","excerpt":"<p>Reactivity (Vue 中文文档中翻译为响应式) 是 Vue 的非常关键的一部分。通过 Model 与视图的双向绑定，让使用者可以简单的更新页面状态，不再需要直接操作 DOM 进行处理。</p>\n<p>除了 Reactivity，Vue 中还有很多其他的部分，包括：模版解析、VDOM、组件等。<br>为了更好的学习 Vue 中 Reactivity 的实现，将其中 Reactivity 相关部分拿出来成为了单独的部分。这样更容易单独的看这一部分的实现。<br>相关的代码在 <a href=\"https://github.com/ZoomZhao/vue-observer\">vue-observer</a></p>","more":"<p>运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install;</div><div class=\"line\">npm run dev;</div></pre></td></tr></table></figure>\n<p>通过访问 <code>example/base</code> 下的 <code>index.html</code>，并修改源码，了解其中的实现。</p>\n<p>Reactivity 监控变化的处理流程参考 Vue 文档中给出的图片：</p>\n<p><img src=\"https://cn.vuejs.org/images/data.png\" alt=\"vue-reactivity\"></p>\n<p>下面从文件介绍以及处理流程两个方面，介绍 Vue 中 Reactivity 的具体实现。</p>\n<h2 id=\"文件功能介绍\"><a href=\"#文件功能介绍\" class=\"headerlink\" title=\"文件功能介绍\"></a>文件功能介绍</h2><h3 id=\"instance\"><a href=\"#instance\" class=\"headerlink\" title=\"instance\"></a>instance</h3><p>instance 中相关的文件，主要是两个：</p>\n<ol>\n<li><p><code>state.js</code></p>\n<p>Vue 中初始化传入的 <code>props</code>，<code>data</code>，<code>compute</code>，<code>watch</code> 的逻辑</p>\n</li>\n<li><p><code>render.js</code></p>\n<p> vue-observer 示例中将 Vue 的 <code>render</code> 方法作了精简，并将 <code>render</code> 方法的调用（其实是 <code>new Watcher()</code>）从 lifecycle 移到了 render.js 文件中。</p>\n</li>\n</ol>\n<h3 id=\"observer\"><a href=\"#observer\" class=\"headerlink\" title=\"observer\"></a>observer</h3><p>vue-observer 的这部分代码，基本完全与 Vue 中的代码一致，是 Vue 中 Reactivity 实现的核心代码。主要包含以下几个文件</p>\n<ol>\n<li><p><code>inde.xjs</code></p>\n<p> 包含类 <code>Observer</code>，主要是为各个需要观察的目标埋点 （<code>new Dep()</code>）</p>\n</li>\n<li><p><code>dep.js</code></p>\n<p> 包含类 <code>Dep</code>  （观察点 类）</p>\n</li>\n<li><p><code>watcher.js</code></p>\n<p> 包含类 <code>Watcher</code>  （观察者 类）</p>\n</li>\n<li><p><code>scheduler.js</code></p>\n<p> 观察者的调度逻辑，主要负责处理，多个 Watcher 需要被调用的情况。防止多次被调用以及在特定情况下按顺序调用。</p>\n</li>\n<li><p><code>array.js</code></p>\n<p> 辅助方法，用于重写 Array 的一些方法，使 Array 的变化可以被观察。</p>\n</li>\n</ol>\n<p>其中的两个重要的类，属性方法如下：</p>\n<h4 id=\"Dep-类\"><a href=\"#Dep-类\" class=\"headerlink\" title=\"Dep 类\"></a>Dep 类</h4><p><strong>属性</strong></p>\n<ul>\n<li><code>target</code>  静态属性，全局唯一，标识当前正在处理的 Watcher</li>\n<li><code>id</code>  ID</li>\n<li><code>subs</code>  Watcher 的列表</li>\n</ul>\n<p><strong>方法</strong></p>\n<ul>\n<li><code>addSub</code>  添加 Watcher</li>\n<li><code>removeSub</code>  移除 Watcher</li>\n<li><code>depend</code>  为自己添加当前 target Watcher，并更新 Watcher 的观察列表</li>\n<li><code>notify</code>  通知所有 Watcher 更新</li>\n</ul>\n<h4 id=\"Watcher\"><a href=\"#Watcher\" class=\"headerlink\" title=\"Watcher\"></a>Watcher</h4><p>根据传入的 expression，得到 value，传给 cb 进行处理。</p>\n<p><strong>属性</strong></p>\n<ul>\n<li><code>deep</code> 用于决定是否完整的轮训，来保证每一个属性都被重新计算依赖</li>\n<li><code>user</code> 是否是用户创建的，是的话会尝试捕获 cb 调用时产生的异常，并提醒</li>\n<li><code>lazy</code> 是否 new 之后不立即执行</li>\n<li><code>sync</code> 是否需要在每次需要 update 的时候立即执行 （不设置的话会交由 scheduler 处理）</li>\n<li><code>expression</code> 传入的方法或表达式</li>\n<li><code>cb</code> 执行之后的回调函数</li>\n<li><code>id</code> </li>\n<li><code>active</code> 是否当前激活状态</li>\n<li><code>dirty</code> 是否是脏数据</li>\n<li><code>deps</code> 与下面的三个一起，用来做 观察目标 （Dep）的动态更新</li>\n<li><code>newDeps</code></li>\n<li><code>depIds</code></li>\n<li><code>newDepIds</code></li>\n<li><code>getter</code> 从 expression 来的 getter 方法</li>\n<li><code>value</code> 当前的取值</li>\n</ul>\n<p><strong>方法</strong></p>\n<ul>\n<li><code>get</code> 默认初始化之后调用，调用传入的 expression，收集依赖，并调用 <code>cleanupDeps</code> 更新依赖关系</li>\n<li><code>addDep</code> 把自身添加到制定 Dep 的观察列表中，另外如果依赖有变化则记录</li>\n<li><code>cleanupDeps</code> 更新依赖关系</li>\n<li><code>update</code> 更新</li>\n<li><code>run</code> 具体的执行方法，负责调用 <code>get</code> 然后根据情况决定是否调用 <code>cb</code></li>\n<li><code>evaluate</code> 只是调用 <code>get</code>，用于清除 <code>dirty</code> 状态</li>\n<li><code>depend</code> 把收集的 deps 统一进行处理，跟 <code>evaluate</code> 一样，都是为 <code>lazy</code> 的 Watcher 服务的</li>\n<li><code>teardown</code> 销毁</li>\n</ul>\n<h3 id=\"util-share-一些工具代码\"><a href=\"#util-share-一些工具代码\" class=\"headerlink\" title=\"util + share 一些工具代码\"></a>util + share 一些工具代码</h3><p>一些工具方法</p>\n<h2 id=\"Reactivity-相关处理流程\"><a href=\"#Reactivity-相关处理流程\" class=\"headerlink\" title=\"Reactivity 相关处理流程\"></a>Reactivity 相关处理流程</h2><p>大概了解了各个文件的功能之后，我们从处理流程的角度，了解下 Vue 中 Reactivity 的具体处理过程。</p>\n<p>Reactivity 的处理包含三个部分：</p>\n<ul>\n<li>初始化观察目标，负责埋点</li>\n<li>初始化 Watcher 并进行依赖收集，等待变更出现</li>\n<li>出现变更，进行更新</li>\n</ul>\n<h3 id=\"初始化观察目标\"><a href=\"#初始化观察目标\" class=\"headerlink\" title=\"初始化观察目标\"></a>初始化观察目标</h3><p>初始化的时候（在 Vue 中 <code>new Vue</code> 或者创建 <code>Component</code>），根据传入的 <code>$options</code> 进行初始化处理。</p>\n<ul>\n<li>初始化 <code>$options.props</code></li>\n<li><p>初始化 <code>$options.data</code></p>\n<p>通过调用 <code>observer/index.js</code> 文件中的 <code>observer</code> 方法，进行埋点。</p>\n<ul>\n<li><p>每个对象（Object 和 Array）都会被分配个观察者 <code>Observer</code></p>\n<p>主要是用于对象变更的观察，例如 Array 的 push 操作；另外一个使用的地方是 Vue.set ，可以在初始化之后依然提供观察的能力。<br>这里有一个很厉害的细节，<code>Observer</code> 对象被放到了 Object 的 <code>__ob__</code> 属性中，既可以在拿到对象的时候都可以回去到对应的 <code>Observer</code>，还起到缓存的作用，防止多次观察同一对象，一举两得。</p>\n</li>\n<li><p>每个属性也会被分配个观察者</p>\n</li>\n</ul>\n<p>这里的观察者采用了闭包的方式，通过 Object.defineProperty 来处理 getter 和 setter。在 get 的时候，处理观察关系，将当前 Watcher 加入到属性的观察者列表中。set 的时候，通过 dep.notify() 触发观察者进行更新。</p>\n<p>这里也有个 childOb 的概念，如果当前的属性存在 childOb，那么 childOb 也要同时被当前 Watcher 观察。</p>\n</li>\n</ul>\n<h3 id=\"初始化-Watcher-并进行依赖收集，等待变更出现\"><a href=\"#初始化-Watcher-并进行依赖收集，等待变更出现\" class=\"headerlink\" title=\"初始化 Watcher 并进行依赖收集，等待变更出现\"></a>初始化 Watcher 并进行依赖收集，等待变更出现</h3><p>初始化 Watcher 分为三个部分：</p>\n<ul>\n<li><p>初始化 $options.computed 的 Watcher</p>\n<p>Vue 中可以通过给 <code>$options</code> 传入 computed 对象来处理一些比较复杂的显示逻辑。这个时候就要根据所依赖的属性，进行观察和重新计算。computed 对应的 Watcher 通过 makeComputedGetter 方法创建，他的特点是，创建的为 Lazy Watcher，new 之后不会立即调用，在 computed 的属性被 get 的时候才需要重新计算。</p>\n<p>对于这类 Watcher，处理的流程为</p>\n<ol>\n<li>初始化的时候，只设置 dirty 为 true，不直接执行传入的 expression。</li>\n<li>每次 Dep 通过 update 的时候只设置 Watcher 的 dirty 为 true，标识需要重新计算。</li>\n<li>在需要获取最新值得时候（这里就是 computed 属性被 get 的时候）调用 watcher.evaluate() 方法，计算 watcher 的最新值，并且手动调用 watcher.depend() 方法来重新计算依赖。</li>\n</ol>\n</li>\n<li><p>初始化 $options.watch 的 Watcher</p>\n<p><code>$options.watch</code> 提供观察 <code>data</code> 的功能，在 <code>data</code> 被修改之后，触发提供的回调函数。</p>\n<p>具体的实现过程中，使用了 Vue 暴露出的全局 API：<code>Vue.$watch</code>，创建一个普通的 watcher，在指定的 expression 的发生改变的时候触发 cb。</p>\n</li>\n<li><p>初始化 render Watcher</p>\n<p>在 Vue 的处理流程中，会把 temple 编译为 render 函数（具体的实现会更加复杂），在 Vue Component 初始化完成的时候，会创建一个 Watcher(render, patchVDom)，根据传入的 render 函数创建依赖关系，如果发现变化，则 PatchVDom， 实现 View 的更新。</p>\n</li>\n</ul>\n<h3 id=\"出现变更，进行更新\"><a href=\"#出现变更，进行更新\" class=\"headerlink\" title=\"出现变更，进行更新\"></a>出现变更，进行更新</h3><p>经过 Watcher 的初始化，Vue 中的 Watcher，分为三类（不包括用户调用 <code>Vue.$watch</code> 传入 sync 参数的情况）</p>\n<ul>\n<li>Computed Watcher（lazy Watcher），update 的时候只标记 dirty 状态，不会进入 queue（后面具体讲队列），属性被 get 的时候直接调用 <code>watcher.evaluate()</code> 进行取值。</li>\n<li>普通 Watcher，包含用户通过 <code>$options.watch</code> 或 <code>Vue.$watch</code> 生成的 watch，在 update 的时候会进入 queue</li>\n<li>Component Watcher，render 方法作为 expOrFn 的 watcher，实现 Model -&gt; DOM 的关键 Watcher，在 update 的时候会进入 queue</li>\n</ul>\n<p>在 Model 被改变的时候，对应的 dep 被触发 notify 方法。dep 会调用所有 watcher 的 update 方法。</p>\n<ul>\n<li>Computed Watcher 的处理逻辑在 <em>初始化 $options.computed 的 Watcher</em> 部分已经做了描述</li>\n<li>其他的 watcher （不包括设置 sync 为 true，下同）都会交由 queueWatcher 进行处理</li>\n</ul>\n<p>想过逻辑存在于文件 <code>observer/scheduler.js</code></p>\n<p>queueWatcher 的作用主要有以下几点：</p>\n<ol>\n<li>同一个 watcher 只会被添加到列表中一次，防止被多次调用</li>\n<li>如果正在执行队列，则会判断当前插入的 watcher id，如果已经过了，则立即执行，否则插入到合适位置</li>\n<li>当前处理的所有 watcher 被插入到队列之后进行执行</li>\n</ol>\n<p>执行队列的时候，会先对需要执行的 watcher 进行排序处理：</p>\n<ol>\n<li>大的方面，从父组件到子组件的方向执行，因为父组件总是先被创建的。</li>\n<li>用户定义的 watcher 先于 render watcher 被处理（用户定义的 watcher 可能会影响 Model 的取值）</li>\n<li>如果子组件被父组件干掉了，那么它会被跳过。</li>\n</ol>\n<p>这个顺序也是 watcher 被创建的顺序，这样的话，按照 watcher 的 id 从小到大进行排列就可以了。</p>\n<p>然后执行 排重 + 排序 之后的 watcher 队列，这样就保证了，每次数据变更，只会按顺序处理一次需要更新的 watcher。</p>\n<hr>\n<p>这就是 Vue 中的 Reactivity 的具体实现。</p>\n<p>可以看到，这部分的整体的实现真的是非常的好。</p>\n<p>其中 Dep 和 Watcher 这两个类的设计非常优秀。在 Watcher 中存储了 Dep 的列表，也在 Dep 中存储了 Watcher 的列表。通过这样的设计，既可以在 Watcher 实例中，初始化及更新依赖关系（通过 Deps 和 newDeps），也可以在 dep 中直接通知所有的 watcher 进行更新。</p>\n<p>scheduler 的引入很好的解决了什么时候调用 watcher 的问题，最大化的减少了 DOM 操作，再加上 VDOM，就完成了 Model 到 View 的高性能的映射。</p>\n<p>​    </p>"},{"layout":"post","title":"理解 CSS 的 vertical-align 属性","_content":"\n原文地址：[Understanding CSS’s vertical-align Property](http://www.impressivewebs.com/css-vertical-align/) by Louis Lazaris\n\n你看，那个前端开发又在哭诉：“ X，Vertical-align 又不起作用了！”\n\n`vertical-align` 属性看上去很简单，但是确实会给 CSS 新手带来很大的麻烦，即便是 CSS 的老手在这个点上也经常需要停下来把问题搞搞清楚。\n\n接下来，我会尝试用一个容易理解的方式来介绍它。\n\n## 什么是它不会做的 ##\n\n对于 **vertical-align** 有一个很常见的误解是，当它作用于一个元素的时候，它会改变这个元素内部所有内容到指定的位置。例如：当你在一个元素上使用 **vertical-align: top**, 这个元素里面所有内容被期望置顶显示。\n\n<!-- more -->\n\n这让我想起使用 Table 时的情况：\n\n```\n<td valign=\"top\">\n  Whatever...\n</td>\n```\n\n在 Table 中，“valign” 属性（在 HTML5 中被废弃）会让表格中的所有的元素置顶显示。所以，很自然的，当 CSS 开发人员使用 **vertical-align** 时会期望达到同样的效果，可惜的是，它只会在当前元素上起作用。\n\n## 它会做些什么 ##\n**vertical-align** 属性以下三种情况下发挥作用：\n\n1. 它只在 inline 或者 inline-block 元素上有效。\n2. 它只会影响元素自身的对齐方式，而不在它的内容上生效（表格单元格除外）。\n3. 当它被应用于表格的单元格时，影响表格内容的对齐方式，而不是单元格自身。\n\n所以，下面的代码不会产生任何的影响:\n\n```\ndiv {\n  vertical-align: middle; /* this won't do anything */\n}\n```\n\n为什么呢？因为 `<div>` 是 `block-level` 元素，而不是 `inline`。当然如果你改变 `div` 到 `inline` 或者 `inline-block`, **vertical-align** 就会生效了。\n\n也就是说，如果正确使用（在 `inline` 或者 `inline-block` 元素上使用），**vertical-align** 属性会使当前元素根据其余的 `inline` 元素进行垂直定位。\n\n到底元素在垂直方向上处于什么样的位置取决于在同一行的其余元素，或 `line-height` 属性。\n\n## 图示 ##\n下面是一个图示以及部分的解释文本，来协助掌握，在 `inline` 元素上使用垂直定位时到底发生了什么：\n\n![vertical-align](http://cdn.impressivewebs.com/2011-12/vertical-align-pic.jpg)\n\n这里是一个 JSBin ，包含一些 `inline` 元素，其中的一个被置顶显示：\n[JSBin](http://jsbin.com/isuvob/edit#html,live \"Vertical Align\")\n\n## 关键字取值 ##\n\n**vertical-align** 属性可以被设置为以下关键字：\n\n- baseline （默认值）\n- bottom\n- middle\n- sub\n- super\n- text-bottom\n- text-top\n- top\n\n你可能只会使用其中的小部分，但是了解所有可选项总是好的。比如说在 [Demo](http://jsbin.com/isuvob/edit#html,live \"Demo\") 中，因为输入框的 `vertical-align` 属性被设置为 `top`，它根据最高的元素（较大的图片）置顶显示。\n\n但是如果你不想根据图片或者其余的块状的元素进行定位，你可以选择 `text-top` 或者 `text-bottom`， 这样元素就会根据同一行的文本进行定位。\n\n## 关于关键字 Middle ##\n\n悲剧的是：**vertical-align: middle** 并不会像大家都期待的那样按照行内最高的元素进行居中定位，如果赋值为 **middle** 会使当前元素根据假象的小写 “x” （通常被称作 “x-height”） 进行居中定位。所以，根据它的实际作用， **middle** 改为 text-middle 会更合适一点。\n\n在 [Demo](http://jsbin.com/apiqog/edit#html,live) 中，我把字体大小调大，从而让 “x-height” 变得很大，所以一般来说，不应该大量使用 **middle**。\n\n## 非关键字取值 ##\n\n **vertical-align** 还可以取值为 `长度` 以及 `百分比`。以下的例子中的使用都是合法的：\n\n----------\n\n```\ninput {\n        vertical-align: 100px;\n}\n\nspan {\n        vertical-align: 50%;\n}\n\nimg {\n        vertical-align: -300px;\n}\n```\n\n虽然你可以阅读 [W3C关于 **vertical-align** 取值的解释](http://www.w3.org/TR/CSS21/visudet.html#propdef-vertical-align \"W3C关于 **vertical-align** 取值的解释\")，但是我觉得，自己尝试调整取值并查看其中的差异会更加有用。\n\n## 总结 ##\n一句话概括怎么来使用这个一直被误解的属性：\n\n**vertical-align** 属性只在 `inline`、`inline-block` 元素以及单元格内容有效，对于单元格自身无效，它只会影响当前元素的对齐，而不是它的内容。\n\n**PS：** 应该说明是，有些时候当我说 `inline` 元素的时候，`inline-block` 元素是包含在内的。\n\n","source":"_posts/2012-03-18-css-vertical-align.md","raw":"---\nlayout: post\ntitle: 理解 CSS 的 vertical-align 属性\n---\n\n原文地址：[Understanding CSS’s vertical-align Property](http://www.impressivewebs.com/css-vertical-align/) by Louis Lazaris\n\n你看，那个前端开发又在哭诉：“ X，Vertical-align 又不起作用了！”\n\n`vertical-align` 属性看上去很简单，但是确实会给 CSS 新手带来很大的麻烦，即便是 CSS 的老手在这个点上也经常需要停下来把问题搞搞清楚。\n\n接下来，我会尝试用一个容易理解的方式来介绍它。\n\n## 什么是它不会做的 ##\n\n对于 **vertical-align** 有一个很常见的误解是，当它作用于一个元素的时候，它会改变这个元素内部所有内容到指定的位置。例如：当你在一个元素上使用 **vertical-align: top**, 这个元素里面所有内容被期望置顶显示。\n\n<!-- more -->\n\n这让我想起使用 Table 时的情况：\n\n```\n<td valign=\"top\">\n  Whatever...\n</td>\n```\n\n在 Table 中，“valign” 属性（在 HTML5 中被废弃）会让表格中的所有的元素置顶显示。所以，很自然的，当 CSS 开发人员使用 **vertical-align** 时会期望达到同样的效果，可惜的是，它只会在当前元素上起作用。\n\n## 它会做些什么 ##\n**vertical-align** 属性以下三种情况下发挥作用：\n\n1. 它只在 inline 或者 inline-block 元素上有效。\n2. 它只会影响元素自身的对齐方式，而不在它的内容上生效（表格单元格除外）。\n3. 当它被应用于表格的单元格时，影响表格内容的对齐方式，而不是单元格自身。\n\n所以，下面的代码不会产生任何的影响:\n\n```\ndiv {\n  vertical-align: middle; /* this won't do anything */\n}\n```\n\n为什么呢？因为 `<div>` 是 `block-level` 元素，而不是 `inline`。当然如果你改变 `div` 到 `inline` 或者 `inline-block`, **vertical-align** 就会生效了。\n\n也就是说，如果正确使用（在 `inline` 或者 `inline-block` 元素上使用），**vertical-align** 属性会使当前元素根据其余的 `inline` 元素进行垂直定位。\n\n到底元素在垂直方向上处于什么样的位置取决于在同一行的其余元素，或 `line-height` 属性。\n\n## 图示 ##\n下面是一个图示以及部分的解释文本，来协助掌握，在 `inline` 元素上使用垂直定位时到底发生了什么：\n\n![vertical-align](http://cdn.impressivewebs.com/2011-12/vertical-align-pic.jpg)\n\n这里是一个 JSBin ，包含一些 `inline` 元素，其中的一个被置顶显示：\n[JSBin](http://jsbin.com/isuvob/edit#html,live \"Vertical Align\")\n\n## 关键字取值 ##\n\n**vertical-align** 属性可以被设置为以下关键字：\n\n- baseline （默认值）\n- bottom\n- middle\n- sub\n- super\n- text-bottom\n- text-top\n- top\n\n你可能只会使用其中的小部分，但是了解所有可选项总是好的。比如说在 [Demo](http://jsbin.com/isuvob/edit#html,live \"Demo\") 中，因为输入框的 `vertical-align` 属性被设置为 `top`，它根据最高的元素（较大的图片）置顶显示。\n\n但是如果你不想根据图片或者其余的块状的元素进行定位，你可以选择 `text-top` 或者 `text-bottom`， 这样元素就会根据同一行的文本进行定位。\n\n## 关于关键字 Middle ##\n\n悲剧的是：**vertical-align: middle** 并不会像大家都期待的那样按照行内最高的元素进行居中定位，如果赋值为 **middle** 会使当前元素根据假象的小写 “x” （通常被称作 “x-height”） 进行居中定位。所以，根据它的实际作用， **middle** 改为 text-middle 会更合适一点。\n\n在 [Demo](http://jsbin.com/apiqog/edit#html,live) 中，我把字体大小调大，从而让 “x-height” 变得很大，所以一般来说，不应该大量使用 **middle**。\n\n## 非关键字取值 ##\n\n **vertical-align** 还可以取值为 `长度` 以及 `百分比`。以下的例子中的使用都是合法的：\n\n----------\n\n```\ninput {\n        vertical-align: 100px;\n}\n\nspan {\n        vertical-align: 50%;\n}\n\nimg {\n        vertical-align: -300px;\n}\n```\n\n虽然你可以阅读 [W3C关于 **vertical-align** 取值的解释](http://www.w3.org/TR/CSS21/visudet.html#propdef-vertical-align \"W3C关于 **vertical-align** 取值的解释\")，但是我觉得，自己尝试调整取值并查看其中的差异会更加有用。\n\n## 总结 ##\n一句话概括怎么来使用这个一直被误解的属性：\n\n**vertical-align** 属性只在 `inline`、`inline-block` 元素以及单元格内容有效，对于单元格自身无效，它只会影响当前元素的对齐，而不是它的内容。\n\n**PS：** 应该说明是，有些时候当我说 `inline` 元素的时候，`inline-block` 元素是包含在内的。\n\n","slug":"css-vertical-align","published":1,"date":"2012-03-17T16:00:00.000Z","updated":"2016-12-27T08:13:01.000Z","_id":"cix78b8l800064as6pfw183ym","comments":1,"photos":[],"link":"","content":"<p>原文地址：<a href=\"http://www.impressivewebs.com/css-vertical-align/\" target=\"_blank\" rel=\"external\">Understanding CSS’s vertical-align Property</a> by Louis Lazaris</p>\n<p>你看，那个前端开发又在哭诉：“ X，Vertical-align 又不起作用了！”</p>\n<p><code>vertical-align</code> 属性看上去很简单，但是确实会给 CSS 新手带来很大的麻烦，即便是 CSS 的老手在这个点上也经常需要停下来把问题搞搞清楚。</p>\n<p>接下来，我会尝试用一个容易理解的方式来介绍它。</p>\n<h2 id=\"什么是它不会做的\"><a href=\"#什么是它不会做的\" class=\"headerlink\" title=\"什么是它不会做的\"></a>什么是它不会做的</h2><p>对于 <strong>vertical-align</strong> 有一个很常见的误解是，当它作用于一个元素的时候，它会改变这个元素内部所有内容到指定的位置。例如：当你在一个元素上使用 <strong>vertical-align: top</strong>, 这个元素里面所有内容被期望置顶显示。</p>\n<a id=\"more\"></a>\n<p>这让我想起使用 Table 时的情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;td valign=&quot;top&quot;&gt;</div><div class=\"line\">  Whatever...</div><div class=\"line\">&lt;/td&gt;</div></pre></td></tr></table></figure>\n<p>在 Table 中，“valign” 属性（在 HTML5 中被废弃）会让表格中的所有的元素置顶显示。所以，很自然的，当 CSS 开发人员使用 <strong>vertical-align</strong> 时会期望达到同样的效果，可惜的是，它只会在当前元素上起作用。</p>\n<h2 id=\"它会做些什么\"><a href=\"#它会做些什么\" class=\"headerlink\" title=\"它会做些什么\"></a>它会做些什么</h2><p><strong>vertical-align</strong> 属性以下三种情况下发挥作用：</p>\n<ol>\n<li>它只在 inline 或者 inline-block 元素上有效。</li>\n<li>它只会影响元素自身的对齐方式，而不在它的内容上生效（表格单元格除外）。</li>\n<li>当它被应用于表格的单元格时，影响表格内容的对齐方式，而不是单元格自身。</li>\n</ol>\n<p>所以，下面的代码不会产生任何的影响:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">div &#123;</div><div class=\"line\">  vertical-align: middle; /* this won&apos;t do anything */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为什么呢？因为 <code>&lt;div&gt;</code> 是 <code>block-level</code> 元素，而不是 <code>inline</code>。当然如果你改变 <code>div</code> 到 <code>inline</code> 或者 <code>inline-block</code>, <strong>vertical-align</strong> 就会生效了。</p>\n<p>也就是说，如果正确使用（在 <code>inline</code> 或者 <code>inline-block</code> 元素上使用），<strong>vertical-align</strong> 属性会使当前元素根据其余的 <code>inline</code> 元素进行垂直定位。</p>\n<p>到底元素在垂直方向上处于什么样的位置取决于在同一行的其余元素，或 <code>line-height</code> 属性。</p>\n<h2 id=\"图示\"><a href=\"#图示\" class=\"headerlink\" title=\"图示\"></a>图示</h2><p>下面是一个图示以及部分的解释文本，来协助掌握，在 <code>inline</code> 元素上使用垂直定位时到底发生了什么：</p>\n<p><img src=\"http://cdn.impressivewebs.com/2011-12/vertical-align-pic.jpg\" alt=\"vertical-align\"></p>\n<p>这里是一个 JSBin ，包含一些 <code>inline</code> 元素，其中的一个被置顶显示：<br><a href=\"http://jsbin.com/isuvob/edit#html,live\" title=\"Vertical Align\" target=\"_blank\" rel=\"external\">JSBin</a></p>\n<h2 id=\"关键字取值\"><a href=\"#关键字取值\" class=\"headerlink\" title=\"关键字取值\"></a>关键字取值</h2><p><strong>vertical-align</strong> 属性可以被设置为以下关键字：</p>\n<ul>\n<li>baseline （默认值）</li>\n<li>bottom</li>\n<li>middle</li>\n<li>sub</li>\n<li>super</li>\n<li>text-bottom</li>\n<li>text-top</li>\n<li>top</li>\n</ul>\n<p>你可能只会使用其中的小部分，但是了解所有可选项总是好的。比如说在 <a href=\"http://jsbin.com/isuvob/edit#html,live\" title=\"Demo\" target=\"_blank\" rel=\"external\">Demo</a> 中，因为输入框的 <code>vertical-align</code> 属性被设置为 <code>top</code>，它根据最高的元素（较大的图片）置顶显示。</p>\n<p>但是如果你不想根据图片或者其余的块状的元素进行定位，你可以选择 <code>text-top</code> 或者 <code>text-bottom</code>， 这样元素就会根据同一行的文本进行定位。</p>\n<h2 id=\"关于关键字-Middle\"><a href=\"#关于关键字-Middle\" class=\"headerlink\" title=\"关于关键字 Middle\"></a>关于关键字 Middle</h2><p>悲剧的是：<strong>vertical-align: middle</strong> 并不会像大家都期待的那样按照行内最高的元素进行居中定位，如果赋值为 <strong>middle</strong> 会使当前元素根据假象的小写 “x” （通常被称作 “x-height”） 进行居中定位。所以，根据它的实际作用， <strong>middle</strong> 改为 text-middle 会更合适一点。</p>\n<p>在 <a href=\"http://jsbin.com/apiqog/edit#html,live\" target=\"_blank\" rel=\"external\">Demo</a> 中，我把字体大小调大，从而让 “x-height” 变得很大，所以一般来说，不应该大量使用 <strong>middle</strong>。</p>\n<h2 id=\"非关键字取值\"><a href=\"#非关键字取值\" class=\"headerlink\" title=\"非关键字取值\"></a>非关键字取值</h2><p> <strong>vertical-align</strong> 还可以取值为 <code>长度</code> 以及 <code>百分比</code>。以下的例子中的使用都是合法的：</p>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">input &#123;</div><div class=\"line\">        vertical-align: 100px;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">span &#123;</div><div class=\"line\">        vertical-align: 50%;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">img &#123;</div><div class=\"line\">        vertical-align: -300px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>虽然你可以阅读 <a href=\"http://www.w3.org/TR/CSS21/visudet.html#propdef-vertical-align\" title=\"W3C关于 **vertical-align** 取值的解释\" target=\"_blank\" rel=\"external\">W3C关于 <strong>vertical-align</strong> 取值的解释</a>，但是我觉得，自己尝试调整取值并查看其中的差异会更加有用。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>一句话概括怎么来使用这个一直被误解的属性：</p>\n<p><strong>vertical-align</strong> 属性只在 <code>inline</code>、<code>inline-block</code> 元素以及单元格内容有效，对于单元格自身无效，它只会影响当前元素的对齐，而不是它的内容。</p>\n<p><strong>PS：</strong> 应该说明是，有些时候当我说 <code>inline</code> 元素的时候，<code>inline-block</code> 元素是包含在内的。</p>\n","excerpt":"<p>原文地址：<a href=\"http://www.impressivewebs.com/css-vertical-align/\">Understanding CSS’s vertical-align Property</a> by Louis Lazaris</p>\n<p>你看，那个前端开发又在哭诉：“ X，Vertical-align 又不起作用了！”</p>\n<p><code>vertical-align</code> 属性看上去很简单，但是确实会给 CSS 新手带来很大的麻烦，即便是 CSS 的老手在这个点上也经常需要停下来把问题搞搞清楚。</p>\n<p>接下来，我会尝试用一个容易理解的方式来介绍它。</p>\n<h2 id=\"什么是它不会做的\"><a href=\"#什么是它不会做的\" class=\"headerlink\" title=\"什么是它不会做的\"></a>什么是它不会做的</h2><p>对于 <strong>vertical-align</strong> 有一个很常见的误解是，当它作用于一个元素的时候，它会改变这个元素内部所有内容到指定的位置。例如：当你在一个元素上使用 <strong>vertical-align: top</strong>, 这个元素里面所有内容被期望置顶显示。</p>","more":"<p>这让我想起使用 Table 时的情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;td valign=&quot;top&quot;&gt;</div><div class=\"line\">  Whatever...</div><div class=\"line\">&lt;/td&gt;</div></pre></td></tr></table></figure>\n<p>在 Table 中，“valign” 属性（在 HTML5 中被废弃）会让表格中的所有的元素置顶显示。所以，很自然的，当 CSS 开发人员使用 <strong>vertical-align</strong> 时会期望达到同样的效果，可惜的是，它只会在当前元素上起作用。</p>\n<h2 id=\"它会做些什么\"><a href=\"#它会做些什么\" class=\"headerlink\" title=\"它会做些什么\"></a>它会做些什么</h2><p><strong>vertical-align</strong> 属性以下三种情况下发挥作用：</p>\n<ol>\n<li>它只在 inline 或者 inline-block 元素上有效。</li>\n<li>它只会影响元素自身的对齐方式，而不在它的内容上生效（表格单元格除外）。</li>\n<li>当它被应用于表格的单元格时，影响表格内容的对齐方式，而不是单元格自身。</li>\n</ol>\n<p>所以，下面的代码不会产生任何的影响:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">div &#123;</div><div class=\"line\">  vertical-align: middle; /* this won&apos;t do anything */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为什么呢？因为 <code>&lt;div&gt;</code> 是 <code>block-level</code> 元素，而不是 <code>inline</code>。当然如果你改变 <code>div</code> 到 <code>inline</code> 或者 <code>inline-block</code>, <strong>vertical-align</strong> 就会生效了。</p>\n<p>也就是说，如果正确使用（在 <code>inline</code> 或者 <code>inline-block</code> 元素上使用），<strong>vertical-align</strong> 属性会使当前元素根据其余的 <code>inline</code> 元素进行垂直定位。</p>\n<p>到底元素在垂直方向上处于什么样的位置取决于在同一行的其余元素，或 <code>line-height</code> 属性。</p>\n<h2 id=\"图示\"><a href=\"#图示\" class=\"headerlink\" title=\"图示\"></a>图示</h2><p>下面是一个图示以及部分的解释文本，来协助掌握，在 <code>inline</code> 元素上使用垂直定位时到底发生了什么：</p>\n<p><img src=\"http://cdn.impressivewebs.com/2011-12/vertical-align-pic.jpg\" alt=\"vertical-align\"></p>\n<p>这里是一个 JSBin ，包含一些 <code>inline</code> 元素，其中的一个被置顶显示：<br><a href=\"http://jsbin.com/isuvob/edit#html,live\" title=\"Vertical Align\">JSBin</a></p>\n<h2 id=\"关键字取值\"><a href=\"#关键字取值\" class=\"headerlink\" title=\"关键字取值\"></a>关键字取值</h2><p><strong>vertical-align</strong> 属性可以被设置为以下关键字：</p>\n<ul>\n<li>baseline （默认值）</li>\n<li>bottom</li>\n<li>middle</li>\n<li>sub</li>\n<li>super</li>\n<li>text-bottom</li>\n<li>text-top</li>\n<li>top</li>\n</ul>\n<p>你可能只会使用其中的小部分，但是了解所有可选项总是好的。比如说在 <a href=\"http://jsbin.com/isuvob/edit#html,live\" title=\"Demo\">Demo</a> 中，因为输入框的 <code>vertical-align</code> 属性被设置为 <code>top</code>，它根据最高的元素（较大的图片）置顶显示。</p>\n<p>但是如果你不想根据图片或者其余的块状的元素进行定位，你可以选择 <code>text-top</code> 或者 <code>text-bottom</code>， 这样元素就会根据同一行的文本进行定位。</p>\n<h2 id=\"关于关键字-Middle\"><a href=\"#关于关键字-Middle\" class=\"headerlink\" title=\"关于关键字 Middle\"></a>关于关键字 Middle</h2><p>悲剧的是：<strong>vertical-align: middle</strong> 并不会像大家都期待的那样按照行内最高的元素进行居中定位，如果赋值为 <strong>middle</strong> 会使当前元素根据假象的小写 “x” （通常被称作 “x-height”） 进行居中定位。所以，根据它的实际作用， <strong>middle</strong> 改为 text-middle 会更合适一点。</p>\n<p>在 <a href=\"http://jsbin.com/apiqog/edit#html,live\">Demo</a> 中，我把字体大小调大，从而让 “x-height” 变得很大，所以一般来说，不应该大量使用 <strong>middle</strong>。</p>\n<h2 id=\"非关键字取值\"><a href=\"#非关键字取值\" class=\"headerlink\" title=\"非关键字取值\"></a>非关键字取值</h2><p> <strong>vertical-align</strong> 还可以取值为 <code>长度</code> 以及 <code>百分比</code>。以下的例子中的使用都是合法的：</p>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">input &#123;</div><div class=\"line\">        vertical-align: 100px;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">span &#123;</div><div class=\"line\">        vertical-align: 50%;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">img &#123;</div><div class=\"line\">        vertical-align: -300px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>虽然你可以阅读 <a href=\"http://www.w3.org/TR/CSS21/visudet.html#propdef-vertical-align\" title=\"W3C关于 **vertical-align** 取值的解释\">W3C关于 <strong>vertical-align</strong> 取值的解释</a>，但是我觉得，自己尝试调整取值并查看其中的差异会更加有用。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>一句话概括怎么来使用这个一直被误解的属性：</p>\n<p><strong>vertical-align</strong> 属性只在 <code>inline</code>、<code>inline-block</code> 元素以及单元格内容有效，对于单元格自身无效，它只会影响当前元素的对齐，而不是它的内容。</p>\n<p><strong>PS：</strong> 应该说明是，有些时候当我说 <code>inline</code> 元素的时候，<code>inline-block</code> 元素是包含在内的。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cix78b8kr00024as6qkjx6pxq","category_id":"cix78b8ly00074as6yysb9q9f","_id":"cix78b8m9000b4as6f6nrzspz"},{"post_id":"cix78b8kl00014as6u0g495wd","category_id":"cix78b8ly00074as6yysb9q9f","_id":"cix78b8md000e4as6ircc8tdp"},{"post_id":"cix78b8ku00034as6je67sg9i","category_id":"cix78b8ly00074as6yysb9q9f","_id":"cix78b8mf000h4as687r724i4"},{"post_id":"cix78b8ky00044as6g4ln466y","category_id":"cix78b8ly00074as6yysb9q9f","_id":"cix78b8or000u4as6moh1qv7m"}],"PostTag":[{"post_id":"cix78b8kr00024as6qkjx6pxq","tag_id":"cix78b8m000084as6hnrp4grx","_id":"cix78b8mf000g4as694b2bd6u"},{"post_id":"cix78b8kr00024as6qkjx6pxq","tag_id":"cix78b8m5000a4as6fsm2nzmv","_id":"cix78b8mf000i4as6mestkgff"},{"post_id":"cix78b8kr00024as6qkjx6pxq","tag_id":"cix78b8mc000d4as6m9llwzhz","_id":"cix78b8mg000k4as60jo5cwj7"},{"post_id":"cix78b8kl00014as6u0g495wd","tag_id":"cix78b8m000084as6hnrp4grx","_id":"cix78b8mj000n4as6rkycsty1"},{"post_id":"cix78b8kl00014as6u0g495wd","tag_id":"cix78b8m5000a4as6fsm2nzmv","_id":"cix78b8mm000o4as6qq1iphw5"},{"post_id":"cix78b8kl00014as6u0g495wd","tag_id":"cix78b8mg000l4as60ji8d3f8","_id":"cix78b8mn000q4as6zfwaysjs"},{"post_id":"cix78b8ku00034as6je67sg9i","tag_id":"cix78b8mh000m4as6c2fkpd5k","_id":"cix78b8mo000r4as6lc8f3d8l"},{"post_id":"cix78b8ku00034as6je67sg9i","tag_id":"cix78b8mm000p4as6a6e0xadr","_id":"cix78b8mp000s4as6r33iy83v"},{"post_id":"cix78b8ky00044as6g4ln466y","tag_id":"cix78b8mh000m4as6c2fkpd5k","_id":"cix78b8or000t4as6d07zo6fa"},{"post_id":"cix78b8ky00044as6g4ln466y","tag_id":"cix78b8mm000p4as6a6e0xadr","_id":"cix78b8or000v4as6v3u20ke5"}],"Tag":[{"name":"Application Cache","_id":"cix78b8m000084as6hnrp4grx"},{"name":"AppCache","_id":"cix78b8m5000a4as6fsm2nzmv"},{"name":"坑","_id":"cix78b8mc000d4as6m9llwzhz"},{"name":"使用","_id":"cix78b8mg000l4as60ji8d3f8"},{"name":"Medium","_id":"cix78b8mh000m4as6c2fkpd5k"},{"name":"CSS","_id":"cix78b8mm000p4as6a6e0xadr"}]}}